// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v5.27.1
// source: shared.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  ContentType,
  contentTypeFromJSON,
  contentTypeToJSON,
  ConvGroupAtType,
  convGroupAtTypeFromJSON,
  convGroupAtTypeToJSON,
  ConvRecvMsgOpt,
  convRecvMsgOptFromJSON,
  convRecvMsgOptToJSON,
  MsgFrom,
  msgFromFromJSON,
  msgFromToJSON,
  MsgStatus,
  msgStatusFromJSON,
  msgStatusToJSON,
  OfflinePushInfo,
  Platform,
  platformFromJSON,
  platformToJSON,
  SessionType,
  sessionTypeFromJSON,
  sessionTypeToJSON,
} from "./common";

export const protobufPackage = "openim.sdk.shared";

export enum GroupStatus {
  Default = 0,
  Dismissed = 2,
  UNRECOGNIZED = -1,
}

export function groupStatusFromJSON(object: any): GroupStatus {
  switch (object) {
    case 0:
    case "Default":
      return GroupStatus.Default;
    case 2:
    case "Dismissed":
      return GroupStatus.Dismissed;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GroupStatus.UNRECOGNIZED;
  }
}

export function groupStatusToJSON(object: GroupStatus): string {
  switch (object) {
    case GroupStatus.Default:
      return "Default";
    case GroupStatus.Dismissed:
      return "Dismissed";
    case GroupStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GroupFilter {
  All = 0,
  Owner = 1,
  Admin = 2,
  OrdinaryUsers = 3,
  AdminAndOrdinaryUsers = 4,
  OwnerAndAdmin = 5,
  UNRECOGNIZED = -1,
}

export function groupFilterFromJSON(object: any): GroupFilter {
  switch (object) {
    case 0:
    case "All":
      return GroupFilter.All;
    case 1:
    case "Owner":
      return GroupFilter.Owner;
    case 2:
    case "Admin":
      return GroupFilter.Admin;
    case 3:
    case "OrdinaryUsers":
      return GroupFilter.OrdinaryUsers;
    case 4:
    case "AdminAndOrdinaryUsers":
      return GroupFilter.AdminAndOrdinaryUsers;
    case 5:
    case "OwnerAndAdmin":
      return GroupFilter.OwnerAndAdmin;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GroupFilter.UNRECOGNIZED;
  }
}

export function groupFilterToJSON(object: GroupFilter): string {
  switch (object) {
    case GroupFilter.All:
      return "All";
    case GroupFilter.Owner:
      return "Owner";
    case GroupFilter.Admin:
      return "Admin";
    case GroupFilter.OrdinaryUsers:
      return "OrdinaryUsers";
    case GroupFilter.AdminAndOrdinaryUsers:
      return "AdminAndOrdinaryUsers";
    case GroupFilter.OwnerAndAdmin:
      return "OwnerAndAdmin";
    case GroupFilter.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface UserInfo {
  userID: string;
  nickname: string;
  faceURL: string;
  ex: string;
  createTime: number;
  appMangerLevel: number;
  globalRecvMsgOpt: number;
  attached: string;
}

export interface CommandInfo {
  userID: string;
  type: number;
  createTime: number;
  uuid: string;
  value: string;
  ex: string;
}

export interface FriendInfo {
  ownerUserID: string;
  friendUserID: string;
  remark: string;
  createTime: number;
  addSource: number;
  operatorUserID: string;
  nickname: string;
  faceURL: string;
  ex: string;
  attachedInfo: string;
  isPinned: boolean;
}

export interface BlackInfo {
  ownerUserID: string;
  blockUserID: string;
  nickname: string;
  faceURL: string;
  createTime: number;
  addSource: number;
  operatorUserID: string;
  ex: string;
  attached: string;
}

export interface FriendRequestInfo {
  fromUserID: string;
  fromNickname: string;
  fromFaceURL: string;
  toUserID: string;
  toNickname: string;
  toFaceURL: string;
  handleResult: number;
  reqMsg: string;
  createTime: number;
  handlerUserID: string;
  handleMsg: string;
  handleTime: number;
  ex: string;
  attached: string;
}

export interface GroupInfo {
  groupID: string;
  groupName: string;
  notification: string;
  introduction: string;
  faceURL: string;
  ownerUserID: string;
  createTime: number;
  memberCount: number;
  ex: string;
  status: GroupStatus;
  creatorUserID: string;
  needVerification: number;
  lookMemberInfo: number;
  applyMemberFriend: number;
  notificationUpdateTime: number;
  notificationUserID: string;
  attachedInfo: string;
}

export interface GroupMemberInfo {
  groupID: string;
  userID: string;
  nickname: string;
  faceURL: string;
  roleLevel: number;
  joinTime: number;
  joinSource: number;
  inviterUserID: string;
  muteEndTime: number;
  operatorUserID: string;
  ex: string;
  attachedInfo: string;
}

export interface GroupRequestInfo {
  groupID: string;
  groupName: string;
  notification: string;
  introduction: string;
  groupFaceURL: string;
  createTime: number;
  status: number;
  creatorUserID: string;
  groupType: number;
  ownerUserID: string;
  memberCount: number;
  userID: string;
  nickname: string;
  userFaceURL: string;
  handleResult: number;
  reqMsg: string;
  handledMsg: string;
  reqTime: number;
  handleUserID: string;
  handledTime: number;
  ex: string;
  attachedInfo: string;
  joinSource: number;
  inviterUserID: string;
}

export interface Conversation {
  conversationID: string;
  conversationType: SessionType;
  userID: string;
  groupID: string;
  showName: string;
  faceURL: string;
  recvMsgOpt: ConvRecvMsgOpt;
  unreadCount: number;
  groupAtType: ConvGroupAtType;
  latestMsg: IMMessage | undefined;
  latestMsgSendTime: number;
  draftText: string;
  draftTextTime: number;
  isPinned: boolean;
  isPrivateChat: boolean;
  burnDuration: number;
  ex: string;
  msgDestructTime: number;
  isMsgDestruct: boolean;
}

export interface AtInfo {
  atUserID: string;
  groupNickname: string;
}

export interface ImageInfo {
  width: number;
  height: number;
  type: string;
  size: number;
}

export interface PictureBaseInfo {
  uuid: string;
  type: string;
  size: number;
  width: number;
  height: number;
  url: string;
}

export interface SoundBaseInfo {
  uuid: string;
  soundPath: string;
  sourceURL: string;
  dataSize: number;
  duration: number;
  soundType: string;
}

export interface VideoBaseInfo {
  videoPath: string;
  videoUUID: string;
  videoURL: string;
  videoType: string;
  videoSize: number;
  duration: number;
  snapshotPath: string;
  snapshotUUID: string;
  snapshotSize: number;
  snapshotURL: string;
  snapshotWidth: number;
  snapshotHeight: number;
  snapshotType: string;
}

export interface FileBaseInfo {
  filePath: string;
  uuid: string;
  sourceURL: string;
  fileName: string;
  fileSize: number;
  fileType: string;
}

export interface TextElem {
  content: string;
}

export interface CardElem {
  userID: string;
  nickname: string;
  faceURL: string;
  ex: string;
}

export interface PictureElem {
  sourcePath: string;
  sourcePicture: PictureBaseInfo | undefined;
  bigPicture: PictureBaseInfo | undefined;
  snapshotPicture: PictureBaseInfo | undefined;
}

export interface SoundElem {
  uuid: string;
  soundPath: string;
  sourceURL: string;
  dataSize: number;
  duration: number;
  soundType: string;
}

export interface VideoElem {
  videoPath: string;
  videoUUID: string;
  videoURL: string;
  videoType: string;
  videoSize: number;
  duration: number;
  snapshotPath: string;
  snapshotUUID: string;
  snapshotSize: number;
  snapshotURL: string;
  snapshotWidth: number;
  snapshotHeight: number;
  snapshotType: string;
}

export interface FileElem {
  filePath: string;
  uuid: string;
  sourceURL: string;
  fileName: string;
  fileSize: number;
  fileType: string;
}

export interface MessageEntity {
  type: string;
  offset: number;
  length: number;
  url: string;
  ex: string;
}

export interface MergeElem {
  title: string;
  abstractList: string[];
  multiMessage: IMMessage[];
  messageEntityList: MessageEntity[];
}

export interface AtTextElem {
  text: string;
  atUserList: string[];
  atUsersInfo: AtInfo[];
  quoteMessage: IMMessage | undefined;
  isAtSelf: boolean;
}

export interface FaceElem {
  index: number;
  data: string;
}

export interface LocationElem {
  description: string;
  longitude: number;
  latitude: number;
}

export interface CustomElem {
  data: string;
  description: string;
  extension: string;
}

export interface QuoteElem {
  text: string;
  quoteMessage: IMMessage | undefined;
  messageEntityList: MessageEntity[];
}

export interface AdvancedTextElem {
  text: string;
  messageEntityList: MessageEntity[];
}

export interface TypingElem {
  msgTips: string;
}

export interface StreamElem {
  type: string;
  content: string;
  packets: string[];
  end: boolean;
}

export interface GroupHasReadInfo {
  hasReadUserIDList: string[];
  hasReadCount: number;
  groupMemberCount: number;
}

export interface UploadProgress {
  total: number;
  save: number;
  current: number;
  uploadID: string;
}

export interface AttachedInfoElem {
  groupHasReadInfo: GroupHasReadInfo | undefined;
  isPrivateChat: boolean;
  burnDuration: number;
  hasReadTime: number;
  progress: UploadProgress | undefined;
}

/** OnGroupCreated() */
export interface GroupCreatedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  memberList: GroupMemberInfo[];
  operationTime: number;
  groupOwnerUser: GroupMemberInfo | undefined;
}

/** OnGroupInfoSet() */
export interface GroupInfoSetTips {
  /** who do this */
  opUser: GroupMemberInfo | undefined;
  muteTime: number;
  group: GroupInfo | undefined;
}

export interface GroupInfoSetNameTips {
  /** who do this */
  opUser: GroupMemberInfo | undefined;
  group: GroupInfo | undefined;
}

export interface GroupInfoSetAnnouncementTips {
  /** who do this */
  opUser: GroupMemberInfo | undefined;
  group: GroupInfo | undefined;
}

/** OnJoinGroupApplication() */
export interface JoinGroupApplicationTips {
  group: GroupInfo | undefined;
  applicant: UserInfo | undefined;
  reqMsg: string;
}

/**
 * OnQuitGroup()
 * Actively leave the group
 */
export interface MemberQuitTips {
  group: GroupInfo | undefined;
  quitUser: GroupMemberInfo | undefined;
  operationTime: number;
}

/** OnApplicationGroupAccepted() */
export interface GroupApplicationAcceptedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  handleMsg: string;
  /** admin(==1) or applicant(==0) */
  receiverAs: number;
}

/** OnApplicationGroupRejected() */
export interface GroupApplicationRejectedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  handleMsg: string;
  /** admin(==1) or applicant(==0) */
  receiverAs: number;
}

/** OnTransferGroupOwner() */
export interface GroupOwnerTransferredTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  newGroupOwner: GroupMemberInfo | undefined;
  oldGroupOwner: string;
  operationTime: number;
  oldGroupOwnerInfo: GroupMemberInfo | undefined;
}

/** OnMemberKicked() */
export interface MemberKickedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  kickedUserList: GroupMemberInfo[];
  operationTime: number;
}

/** OnMemberInvited() */
export interface MemberInvitedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  invitedUserList: GroupMemberInfo[];
  operationTime: number;
  inviterUser: GroupMemberInfo | undefined;
}

/** Actively join the group */
export interface MemberEnterTips {
  group: GroupInfo | undefined;
  entrantUser: GroupMemberInfo | undefined;
  operationTime: number;
}

export interface GroupDismissedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  operationTime: number;
}

export interface GroupMemberMutedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  operationTime: number;
  mutedUser: GroupMemberInfo | undefined;
  mutedSeconds: number;
}

export interface GroupMemberCancelMutedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  operationTime: number;
  mutedUser: GroupMemberInfo | undefined;
}

export interface GroupMutedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  operationTime: number;
}

export interface GroupCancelMutedTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  operationTime: number;
}

export interface GroupMemberInfoSetTips {
  group: GroupInfo | undefined;
  opUser: GroupMemberInfo | undefined;
  operationTime: number;
  changedUser: GroupMemberInfo | undefined;
}

export interface FriendApplication {
  addTime: number;
  addSource: string;
  addWording: string;
}

export interface FromToUserID {
  fromUserID: string;
  toUserID: string;
}

/** FromUserID apply to add ToUserID */
export interface FriendApplicationTips {
  fromToUserID: FromToUserID | undefined;
}

/** FromUserID accept or reject ToUserID */
export interface FriendApplicationApprovedTips {
  fromToUserID: FromToUserID | undefined;
}

/** FromUserID accept or reject ToUserID */
export interface FriendApplicationRejectedTips {
  fromToUserID: FromToUserID | undefined;
  handleMsg: string;
}

/** FromUserID  Added a friend ToUserID */
export interface FriendAddedTips {
  friend: FriendInfo | undefined;
  operationTime: number;
  /** who do this */
  opUser: UserInfo | undefined;
}

/** FromUserID  deleted a friend ToUserID */
export interface FriendDeletedTips {
  /** from：owner； to：friend */
  fromToUserID: FromToUserID | undefined;
}

export interface BlackAddedTips {
  /** from：owner； to：black */
  fromToUserID: FromToUserID | undefined;
}

export interface BlackDeletedTips {
  /** from：owner； to：black */
  fromToUserID: FromToUserID | undefined;
}

export interface FriendInfoChangedTips {
  /** from：changed； to：friend */
  fromToUserID: FromToUserID | undefined;
}

/** ////////////////////user///////////////////// */
export interface UserInfoUpdatedTips {
  userID: string;
}

export interface UserStatusChangeTips {
  fromUserID: string;
  toUserID: string;
  status: number;
  platformID: number;
}

export interface UserCommandAddTips {
  fromUserID: string;
  toUserID: string;
}

export interface UserCommandUpdateTips {
  fromUserID: string;
  toUserID: string;
}

export interface UserCommandDeleteTips {
  fromUserID: string;
  toUserID: string;
}

/** ////////////////////conversation///////////////////// */
export interface ConversationUpdateTips {
  userID: string;
  conversationIDList: string[];
}

export interface ConversationSetPrivateTips {
  recvID: string;
  sendID: string;
  isPrivate: boolean;
  conversationID: string;
}

export interface ConversationHasReadTips {
  userID: string;
  conversationID: string;
  hasReadSeq: number;
  unreadCountTime: number;
}

export interface DeleteMessageTips {
  opUserID: string;
  userID: string;
  seqs: number[];
}

export interface RevokeMsgTips {
  revokerUserID: string;
  clientMsgID: string;
  revokeTime: number;
  sesstionType: number;
  seq: number;
  conversationID: string;
  isAdminRevoke: boolean;
}

export interface MessageRevokedContent {
  revokerID: string;
  revokerRole: number;
  clientMsgID: string;
  revokerNickname: string;
  revokeTime: number;
  sourceMessageSendTime: number;
  sourceMessageSendID: string;
  sourceMessageSenderNickname: string;
  sessionType: number;
  seq: number;
  ex: string;
}

export interface ClearConversationTips {
  userID: string;
  conversationIDs: string[];
}

export interface DeleteMsgsTips {
  userID: string;
  conversationID: string;
  seqs: number[];
}

export interface MarkAsReadTips {
  markAsReadUserID: string;
  conversationID: string;
  seqs: number[];
  hasReadSeq: number;
}

export interface FriendsInfoUpdateTips {
  fromToUserID: FromToUserID | undefined;
  friendIDs: string[];
}

export interface SubUserOnlineStatusElem {
  userID: string;
  onlinePlatformIDs: number[];
}

export interface SubUserOnlineStatusTips {
  subscribers: SubUserOnlineStatusElem[];
}

export interface SubUserOnlineStatus {
  subscribeUserID: string[];
  unsubscribeUserID: string[];
}

export interface StreamMsgTips {
  conversationID: string;
  clientMsgID: string;
  startIndex: number;
  packets: string[];
  end: boolean;
}

export interface IMMessage {
  clientMsgID: string;
  serverMsgID: string;
  createTime: number;
  sendTime: number;
  sessionType: SessionType;
  sendID: string;
  recvID: string;
  msgFrom: MsgFrom;
  contentType: ContentType;
  senderPlatformID: Platform;
  senderNickname: string;
  senderFaceURL: string;
  groupID: string;
  seq: number;
  isRead: boolean;
  status: MsgStatus;
  offlinePush: OfflinePushInfo | undefined;
  ex: string;
  localEx: string;
  attachedInfoElem: AttachedInfoElem | undefined;
  textElem?: TextElem | undefined;
  cardElem?: CardElem | undefined;
  pictureElem?: PictureElem | undefined;
  soundElem?: SoundElem | undefined;
  videoElem?: VideoElem | undefined;
  fileElem?: FileElem | undefined;
  mergeElem?: MergeElem | undefined;
  atTextElem?: AtTextElem | undefined;
  faceElem?: FaceElem | undefined;
  locationElem?: LocationElem | undefined;
  customElem?: CustomElem | undefined;
  quoteElem?: QuoteElem | undefined;
  advancedTextElem?: AdvancedTextElem | undefined;
  typingElem?: TypingElem | undefined;
  streamElem?: StreamElem | undefined;
  groupCreatedTips?: GroupCreatedTips | undefined;
  groupInfoSetTips?: GroupInfoSetTips | undefined;
  groupInfoSetNameTips?: GroupInfoSetNameTips | undefined;
  groupInfoSetAnnouncementTips?: GroupInfoSetAnnouncementTips | undefined;
  joinGroupApplicationTips?: JoinGroupApplicationTips | undefined;
  memberQuitTips?: MemberQuitTips | undefined;
  groupApplicationAcceptedTips?: GroupApplicationAcceptedTips | undefined;
  groupApplicationRejectedTips?: GroupApplicationRejectedTips | undefined;
  groupOwnerTransferredTips?: GroupOwnerTransferredTips | undefined;
  memberKickedTips?: MemberKickedTips | undefined;
  memberInvitedTips?: MemberInvitedTips | undefined;
  memberEnterTips?: MemberEnterTips | undefined;
  groupDismissedTips?: GroupDismissedTips | undefined;
  groupMemberMutedTips?: GroupMemberMutedTips | undefined;
  groupMemberCancelMutedTips?: GroupMemberCancelMutedTips | undefined;
  groupMutedTips?: GroupMutedTips | undefined;
  groupCancelMutedTips?: GroupCancelMutedTips | undefined;
  groupMemberInfoSetTips?: GroupMemberInfoSetTips | undefined;
  friendApplicationTips?: FriendApplicationTips | undefined;
  friendApplicationApprovedTips?: FriendApplicationApprovedTips | undefined;
  friendApplicationRejectedTips?: FriendApplicationRejectedTips | undefined;
  friendAddedTips?: FriendAddedTips | undefined;
  friendDeletedTips?: FriendDeletedTips | undefined;
  blackAddedTips?: BlackAddedTips | undefined;
  blackDeletedTips?: BlackDeletedTips | undefined;
  friendInfoChangedTips?: FriendInfoChangedTips | undefined;
  userInfoUpdatedTips?: UserInfoUpdatedTips | undefined;
  userStatusChangeTips?: UserStatusChangeTips | undefined;
  userCommandAddTips?: UserCommandAddTips | undefined;
  userCommandUpdateTips?: UserCommandUpdateTips | undefined;
  userCommandDeleteTips?: UserCommandDeleteTips | undefined;
  conversationUpdateTips?: ConversationUpdateTips | undefined;
  conversationSetPrivateTips?: ConversationSetPrivateTips | undefined;
  conversationHasReadTips?: ConversationHasReadTips | undefined;
  deleteMessageTips?: DeleteMessageTips | undefined;
  revokeMsgTips?: RevokeMsgTips | undefined;
  clearConversationTips?: ClearConversationTips | undefined;
  deleteMsgsTips?: DeleteMsgsTips | undefined;
  markAsReadTips?: MarkAsReadTips | undefined;
  friendsInfoUpdateTips?: FriendsInfoUpdateTips | undefined;
  subUserOnlineStatusTips?: SubUserOnlineStatusTips | undefined;
  streamMsgTips?: StreamMsgTips | undefined;
}

function createBaseUserInfo(): UserInfo {
  return {
    userID: "",
    nickname: "",
    faceURL: "",
    ex: "",
    createTime: 0,
    appMangerLevel: 0,
    globalRecvMsgOpt: 0,
    attached: "",
  };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    if (message.nickname !== "") {
      writer.uint32(18).string(message.nickname);
    }
    if (message.faceURL !== "") {
      writer.uint32(26).string(message.faceURL);
    }
    if (message.ex !== "") {
      writer.uint32(34).string(message.ex);
    }
    if (message.createTime !== 0) {
      writer.uint32(40).int64(message.createTime);
    }
    if (message.appMangerLevel !== 0) {
      writer.uint32(48).int32(message.appMangerLevel);
    }
    if (message.globalRecvMsgOpt !== 0) {
      writer.uint32(56).int32(message.globalRecvMsgOpt);
    }
    if (message.attached !== "") {
      writer.uint32(66).string(message.attached);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.createTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.appMangerLevel = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.globalRecvMsgOpt = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attached = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : "",
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      appMangerLevel: isSet(object.appMangerLevel) ? globalThis.Number(object.appMangerLevel) : 0,
      globalRecvMsgOpt: isSet(object.globalRecvMsgOpt) ? globalThis.Number(object.globalRecvMsgOpt) : 0,
      attached: isSet(object.attached) ? globalThis.String(object.attached) : "",
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.faceURL !== "") {
      obj.faceURL = message.faceURL;
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.createTime !== 0) {
      obj.createTime = Math.round(message.createTime);
    }
    if (message.appMangerLevel !== 0) {
      obj.appMangerLevel = Math.round(message.appMangerLevel);
    }
    if (message.globalRecvMsgOpt !== 0) {
      obj.globalRecvMsgOpt = Math.round(message.globalRecvMsgOpt);
    }
    if (message.attached !== "") {
      obj.attached = message.attached;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.userID = object.userID ?? "";
    message.nickname = object.nickname ?? "";
    message.faceURL = object.faceURL ?? "";
    message.ex = object.ex ?? "";
    message.createTime = object.createTime ?? 0;
    message.appMangerLevel = object.appMangerLevel ?? 0;
    message.globalRecvMsgOpt = object.globalRecvMsgOpt ?? 0;
    message.attached = object.attached ?? "";
    return message;
  },
};

function createBaseCommandInfo(): CommandInfo {
  return { userID: "", type: 0, createTime: 0, uuid: "", value: "", ex: "" };
}

export const CommandInfo: MessageFns<CommandInfo> = {
  encode(message: CommandInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.createTime !== 0) {
      writer.uint32(24).int64(message.createTime);
    }
    if (message.uuid !== "") {
      writer.uint32(34).string(message.uuid);
    }
    if (message.value !== "") {
      writer.uint32(42).string(message.value);
    }
    if (message.ex !== "") {
      writer.uint32(50).string(message.ex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.createTime = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandInfo {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
    };
  },

  toJSON(message: CommandInfo): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.createTime !== 0) {
      obj.createTime = Math.round(message.createTime);
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandInfo>, I>>(base?: I): CommandInfo {
    return CommandInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandInfo>, I>>(object: I): CommandInfo {
    const message = createBaseCommandInfo();
    message.userID = object.userID ?? "";
    message.type = object.type ?? 0;
    message.createTime = object.createTime ?? 0;
    message.uuid = object.uuid ?? "";
    message.value = object.value ?? "";
    message.ex = object.ex ?? "";
    return message;
  },
};

function createBaseFriendInfo(): FriendInfo {
  return {
    ownerUserID: "",
    friendUserID: "",
    remark: "",
    createTime: 0,
    addSource: 0,
    operatorUserID: "",
    nickname: "",
    faceURL: "",
    ex: "",
    attachedInfo: "",
    isPinned: false,
  };
}

export const FriendInfo: MessageFns<FriendInfo> = {
  encode(message: FriendInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerUserID !== "") {
      writer.uint32(10).string(message.ownerUserID);
    }
    if (message.friendUserID !== "") {
      writer.uint32(18).string(message.friendUserID);
    }
    if (message.remark !== "") {
      writer.uint32(26).string(message.remark);
    }
    if (message.createTime !== 0) {
      writer.uint32(32).int64(message.createTime);
    }
    if (message.addSource !== 0) {
      writer.uint32(40).int32(message.addSource);
    }
    if (message.operatorUserID !== "") {
      writer.uint32(50).string(message.operatorUserID);
    }
    if (message.nickname !== "") {
      writer.uint32(58).string(message.nickname);
    }
    if (message.faceURL !== "") {
      writer.uint32(66).string(message.faceURL);
    }
    if (message.ex !== "") {
      writer.uint32(74).string(message.ex);
    }
    if (message.attachedInfo !== "") {
      writer.uint32(82).string(message.attachedInfo);
    }
    if (message.isPinned !== false) {
      writer.uint32(88).bool(message.isPinned);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.friendUserID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.remark = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.addSource = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.operatorUserID = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.attachedInfo = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isPinned = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendInfo {
    return {
      ownerUserID: isSet(object.ownerUserID) ? globalThis.String(object.ownerUserID) : "",
      friendUserID: isSet(object.friendUserID) ? globalThis.String(object.friendUserID) : "",
      remark: isSet(object.remark) ? globalThis.String(object.remark) : "",
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      addSource: isSet(object.addSource) ? globalThis.Number(object.addSource) : 0,
      operatorUserID: isSet(object.operatorUserID) ? globalThis.String(object.operatorUserID) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : "",
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      attachedInfo: isSet(object.attachedInfo) ? globalThis.String(object.attachedInfo) : "",
      isPinned: isSet(object.isPinned) ? globalThis.Boolean(object.isPinned) : false,
    };
  },

  toJSON(message: FriendInfo): unknown {
    const obj: any = {};
    if (message.ownerUserID !== "") {
      obj.ownerUserID = message.ownerUserID;
    }
    if (message.friendUserID !== "") {
      obj.friendUserID = message.friendUserID;
    }
    if (message.remark !== "") {
      obj.remark = message.remark;
    }
    if (message.createTime !== 0) {
      obj.createTime = Math.round(message.createTime);
    }
    if (message.addSource !== 0) {
      obj.addSource = Math.round(message.addSource);
    }
    if (message.operatorUserID !== "") {
      obj.operatorUserID = message.operatorUserID;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.faceURL !== "") {
      obj.faceURL = message.faceURL;
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.attachedInfo !== "") {
      obj.attachedInfo = message.attachedInfo;
    }
    if (message.isPinned !== false) {
      obj.isPinned = message.isPinned;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendInfo>, I>>(base?: I): FriendInfo {
    return FriendInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendInfo>, I>>(object: I): FriendInfo {
    const message = createBaseFriendInfo();
    message.ownerUserID = object.ownerUserID ?? "";
    message.friendUserID = object.friendUserID ?? "";
    message.remark = object.remark ?? "";
    message.createTime = object.createTime ?? 0;
    message.addSource = object.addSource ?? 0;
    message.operatorUserID = object.operatorUserID ?? "";
    message.nickname = object.nickname ?? "";
    message.faceURL = object.faceURL ?? "";
    message.ex = object.ex ?? "";
    message.attachedInfo = object.attachedInfo ?? "";
    message.isPinned = object.isPinned ?? false;
    return message;
  },
};

function createBaseBlackInfo(): BlackInfo {
  return {
    ownerUserID: "",
    blockUserID: "",
    nickname: "",
    faceURL: "",
    createTime: 0,
    addSource: 0,
    operatorUserID: "",
    ex: "",
    attached: "",
  };
}

export const BlackInfo: MessageFns<BlackInfo> = {
  encode(message: BlackInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerUserID !== "") {
      writer.uint32(10).string(message.ownerUserID);
    }
    if (message.blockUserID !== "") {
      writer.uint32(18).string(message.blockUserID);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.faceURL !== "") {
      writer.uint32(34).string(message.faceURL);
    }
    if (message.createTime !== 0) {
      writer.uint32(40).int64(message.createTime);
    }
    if (message.addSource !== 0) {
      writer.uint32(48).int32(message.addSource);
    }
    if (message.operatorUserID !== "") {
      writer.uint32(58).string(message.operatorUserID);
    }
    if (message.ex !== "") {
      writer.uint32(66).string(message.ex);
    }
    if (message.attached !== "") {
      writer.uint32(74).string(message.attached);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlackInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlackInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockUserID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.createTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.addSource = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.operatorUserID = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.attached = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlackInfo {
    return {
      ownerUserID: isSet(object.ownerUserID) ? globalThis.String(object.ownerUserID) : "",
      blockUserID: isSet(object.blockUserID) ? globalThis.String(object.blockUserID) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : "",
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      addSource: isSet(object.addSource) ? globalThis.Number(object.addSource) : 0,
      operatorUserID: isSet(object.operatorUserID) ? globalThis.String(object.operatorUserID) : "",
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      attached: isSet(object.attached) ? globalThis.String(object.attached) : "",
    };
  },

  toJSON(message: BlackInfo): unknown {
    const obj: any = {};
    if (message.ownerUserID !== "") {
      obj.ownerUserID = message.ownerUserID;
    }
    if (message.blockUserID !== "") {
      obj.blockUserID = message.blockUserID;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.faceURL !== "") {
      obj.faceURL = message.faceURL;
    }
    if (message.createTime !== 0) {
      obj.createTime = Math.round(message.createTime);
    }
    if (message.addSource !== 0) {
      obj.addSource = Math.round(message.addSource);
    }
    if (message.operatorUserID !== "") {
      obj.operatorUserID = message.operatorUserID;
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.attached !== "") {
      obj.attached = message.attached;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlackInfo>, I>>(base?: I): BlackInfo {
    return BlackInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlackInfo>, I>>(object: I): BlackInfo {
    const message = createBaseBlackInfo();
    message.ownerUserID = object.ownerUserID ?? "";
    message.blockUserID = object.blockUserID ?? "";
    message.nickname = object.nickname ?? "";
    message.faceURL = object.faceURL ?? "";
    message.createTime = object.createTime ?? 0;
    message.addSource = object.addSource ?? 0;
    message.operatorUserID = object.operatorUserID ?? "";
    message.ex = object.ex ?? "";
    message.attached = object.attached ?? "";
    return message;
  },
};

function createBaseFriendRequestInfo(): FriendRequestInfo {
  return {
    fromUserID: "",
    fromNickname: "",
    fromFaceURL: "",
    toUserID: "",
    toNickname: "",
    toFaceURL: "",
    handleResult: 0,
    reqMsg: "",
    createTime: 0,
    handlerUserID: "",
    handleMsg: "",
    handleTime: 0,
    ex: "",
    attached: "",
  };
}

export const FriendRequestInfo: MessageFns<FriendRequestInfo> = {
  encode(message: FriendRequestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserID !== "") {
      writer.uint32(10).string(message.fromUserID);
    }
    if (message.fromNickname !== "") {
      writer.uint32(18).string(message.fromNickname);
    }
    if (message.fromFaceURL !== "") {
      writer.uint32(26).string(message.fromFaceURL);
    }
    if (message.toUserID !== "") {
      writer.uint32(34).string(message.toUserID);
    }
    if (message.toNickname !== "") {
      writer.uint32(42).string(message.toNickname);
    }
    if (message.toFaceURL !== "") {
      writer.uint32(50).string(message.toFaceURL);
    }
    if (message.handleResult !== 0) {
      writer.uint32(56).int32(message.handleResult);
    }
    if (message.reqMsg !== "") {
      writer.uint32(66).string(message.reqMsg);
    }
    if (message.createTime !== 0) {
      writer.uint32(72).int64(message.createTime);
    }
    if (message.handlerUserID !== "") {
      writer.uint32(82).string(message.handlerUserID);
    }
    if (message.handleMsg !== "") {
      writer.uint32(90).string(message.handleMsg);
    }
    if (message.handleTime !== 0) {
      writer.uint32(96).int64(message.handleTime);
    }
    if (message.ex !== "") {
      writer.uint32(106).string(message.ex);
    }
    if (message.attached !== "") {
      writer.uint32(114).string(message.attached);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendRequestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromNickname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromFaceURL = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toUserID = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toNickname = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toFaceURL = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.handleResult = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reqMsg = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.createTime = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.handlerUserID = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.handleMsg = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.handleTime = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.attached = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendRequestInfo {
    return {
      fromUserID: isSet(object.fromUserID) ? globalThis.String(object.fromUserID) : "",
      fromNickname: isSet(object.fromNickname) ? globalThis.String(object.fromNickname) : "",
      fromFaceURL: isSet(object.fromFaceURL) ? globalThis.String(object.fromFaceURL) : "",
      toUserID: isSet(object.toUserID) ? globalThis.String(object.toUserID) : "",
      toNickname: isSet(object.toNickname) ? globalThis.String(object.toNickname) : "",
      toFaceURL: isSet(object.toFaceURL) ? globalThis.String(object.toFaceURL) : "",
      handleResult: isSet(object.handleResult) ? globalThis.Number(object.handleResult) : 0,
      reqMsg: isSet(object.reqMsg) ? globalThis.String(object.reqMsg) : "",
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      handlerUserID: isSet(object.handlerUserID) ? globalThis.String(object.handlerUserID) : "",
      handleMsg: isSet(object.handleMsg) ? globalThis.String(object.handleMsg) : "",
      handleTime: isSet(object.handleTime) ? globalThis.Number(object.handleTime) : 0,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      attached: isSet(object.attached) ? globalThis.String(object.attached) : "",
    };
  },

  toJSON(message: FriendRequestInfo): unknown {
    const obj: any = {};
    if (message.fromUserID !== "") {
      obj.fromUserID = message.fromUserID;
    }
    if (message.fromNickname !== "") {
      obj.fromNickname = message.fromNickname;
    }
    if (message.fromFaceURL !== "") {
      obj.fromFaceURL = message.fromFaceURL;
    }
    if (message.toUserID !== "") {
      obj.toUserID = message.toUserID;
    }
    if (message.toNickname !== "") {
      obj.toNickname = message.toNickname;
    }
    if (message.toFaceURL !== "") {
      obj.toFaceURL = message.toFaceURL;
    }
    if (message.handleResult !== 0) {
      obj.handleResult = Math.round(message.handleResult);
    }
    if (message.reqMsg !== "") {
      obj.reqMsg = message.reqMsg;
    }
    if (message.createTime !== 0) {
      obj.createTime = Math.round(message.createTime);
    }
    if (message.handlerUserID !== "") {
      obj.handlerUserID = message.handlerUserID;
    }
    if (message.handleMsg !== "") {
      obj.handleMsg = message.handleMsg;
    }
    if (message.handleTime !== 0) {
      obj.handleTime = Math.round(message.handleTime);
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.attached !== "") {
      obj.attached = message.attached;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendRequestInfo>, I>>(base?: I): FriendRequestInfo {
    return FriendRequestInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendRequestInfo>, I>>(object: I): FriendRequestInfo {
    const message = createBaseFriendRequestInfo();
    message.fromUserID = object.fromUserID ?? "";
    message.fromNickname = object.fromNickname ?? "";
    message.fromFaceURL = object.fromFaceURL ?? "";
    message.toUserID = object.toUserID ?? "";
    message.toNickname = object.toNickname ?? "";
    message.toFaceURL = object.toFaceURL ?? "";
    message.handleResult = object.handleResult ?? 0;
    message.reqMsg = object.reqMsg ?? "";
    message.createTime = object.createTime ?? 0;
    message.handlerUserID = object.handlerUserID ?? "";
    message.handleMsg = object.handleMsg ?? "";
    message.handleTime = object.handleTime ?? 0;
    message.ex = object.ex ?? "";
    message.attached = object.attached ?? "";
    return message;
  },
};

function createBaseGroupInfo(): GroupInfo {
  return {
    groupID: "",
    groupName: "",
    notification: "",
    introduction: "",
    faceURL: "",
    ownerUserID: "",
    createTime: 0,
    memberCount: 0,
    ex: "",
    status: 0,
    creatorUserID: "",
    needVerification: 0,
    lookMemberInfo: 0,
    applyMemberFriend: 0,
    notificationUpdateTime: 0,
    notificationUserID: "",
    attachedInfo: "",
  };
}

export const GroupInfo: MessageFns<GroupInfo> = {
  encode(message: GroupInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.groupName !== "") {
      writer.uint32(18).string(message.groupName);
    }
    if (message.notification !== "") {
      writer.uint32(26).string(message.notification);
    }
    if (message.introduction !== "") {
      writer.uint32(34).string(message.introduction);
    }
    if (message.faceURL !== "") {
      writer.uint32(42).string(message.faceURL);
    }
    if (message.ownerUserID !== "") {
      writer.uint32(50).string(message.ownerUserID);
    }
    if (message.createTime !== 0) {
      writer.uint32(56).int64(message.createTime);
    }
    if (message.memberCount !== 0) {
      writer.uint32(64).int64(message.memberCount);
    }
    if (message.ex !== "") {
      writer.uint32(74).string(message.ex);
    }
    if (message.status !== 0) {
      writer.uint32(80).int32(message.status);
    }
    if (message.creatorUserID !== "") {
      writer.uint32(90).string(message.creatorUserID);
    }
    if (message.needVerification !== 0) {
      writer.uint32(96).int32(message.needVerification);
    }
    if (message.lookMemberInfo !== 0) {
      writer.uint32(104).int32(message.lookMemberInfo);
    }
    if (message.applyMemberFriend !== 0) {
      writer.uint32(112).int32(message.applyMemberFriend);
    }
    if (message.notificationUpdateTime !== 0) {
      writer.uint32(120).int64(message.notificationUpdateTime);
    }
    if (message.notificationUserID !== "") {
      writer.uint32(130).string(message.notificationUserID);
    }
    if (message.attachedInfo !== "") {
      writer.uint32(138).string(message.attachedInfo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.notification = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.introduction = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ownerUserID = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.createTime = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.memberCount = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.creatorUserID = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.needVerification = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.lookMemberInfo = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.applyMemberFriend = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.notificationUpdateTime = longToNumber(reader.int64());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.notificationUserID = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.attachedInfo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupInfo {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : "",
      notification: isSet(object.notification) ? globalThis.String(object.notification) : "",
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "",
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : "",
      ownerUserID: isSet(object.ownerUserID) ? globalThis.String(object.ownerUserID) : "",
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      memberCount: isSet(object.memberCount) ? globalThis.Number(object.memberCount) : 0,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      status: isSet(object.status) ? groupStatusFromJSON(object.status) : 0,
      creatorUserID: isSet(object.creatorUserID) ? globalThis.String(object.creatorUserID) : "",
      needVerification: isSet(object.needVerification) ? globalThis.Number(object.needVerification) : 0,
      lookMemberInfo: isSet(object.lookMemberInfo) ? globalThis.Number(object.lookMemberInfo) : 0,
      applyMemberFriend: isSet(object.applyMemberFriend) ? globalThis.Number(object.applyMemberFriend) : 0,
      notificationUpdateTime: isSet(object.notificationUpdateTime)
        ? globalThis.Number(object.notificationUpdateTime)
        : 0,
      notificationUserID: isSet(object.notificationUserID) ? globalThis.String(object.notificationUserID) : "",
      attachedInfo: isSet(object.attachedInfo) ? globalThis.String(object.attachedInfo) : "",
    };
  },

  toJSON(message: GroupInfo): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.groupName !== "") {
      obj.groupName = message.groupName;
    }
    if (message.notification !== "") {
      obj.notification = message.notification;
    }
    if (message.introduction !== "") {
      obj.introduction = message.introduction;
    }
    if (message.faceURL !== "") {
      obj.faceURL = message.faceURL;
    }
    if (message.ownerUserID !== "") {
      obj.ownerUserID = message.ownerUserID;
    }
    if (message.createTime !== 0) {
      obj.createTime = Math.round(message.createTime);
    }
    if (message.memberCount !== 0) {
      obj.memberCount = Math.round(message.memberCount);
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.status !== 0) {
      obj.status = groupStatusToJSON(message.status);
    }
    if (message.creatorUserID !== "") {
      obj.creatorUserID = message.creatorUserID;
    }
    if (message.needVerification !== 0) {
      obj.needVerification = Math.round(message.needVerification);
    }
    if (message.lookMemberInfo !== 0) {
      obj.lookMemberInfo = Math.round(message.lookMemberInfo);
    }
    if (message.applyMemberFriend !== 0) {
      obj.applyMemberFriend = Math.round(message.applyMemberFriend);
    }
    if (message.notificationUpdateTime !== 0) {
      obj.notificationUpdateTime = Math.round(message.notificationUpdateTime);
    }
    if (message.notificationUserID !== "") {
      obj.notificationUserID = message.notificationUserID;
    }
    if (message.attachedInfo !== "") {
      obj.attachedInfo = message.attachedInfo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupInfo>, I>>(base?: I): GroupInfo {
    return GroupInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupInfo>, I>>(object: I): GroupInfo {
    const message = createBaseGroupInfo();
    message.groupID = object.groupID ?? "";
    message.groupName = object.groupName ?? "";
    message.notification = object.notification ?? "";
    message.introduction = object.introduction ?? "";
    message.faceURL = object.faceURL ?? "";
    message.ownerUserID = object.ownerUserID ?? "";
    message.createTime = object.createTime ?? 0;
    message.memberCount = object.memberCount ?? 0;
    message.ex = object.ex ?? "";
    message.status = object.status ?? 0;
    message.creatorUserID = object.creatorUserID ?? "";
    message.needVerification = object.needVerification ?? 0;
    message.lookMemberInfo = object.lookMemberInfo ?? 0;
    message.applyMemberFriend = object.applyMemberFriend ?? 0;
    message.notificationUpdateTime = object.notificationUpdateTime ?? 0;
    message.notificationUserID = object.notificationUserID ?? "";
    message.attachedInfo = object.attachedInfo ?? "";
    return message;
  },
};

function createBaseGroupMemberInfo(): GroupMemberInfo {
  return {
    groupID: "",
    userID: "",
    nickname: "",
    faceURL: "",
    roleLevel: 0,
    joinTime: 0,
    joinSource: 0,
    inviterUserID: "",
    muteEndTime: 0,
    operatorUserID: "",
    ex: "",
    attachedInfo: "",
  };
}

export const GroupMemberInfo: MessageFns<GroupMemberInfo> = {
  encode(message: GroupMemberInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.userID !== "") {
      writer.uint32(18).string(message.userID);
    }
    if (message.nickname !== "") {
      writer.uint32(26).string(message.nickname);
    }
    if (message.faceURL !== "") {
      writer.uint32(34).string(message.faceURL);
    }
    if (message.roleLevel !== 0) {
      writer.uint32(40).int32(message.roleLevel);
    }
    if (message.joinTime !== 0) {
      writer.uint32(48).int64(message.joinTime);
    }
    if (message.joinSource !== 0) {
      writer.uint32(56).int32(message.joinSource);
    }
    if (message.inviterUserID !== "") {
      writer.uint32(66).string(message.inviterUserID);
    }
    if (message.muteEndTime !== 0) {
      writer.uint32(72).int64(message.muteEndTime);
    }
    if (message.operatorUserID !== "") {
      writer.uint32(82).string(message.operatorUserID);
    }
    if (message.ex !== "") {
      writer.uint32(90).string(message.ex);
    }
    if (message.attachedInfo !== "") {
      writer.uint32(98).string(message.attachedInfo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMemberInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMemberInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.roleLevel = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.joinTime = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.joinSource = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.inviterUserID = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.muteEndTime = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.operatorUserID = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.attachedInfo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMemberInfo {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : "",
      roleLevel: isSet(object.roleLevel) ? globalThis.Number(object.roleLevel) : 0,
      joinTime: isSet(object.joinTime) ? globalThis.Number(object.joinTime) : 0,
      joinSource: isSet(object.joinSource) ? globalThis.Number(object.joinSource) : 0,
      inviterUserID: isSet(object.inviterUserID) ? globalThis.String(object.inviterUserID) : "",
      muteEndTime: isSet(object.muteEndTime) ? globalThis.Number(object.muteEndTime) : 0,
      operatorUserID: isSet(object.operatorUserID) ? globalThis.String(object.operatorUserID) : "",
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      attachedInfo: isSet(object.attachedInfo) ? globalThis.String(object.attachedInfo) : "",
    };
  },

  toJSON(message: GroupMemberInfo): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.faceURL !== "") {
      obj.faceURL = message.faceURL;
    }
    if (message.roleLevel !== 0) {
      obj.roleLevel = Math.round(message.roleLevel);
    }
    if (message.joinTime !== 0) {
      obj.joinTime = Math.round(message.joinTime);
    }
    if (message.joinSource !== 0) {
      obj.joinSource = Math.round(message.joinSource);
    }
    if (message.inviterUserID !== "") {
      obj.inviterUserID = message.inviterUserID;
    }
    if (message.muteEndTime !== 0) {
      obj.muteEndTime = Math.round(message.muteEndTime);
    }
    if (message.operatorUserID !== "") {
      obj.operatorUserID = message.operatorUserID;
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.attachedInfo !== "") {
      obj.attachedInfo = message.attachedInfo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMemberInfo>, I>>(base?: I): GroupMemberInfo {
    return GroupMemberInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMemberInfo>, I>>(object: I): GroupMemberInfo {
    const message = createBaseGroupMemberInfo();
    message.groupID = object.groupID ?? "";
    message.userID = object.userID ?? "";
    message.nickname = object.nickname ?? "";
    message.faceURL = object.faceURL ?? "";
    message.roleLevel = object.roleLevel ?? 0;
    message.joinTime = object.joinTime ?? 0;
    message.joinSource = object.joinSource ?? 0;
    message.inviterUserID = object.inviterUserID ?? "";
    message.muteEndTime = object.muteEndTime ?? 0;
    message.operatorUserID = object.operatorUserID ?? "";
    message.ex = object.ex ?? "";
    message.attachedInfo = object.attachedInfo ?? "";
    return message;
  },
};

function createBaseGroupRequestInfo(): GroupRequestInfo {
  return {
    groupID: "",
    groupName: "",
    notification: "",
    introduction: "",
    groupFaceURL: "",
    createTime: 0,
    status: 0,
    creatorUserID: "",
    groupType: 0,
    ownerUserID: "",
    memberCount: 0,
    userID: "",
    nickname: "",
    userFaceURL: "",
    handleResult: 0,
    reqMsg: "",
    handledMsg: "",
    reqTime: 0,
    handleUserID: "",
    handledTime: 0,
    ex: "",
    attachedInfo: "",
    joinSource: 0,
    inviterUserID: "",
  };
}

export const GroupRequestInfo: MessageFns<GroupRequestInfo> = {
  encode(message: GroupRequestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.groupName !== "") {
      writer.uint32(18).string(message.groupName);
    }
    if (message.notification !== "") {
      writer.uint32(26).string(message.notification);
    }
    if (message.introduction !== "") {
      writer.uint32(34).string(message.introduction);
    }
    if (message.groupFaceURL !== "") {
      writer.uint32(42).string(message.groupFaceURL);
    }
    if (message.createTime !== 0) {
      writer.uint32(48).int64(message.createTime);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.creatorUserID !== "") {
      writer.uint32(66).string(message.creatorUserID);
    }
    if (message.groupType !== 0) {
      writer.uint32(72).int32(message.groupType);
    }
    if (message.ownerUserID !== "") {
      writer.uint32(82).string(message.ownerUserID);
    }
    if (message.memberCount !== 0) {
      writer.uint32(88).int32(message.memberCount);
    }
    if (message.userID !== "") {
      writer.uint32(98).string(message.userID);
    }
    if (message.nickname !== "") {
      writer.uint32(106).string(message.nickname);
    }
    if (message.userFaceURL !== "") {
      writer.uint32(114).string(message.userFaceURL);
    }
    if (message.handleResult !== 0) {
      writer.uint32(120).int32(message.handleResult);
    }
    if (message.reqMsg !== "") {
      writer.uint32(130).string(message.reqMsg);
    }
    if (message.handledMsg !== "") {
      writer.uint32(138).string(message.handledMsg);
    }
    if (message.reqTime !== 0) {
      writer.uint32(144).int64(message.reqTime);
    }
    if (message.handleUserID !== "") {
      writer.uint32(154).string(message.handleUserID);
    }
    if (message.handledTime !== 0) {
      writer.uint32(160).int64(message.handledTime);
    }
    if (message.ex !== "") {
      writer.uint32(170).string(message.ex);
    }
    if (message.attachedInfo !== "") {
      writer.uint32(178).string(message.attachedInfo);
    }
    if (message.joinSource !== 0) {
      writer.uint32(184).int32(message.joinSource);
    }
    if (message.inviterUserID !== "") {
      writer.uint32(194).string(message.inviterUserID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupRequestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.notification = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.introduction = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.groupFaceURL = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.createTime = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.creatorUserID = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.groupType = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ownerUserID = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.memberCount = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.userFaceURL = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.handleResult = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.reqMsg = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.handledMsg = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.reqTime = longToNumber(reader.int64());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.handleUserID = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.handledTime = longToNumber(reader.int64());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.attachedInfo = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.joinSource = reader.int32();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.inviterUserID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupRequestInfo {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : "",
      notification: isSet(object.notification) ? globalThis.String(object.notification) : "",
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "",
      groupFaceURL: isSet(object.groupFaceURL) ? globalThis.String(object.groupFaceURL) : "",
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      creatorUserID: isSet(object.creatorUserID) ? globalThis.String(object.creatorUserID) : "",
      groupType: isSet(object.groupType) ? globalThis.Number(object.groupType) : 0,
      ownerUserID: isSet(object.ownerUserID) ? globalThis.String(object.ownerUserID) : "",
      memberCount: isSet(object.memberCount) ? globalThis.Number(object.memberCount) : 0,
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      userFaceURL: isSet(object.userFaceURL) ? globalThis.String(object.userFaceURL) : "",
      handleResult: isSet(object.handleResult) ? globalThis.Number(object.handleResult) : 0,
      reqMsg: isSet(object.reqMsg) ? globalThis.String(object.reqMsg) : "",
      handledMsg: isSet(object.handledMsg) ? globalThis.String(object.handledMsg) : "",
      reqTime: isSet(object.reqTime) ? globalThis.Number(object.reqTime) : 0,
      handleUserID: isSet(object.handleUserID) ? globalThis.String(object.handleUserID) : "",
      handledTime: isSet(object.handledTime) ? globalThis.Number(object.handledTime) : 0,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      attachedInfo: isSet(object.attachedInfo) ? globalThis.String(object.attachedInfo) : "",
      joinSource: isSet(object.joinSource) ? globalThis.Number(object.joinSource) : 0,
      inviterUserID: isSet(object.inviterUserID) ? globalThis.String(object.inviterUserID) : "",
    };
  },

  toJSON(message: GroupRequestInfo): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.groupName !== "") {
      obj.groupName = message.groupName;
    }
    if (message.notification !== "") {
      obj.notification = message.notification;
    }
    if (message.introduction !== "") {
      obj.introduction = message.introduction;
    }
    if (message.groupFaceURL !== "") {
      obj.groupFaceURL = message.groupFaceURL;
    }
    if (message.createTime !== 0) {
      obj.createTime = Math.round(message.createTime);
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.creatorUserID !== "") {
      obj.creatorUserID = message.creatorUserID;
    }
    if (message.groupType !== 0) {
      obj.groupType = Math.round(message.groupType);
    }
    if (message.ownerUserID !== "") {
      obj.ownerUserID = message.ownerUserID;
    }
    if (message.memberCount !== 0) {
      obj.memberCount = Math.round(message.memberCount);
    }
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.userFaceURL !== "") {
      obj.userFaceURL = message.userFaceURL;
    }
    if (message.handleResult !== 0) {
      obj.handleResult = Math.round(message.handleResult);
    }
    if (message.reqMsg !== "") {
      obj.reqMsg = message.reqMsg;
    }
    if (message.handledMsg !== "") {
      obj.handledMsg = message.handledMsg;
    }
    if (message.reqTime !== 0) {
      obj.reqTime = Math.round(message.reqTime);
    }
    if (message.handleUserID !== "") {
      obj.handleUserID = message.handleUserID;
    }
    if (message.handledTime !== 0) {
      obj.handledTime = Math.round(message.handledTime);
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.attachedInfo !== "") {
      obj.attachedInfo = message.attachedInfo;
    }
    if (message.joinSource !== 0) {
      obj.joinSource = Math.round(message.joinSource);
    }
    if (message.inviterUserID !== "") {
      obj.inviterUserID = message.inviterUserID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupRequestInfo>, I>>(base?: I): GroupRequestInfo {
    return GroupRequestInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupRequestInfo>, I>>(object: I): GroupRequestInfo {
    const message = createBaseGroupRequestInfo();
    message.groupID = object.groupID ?? "";
    message.groupName = object.groupName ?? "";
    message.notification = object.notification ?? "";
    message.introduction = object.introduction ?? "";
    message.groupFaceURL = object.groupFaceURL ?? "";
    message.createTime = object.createTime ?? 0;
    message.status = object.status ?? 0;
    message.creatorUserID = object.creatorUserID ?? "";
    message.groupType = object.groupType ?? 0;
    message.ownerUserID = object.ownerUserID ?? "";
    message.memberCount = object.memberCount ?? 0;
    message.userID = object.userID ?? "";
    message.nickname = object.nickname ?? "";
    message.userFaceURL = object.userFaceURL ?? "";
    message.handleResult = object.handleResult ?? 0;
    message.reqMsg = object.reqMsg ?? "";
    message.handledMsg = object.handledMsg ?? "";
    message.reqTime = object.reqTime ?? 0;
    message.handleUserID = object.handleUserID ?? "";
    message.handledTime = object.handledTime ?? 0;
    message.ex = object.ex ?? "";
    message.attachedInfo = object.attachedInfo ?? "";
    message.joinSource = object.joinSource ?? 0;
    message.inviterUserID = object.inviterUserID ?? "";
    return message;
  },
};

function createBaseConversation(): Conversation {
  return {
    conversationID: "",
    conversationType: 0,
    userID: "",
    groupID: "",
    showName: "",
    faceURL: "",
    recvMsgOpt: 0,
    unreadCount: 0,
    groupAtType: 0,
    latestMsg: undefined,
    latestMsgSendTime: 0,
    draftText: "",
    draftTextTime: 0,
    isPinned: false,
    isPrivateChat: false,
    burnDuration: 0,
    ex: "",
    msgDestructTime: 0,
    isMsgDestruct: false,
  };
}

export const Conversation: MessageFns<Conversation> = {
  encode(message: Conversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.conversationType !== 0) {
      writer.uint32(16).int32(message.conversationType);
    }
    if (message.userID !== "") {
      writer.uint32(26).string(message.userID);
    }
    if (message.groupID !== "") {
      writer.uint32(34).string(message.groupID);
    }
    if (message.showName !== "") {
      writer.uint32(42).string(message.showName);
    }
    if (message.faceURL !== "") {
      writer.uint32(50).string(message.faceURL);
    }
    if (message.recvMsgOpt !== 0) {
      writer.uint32(56).int32(message.recvMsgOpt);
    }
    if (message.unreadCount !== 0) {
      writer.uint32(64).int32(message.unreadCount);
    }
    if (message.groupAtType !== 0) {
      writer.uint32(72).int32(message.groupAtType);
    }
    if (message.latestMsg !== undefined) {
      IMMessage.encode(message.latestMsg, writer.uint32(82).fork()).join();
    }
    if (message.latestMsgSendTime !== 0) {
      writer.uint32(88).int64(message.latestMsgSendTime);
    }
    if (message.draftText !== "") {
      writer.uint32(98).string(message.draftText);
    }
    if (message.draftTextTime !== 0) {
      writer.uint32(104).int64(message.draftTextTime);
    }
    if (message.isPinned !== false) {
      writer.uint32(112).bool(message.isPinned);
    }
    if (message.isPrivateChat !== false) {
      writer.uint32(120).bool(message.isPrivateChat);
    }
    if (message.burnDuration !== 0) {
      writer.uint32(128).int32(message.burnDuration);
    }
    if (message.ex !== "") {
      writer.uint32(138).string(message.ex);
    }
    if (message.msgDestructTime !== 0) {
      writer.uint32(144).int64(message.msgDestructTime);
    }
    if (message.isMsgDestruct !== false) {
      writer.uint32(152).bool(message.isMsgDestruct);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.conversationType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.showName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.recvMsgOpt = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.unreadCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.groupAtType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.latestMsg = IMMessage.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.latestMsgSendTime = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.draftText = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.draftTextTime = longToNumber(reader.int64());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isPinned = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isPrivateChat = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.burnDuration = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.msgDestructTime = longToNumber(reader.int64());
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isMsgDestruct = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      conversationType: isSet(object.conversationType) ? sessionTypeFromJSON(object.conversationType) : 0,
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      showName: isSet(object.showName) ? globalThis.String(object.showName) : "",
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : "",
      recvMsgOpt: isSet(object.recvMsgOpt) ? convRecvMsgOptFromJSON(object.recvMsgOpt) : 0,
      unreadCount: isSet(object.unreadCount) ? globalThis.Number(object.unreadCount) : 0,
      groupAtType: isSet(object.groupAtType) ? convGroupAtTypeFromJSON(object.groupAtType) : 0,
      latestMsg: isSet(object.latestMsg) ? IMMessage.fromJSON(object.latestMsg) : undefined,
      latestMsgSendTime: isSet(object.latestMsgSendTime) ? globalThis.Number(object.latestMsgSendTime) : 0,
      draftText: isSet(object.draftText) ? globalThis.String(object.draftText) : "",
      draftTextTime: isSet(object.draftTextTime) ? globalThis.Number(object.draftTextTime) : 0,
      isPinned: isSet(object.isPinned) ? globalThis.Boolean(object.isPinned) : false,
      isPrivateChat: isSet(object.isPrivateChat) ? globalThis.Boolean(object.isPrivateChat) : false,
      burnDuration: isSet(object.burnDuration) ? globalThis.Number(object.burnDuration) : 0,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      msgDestructTime: isSet(object.msgDestructTime) ? globalThis.Number(object.msgDestructTime) : 0,
      isMsgDestruct: isSet(object.isMsgDestruct) ? globalThis.Boolean(object.isMsgDestruct) : false,
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.conversationType !== 0) {
      obj.conversationType = sessionTypeToJSON(message.conversationType);
    }
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.showName !== "") {
      obj.showName = message.showName;
    }
    if (message.faceURL !== "") {
      obj.faceURL = message.faceURL;
    }
    if (message.recvMsgOpt !== 0) {
      obj.recvMsgOpt = convRecvMsgOptToJSON(message.recvMsgOpt);
    }
    if (message.unreadCount !== 0) {
      obj.unreadCount = Math.round(message.unreadCount);
    }
    if (message.groupAtType !== 0) {
      obj.groupAtType = convGroupAtTypeToJSON(message.groupAtType);
    }
    if (message.latestMsg !== undefined) {
      obj.latestMsg = IMMessage.toJSON(message.latestMsg);
    }
    if (message.latestMsgSendTime !== 0) {
      obj.latestMsgSendTime = Math.round(message.latestMsgSendTime);
    }
    if (message.draftText !== "") {
      obj.draftText = message.draftText;
    }
    if (message.draftTextTime !== 0) {
      obj.draftTextTime = Math.round(message.draftTextTime);
    }
    if (message.isPinned !== false) {
      obj.isPinned = message.isPinned;
    }
    if (message.isPrivateChat !== false) {
      obj.isPrivateChat = message.isPrivateChat;
    }
    if (message.burnDuration !== 0) {
      obj.burnDuration = Math.round(message.burnDuration);
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.msgDestructTime !== 0) {
      obj.msgDestructTime = Math.round(message.msgDestructTime);
    }
    if (message.isMsgDestruct !== false) {
      obj.isMsgDestruct = message.isMsgDestruct;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Conversation>, I>>(base?: I): Conversation {
    return Conversation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Conversation>, I>>(object: I): Conversation {
    const message = createBaseConversation();
    message.conversationID = object.conversationID ?? "";
    message.conversationType = object.conversationType ?? 0;
    message.userID = object.userID ?? "";
    message.groupID = object.groupID ?? "";
    message.showName = object.showName ?? "";
    message.faceURL = object.faceURL ?? "";
    message.recvMsgOpt = object.recvMsgOpt ?? 0;
    message.unreadCount = object.unreadCount ?? 0;
    message.groupAtType = object.groupAtType ?? 0;
    message.latestMsg = (object.latestMsg !== undefined && object.latestMsg !== null)
      ? IMMessage.fromPartial(object.latestMsg)
      : undefined;
    message.latestMsgSendTime = object.latestMsgSendTime ?? 0;
    message.draftText = object.draftText ?? "";
    message.draftTextTime = object.draftTextTime ?? 0;
    message.isPinned = object.isPinned ?? false;
    message.isPrivateChat = object.isPrivateChat ?? false;
    message.burnDuration = object.burnDuration ?? 0;
    message.ex = object.ex ?? "";
    message.msgDestructTime = object.msgDestructTime ?? 0;
    message.isMsgDestruct = object.isMsgDestruct ?? false;
    return message;
  },
};

function createBaseAtInfo(): AtInfo {
  return { atUserID: "", groupNickname: "" };
}

export const AtInfo: MessageFns<AtInfo> = {
  encode(message: AtInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.atUserID !== "") {
      writer.uint32(10).string(message.atUserID);
    }
    if (message.groupNickname !== "") {
      writer.uint32(18).string(message.groupNickname);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AtInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAtInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.atUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupNickname = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AtInfo {
    return {
      atUserID: isSet(object.atUserID) ? globalThis.String(object.atUserID) : "",
      groupNickname: isSet(object.groupNickname) ? globalThis.String(object.groupNickname) : "",
    };
  },

  toJSON(message: AtInfo): unknown {
    const obj: any = {};
    if (message.atUserID !== "") {
      obj.atUserID = message.atUserID;
    }
    if (message.groupNickname !== "") {
      obj.groupNickname = message.groupNickname;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AtInfo>, I>>(base?: I): AtInfo {
    return AtInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AtInfo>, I>>(object: I): AtInfo {
    const message = createBaseAtInfo();
    message.atUserID = object.atUserID ?? "";
    message.groupNickname = object.groupNickname ?? "";
    return message;
  },
};

function createBaseImageInfo(): ImageInfo {
  return { width: 0, height: 0, type: "", size: 0 };
}

export const ImageInfo: MessageFns<ImageInfo> = {
  encode(message: ImageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.size !== 0) {
      writer.uint32(32).int64(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageInfo {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
    };
  },

  toJSON(message: ImageInfo): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageInfo>, I>>(base?: I): ImageInfo {
    return ImageInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageInfo>, I>>(object: I): ImageInfo {
    const message = createBaseImageInfo();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.type = object.type ?? "";
    message.size = object.size ?? 0;
    return message;
  },
};

function createBasePictureBaseInfo(): PictureBaseInfo {
  return { uuid: "", type: "", size: 0, width: 0, height: 0, url: "" };
}

export const PictureBaseInfo: MessageFns<PictureBaseInfo> = {
  encode(message: PictureBaseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.size !== 0) {
      writer.uint32(24).int64(message.size);
    }
    if (message.width !== 0) {
      writer.uint32(32).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(40).int32(message.height);
    }
    if (message.url !== "") {
      writer.uint32(50).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PictureBaseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePictureBaseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.width = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.height = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PictureBaseInfo {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: PictureBaseInfo): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PictureBaseInfo>, I>>(base?: I): PictureBaseInfo {
    return PictureBaseInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PictureBaseInfo>, I>>(object: I): PictureBaseInfo {
    const message = createBasePictureBaseInfo();
    message.uuid = object.uuid ?? "";
    message.type = object.type ?? "";
    message.size = object.size ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseSoundBaseInfo(): SoundBaseInfo {
  return { uuid: "", soundPath: "", sourceURL: "", dataSize: 0, duration: 0, soundType: "" };
}

export const SoundBaseInfo: MessageFns<SoundBaseInfo> = {
  encode(message: SoundBaseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.soundPath !== "") {
      writer.uint32(18).string(message.soundPath);
    }
    if (message.sourceURL !== "") {
      writer.uint32(26).string(message.sourceURL);
    }
    if (message.dataSize !== 0) {
      writer.uint32(32).int64(message.dataSize);
    }
    if (message.duration !== 0) {
      writer.uint32(40).int64(message.duration);
    }
    if (message.soundType !== "") {
      writer.uint32(50).string(message.soundType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoundBaseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoundBaseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.soundPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceURL = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dataSize = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.soundType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoundBaseInfo {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      soundPath: isSet(object.soundPath) ? globalThis.String(object.soundPath) : "",
      sourceURL: isSet(object.sourceURL) ? globalThis.String(object.sourceURL) : "",
      dataSize: isSet(object.dataSize) ? globalThis.Number(object.dataSize) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      soundType: isSet(object.soundType) ? globalThis.String(object.soundType) : "",
    };
  },

  toJSON(message: SoundBaseInfo): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.soundPath !== "") {
      obj.soundPath = message.soundPath;
    }
    if (message.sourceURL !== "") {
      obj.sourceURL = message.sourceURL;
    }
    if (message.dataSize !== 0) {
      obj.dataSize = Math.round(message.dataSize);
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.soundType !== "") {
      obj.soundType = message.soundType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SoundBaseInfo>, I>>(base?: I): SoundBaseInfo {
    return SoundBaseInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SoundBaseInfo>, I>>(object: I): SoundBaseInfo {
    const message = createBaseSoundBaseInfo();
    message.uuid = object.uuid ?? "";
    message.soundPath = object.soundPath ?? "";
    message.sourceURL = object.sourceURL ?? "";
    message.dataSize = object.dataSize ?? 0;
    message.duration = object.duration ?? 0;
    message.soundType = object.soundType ?? "";
    return message;
  },
};

function createBaseVideoBaseInfo(): VideoBaseInfo {
  return {
    videoPath: "",
    videoUUID: "",
    videoURL: "",
    videoType: "",
    videoSize: 0,
    duration: 0,
    snapshotPath: "",
    snapshotUUID: "",
    snapshotSize: 0,
    snapshotURL: "",
    snapshotWidth: 0,
    snapshotHeight: 0,
    snapshotType: "",
  };
}

export const VideoBaseInfo: MessageFns<VideoBaseInfo> = {
  encode(message: VideoBaseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoPath !== "") {
      writer.uint32(10).string(message.videoPath);
    }
    if (message.videoUUID !== "") {
      writer.uint32(18).string(message.videoUUID);
    }
    if (message.videoURL !== "") {
      writer.uint32(26).string(message.videoURL);
    }
    if (message.videoType !== "") {
      writer.uint32(34).string(message.videoType);
    }
    if (message.videoSize !== 0) {
      writer.uint32(40).int64(message.videoSize);
    }
    if (message.duration !== 0) {
      writer.uint32(48).int64(message.duration);
    }
    if (message.snapshotPath !== "") {
      writer.uint32(58).string(message.snapshotPath);
    }
    if (message.snapshotUUID !== "") {
      writer.uint32(66).string(message.snapshotUUID);
    }
    if (message.snapshotSize !== 0) {
      writer.uint32(72).int64(message.snapshotSize);
    }
    if (message.snapshotURL !== "") {
      writer.uint32(82).string(message.snapshotURL);
    }
    if (message.snapshotWidth !== 0) {
      writer.uint32(88).int32(message.snapshotWidth);
    }
    if (message.snapshotHeight !== 0) {
      writer.uint32(96).int32(message.snapshotHeight);
    }
    if (message.snapshotType !== "") {
      writer.uint32(106).string(message.snapshotType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoBaseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoBaseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.videoUUID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.videoURL = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.videoType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.videoSize = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.snapshotPath = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.snapshotUUID = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.snapshotSize = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.snapshotURL = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.snapshotWidth = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.snapshotHeight = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.snapshotType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoBaseInfo {
    return {
      videoPath: isSet(object.videoPath) ? globalThis.String(object.videoPath) : "",
      videoUUID: isSet(object.videoUUID) ? globalThis.String(object.videoUUID) : "",
      videoURL: isSet(object.videoURL) ? globalThis.String(object.videoURL) : "",
      videoType: isSet(object.videoType) ? globalThis.String(object.videoType) : "",
      videoSize: isSet(object.videoSize) ? globalThis.Number(object.videoSize) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      snapshotPath: isSet(object.snapshotPath) ? globalThis.String(object.snapshotPath) : "",
      snapshotUUID: isSet(object.snapshotUUID) ? globalThis.String(object.snapshotUUID) : "",
      snapshotSize: isSet(object.snapshotSize) ? globalThis.Number(object.snapshotSize) : 0,
      snapshotURL: isSet(object.snapshotURL) ? globalThis.String(object.snapshotURL) : "",
      snapshotWidth: isSet(object.snapshotWidth) ? globalThis.Number(object.snapshotWidth) : 0,
      snapshotHeight: isSet(object.snapshotHeight) ? globalThis.Number(object.snapshotHeight) : 0,
      snapshotType: isSet(object.snapshotType) ? globalThis.String(object.snapshotType) : "",
    };
  },

  toJSON(message: VideoBaseInfo): unknown {
    const obj: any = {};
    if (message.videoPath !== "") {
      obj.videoPath = message.videoPath;
    }
    if (message.videoUUID !== "") {
      obj.videoUUID = message.videoUUID;
    }
    if (message.videoURL !== "") {
      obj.videoURL = message.videoURL;
    }
    if (message.videoType !== "") {
      obj.videoType = message.videoType;
    }
    if (message.videoSize !== 0) {
      obj.videoSize = Math.round(message.videoSize);
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.snapshotPath !== "") {
      obj.snapshotPath = message.snapshotPath;
    }
    if (message.snapshotUUID !== "") {
      obj.snapshotUUID = message.snapshotUUID;
    }
    if (message.snapshotSize !== 0) {
      obj.snapshotSize = Math.round(message.snapshotSize);
    }
    if (message.snapshotURL !== "") {
      obj.snapshotURL = message.snapshotURL;
    }
    if (message.snapshotWidth !== 0) {
      obj.snapshotWidth = Math.round(message.snapshotWidth);
    }
    if (message.snapshotHeight !== 0) {
      obj.snapshotHeight = Math.round(message.snapshotHeight);
    }
    if (message.snapshotType !== "") {
      obj.snapshotType = message.snapshotType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoBaseInfo>, I>>(base?: I): VideoBaseInfo {
    return VideoBaseInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoBaseInfo>, I>>(object: I): VideoBaseInfo {
    const message = createBaseVideoBaseInfo();
    message.videoPath = object.videoPath ?? "";
    message.videoUUID = object.videoUUID ?? "";
    message.videoURL = object.videoURL ?? "";
    message.videoType = object.videoType ?? "";
    message.videoSize = object.videoSize ?? 0;
    message.duration = object.duration ?? 0;
    message.snapshotPath = object.snapshotPath ?? "";
    message.snapshotUUID = object.snapshotUUID ?? "";
    message.snapshotSize = object.snapshotSize ?? 0;
    message.snapshotURL = object.snapshotURL ?? "";
    message.snapshotWidth = object.snapshotWidth ?? 0;
    message.snapshotHeight = object.snapshotHeight ?? 0;
    message.snapshotType = object.snapshotType ?? "";
    return message;
  },
};

function createBaseFileBaseInfo(): FileBaseInfo {
  return { filePath: "", uuid: "", sourceURL: "", fileName: "", fileSize: 0, fileType: "" };
}

export const FileBaseInfo: MessageFns<FileBaseInfo> = {
  encode(message: FileBaseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.uuid !== "") {
      writer.uint32(18).string(message.uuid);
    }
    if (message.sourceURL !== "") {
      writer.uint32(26).string(message.sourceURL);
    }
    if (message.fileName !== "") {
      writer.uint32(34).string(message.fileName);
    }
    if (message.fileSize !== 0) {
      writer.uint32(40).int64(message.fileSize);
    }
    if (message.fileType !== "") {
      writer.uint32(50).string(message.fileType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileBaseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileBaseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceURL = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fileSize = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fileType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileBaseInfo {
    return {
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      sourceURL: isSet(object.sourceURL) ? globalThis.String(object.sourceURL) : "",
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      fileSize: isSet(object.fileSize) ? globalThis.Number(object.fileSize) : 0,
      fileType: isSet(object.fileType) ? globalThis.String(object.fileType) : "",
    };
  },

  toJSON(message: FileBaseInfo): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.sourceURL !== "") {
      obj.sourceURL = message.sourceURL;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    if (message.fileType !== "") {
      obj.fileType = message.fileType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileBaseInfo>, I>>(base?: I): FileBaseInfo {
    return FileBaseInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileBaseInfo>, I>>(object: I): FileBaseInfo {
    const message = createBaseFileBaseInfo();
    message.filePath = object.filePath ?? "";
    message.uuid = object.uuid ?? "";
    message.sourceURL = object.sourceURL ?? "";
    message.fileName = object.fileName ?? "";
    message.fileSize = object.fileSize ?? 0;
    message.fileType = object.fileType ?? "";
    return message;
  },
};

function createBaseTextElem(): TextElem {
  return { content: "" };
}

export const TextElem: MessageFns<TextElem> = {
  encode(message: TextElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextElem {
    return { content: isSet(object.content) ? globalThis.String(object.content) : "" };
  },

  toJSON(message: TextElem): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextElem>, I>>(base?: I): TextElem {
    return TextElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextElem>, I>>(object: I): TextElem {
    const message = createBaseTextElem();
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseCardElem(): CardElem {
  return { userID: "", nickname: "", faceURL: "", ex: "" };
}

export const CardElem: MessageFns<CardElem> = {
  encode(message: CardElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    if (message.nickname !== "") {
      writer.uint32(18).string(message.nickname);
    }
    if (message.faceURL !== "") {
      writer.uint32(26).string(message.faceURL);
    }
    if (message.ex !== "") {
      writer.uint32(34).string(message.ex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CardElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCardElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CardElem {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : "",
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
    };
  },

  toJSON(message: CardElem): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.faceURL !== "") {
      obj.faceURL = message.faceURL;
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CardElem>, I>>(base?: I): CardElem {
    return CardElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CardElem>, I>>(object: I): CardElem {
    const message = createBaseCardElem();
    message.userID = object.userID ?? "";
    message.nickname = object.nickname ?? "";
    message.faceURL = object.faceURL ?? "";
    message.ex = object.ex ?? "";
    return message;
  },
};

function createBasePictureElem(): PictureElem {
  return { sourcePath: "", sourcePicture: undefined, bigPicture: undefined, snapshotPicture: undefined };
}

export const PictureElem: MessageFns<PictureElem> = {
  encode(message: PictureElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourcePath !== "") {
      writer.uint32(10).string(message.sourcePath);
    }
    if (message.sourcePicture !== undefined) {
      PictureBaseInfo.encode(message.sourcePicture, writer.uint32(18).fork()).join();
    }
    if (message.bigPicture !== undefined) {
      PictureBaseInfo.encode(message.bigPicture, writer.uint32(26).fork()).join();
    }
    if (message.snapshotPicture !== undefined) {
      PictureBaseInfo.encode(message.snapshotPicture, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PictureElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePictureElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourcePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourcePicture = PictureBaseInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bigPicture = PictureBaseInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.snapshotPicture = PictureBaseInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PictureElem {
    return {
      sourcePath: isSet(object.sourcePath) ? globalThis.String(object.sourcePath) : "",
      sourcePicture: isSet(object.sourcePicture) ? PictureBaseInfo.fromJSON(object.sourcePicture) : undefined,
      bigPicture: isSet(object.bigPicture) ? PictureBaseInfo.fromJSON(object.bigPicture) : undefined,
      snapshotPicture: isSet(object.snapshotPicture) ? PictureBaseInfo.fromJSON(object.snapshotPicture) : undefined,
    };
  },

  toJSON(message: PictureElem): unknown {
    const obj: any = {};
    if (message.sourcePath !== "") {
      obj.sourcePath = message.sourcePath;
    }
    if (message.sourcePicture !== undefined) {
      obj.sourcePicture = PictureBaseInfo.toJSON(message.sourcePicture);
    }
    if (message.bigPicture !== undefined) {
      obj.bigPicture = PictureBaseInfo.toJSON(message.bigPicture);
    }
    if (message.snapshotPicture !== undefined) {
      obj.snapshotPicture = PictureBaseInfo.toJSON(message.snapshotPicture);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PictureElem>, I>>(base?: I): PictureElem {
    return PictureElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PictureElem>, I>>(object: I): PictureElem {
    const message = createBasePictureElem();
    message.sourcePath = object.sourcePath ?? "";
    message.sourcePicture = (object.sourcePicture !== undefined && object.sourcePicture !== null)
      ? PictureBaseInfo.fromPartial(object.sourcePicture)
      : undefined;
    message.bigPicture = (object.bigPicture !== undefined && object.bigPicture !== null)
      ? PictureBaseInfo.fromPartial(object.bigPicture)
      : undefined;
    message.snapshotPicture = (object.snapshotPicture !== undefined && object.snapshotPicture !== null)
      ? PictureBaseInfo.fromPartial(object.snapshotPicture)
      : undefined;
    return message;
  },
};

function createBaseSoundElem(): SoundElem {
  return { uuid: "", soundPath: "", sourceURL: "", dataSize: 0, duration: 0, soundType: "" };
}

export const SoundElem: MessageFns<SoundElem> = {
  encode(message: SoundElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.soundPath !== "") {
      writer.uint32(18).string(message.soundPath);
    }
    if (message.sourceURL !== "") {
      writer.uint32(26).string(message.sourceURL);
    }
    if (message.dataSize !== 0) {
      writer.uint32(32).int64(message.dataSize);
    }
    if (message.duration !== 0) {
      writer.uint32(40).int64(message.duration);
    }
    if (message.soundType !== "") {
      writer.uint32(50).string(message.soundType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoundElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoundElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.soundPath = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceURL = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dataSize = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.soundType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoundElem {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      soundPath: isSet(object.soundPath) ? globalThis.String(object.soundPath) : "",
      sourceURL: isSet(object.sourceURL) ? globalThis.String(object.sourceURL) : "",
      dataSize: isSet(object.dataSize) ? globalThis.Number(object.dataSize) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      soundType: isSet(object.soundType) ? globalThis.String(object.soundType) : "",
    };
  },

  toJSON(message: SoundElem): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.soundPath !== "") {
      obj.soundPath = message.soundPath;
    }
    if (message.sourceURL !== "") {
      obj.sourceURL = message.sourceURL;
    }
    if (message.dataSize !== 0) {
      obj.dataSize = Math.round(message.dataSize);
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.soundType !== "") {
      obj.soundType = message.soundType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SoundElem>, I>>(base?: I): SoundElem {
    return SoundElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SoundElem>, I>>(object: I): SoundElem {
    const message = createBaseSoundElem();
    message.uuid = object.uuid ?? "";
    message.soundPath = object.soundPath ?? "";
    message.sourceURL = object.sourceURL ?? "";
    message.dataSize = object.dataSize ?? 0;
    message.duration = object.duration ?? 0;
    message.soundType = object.soundType ?? "";
    return message;
  },
};

function createBaseVideoElem(): VideoElem {
  return {
    videoPath: "",
    videoUUID: "",
    videoURL: "",
    videoType: "",
    videoSize: 0,
    duration: 0,
    snapshotPath: "",
    snapshotUUID: "",
    snapshotSize: 0,
    snapshotURL: "",
    snapshotWidth: 0,
    snapshotHeight: 0,
    snapshotType: "",
  };
}

export const VideoElem: MessageFns<VideoElem> = {
  encode(message: VideoElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoPath !== "") {
      writer.uint32(10).string(message.videoPath);
    }
    if (message.videoUUID !== "") {
      writer.uint32(18).string(message.videoUUID);
    }
    if (message.videoURL !== "") {
      writer.uint32(26).string(message.videoURL);
    }
    if (message.videoType !== "") {
      writer.uint32(34).string(message.videoType);
    }
    if (message.videoSize !== 0) {
      writer.uint32(40).int64(message.videoSize);
    }
    if (message.duration !== 0) {
      writer.uint32(48).int64(message.duration);
    }
    if (message.snapshotPath !== "") {
      writer.uint32(58).string(message.snapshotPath);
    }
    if (message.snapshotUUID !== "") {
      writer.uint32(66).string(message.snapshotUUID);
    }
    if (message.snapshotSize !== 0) {
      writer.uint32(72).int64(message.snapshotSize);
    }
    if (message.snapshotURL !== "") {
      writer.uint32(82).string(message.snapshotURL);
    }
    if (message.snapshotWidth !== 0) {
      writer.uint32(88).int32(message.snapshotWidth);
    }
    if (message.snapshotHeight !== 0) {
      writer.uint32(96).int32(message.snapshotHeight);
    }
    if (message.snapshotType !== "") {
      writer.uint32(106).string(message.snapshotType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.videoUUID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.videoURL = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.videoType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.videoSize = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.snapshotPath = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.snapshotUUID = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.snapshotSize = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.snapshotURL = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.snapshotWidth = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.snapshotHeight = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.snapshotType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoElem {
    return {
      videoPath: isSet(object.videoPath) ? globalThis.String(object.videoPath) : "",
      videoUUID: isSet(object.videoUUID) ? globalThis.String(object.videoUUID) : "",
      videoURL: isSet(object.videoURL) ? globalThis.String(object.videoURL) : "",
      videoType: isSet(object.videoType) ? globalThis.String(object.videoType) : "",
      videoSize: isSet(object.videoSize) ? globalThis.Number(object.videoSize) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      snapshotPath: isSet(object.snapshotPath) ? globalThis.String(object.snapshotPath) : "",
      snapshotUUID: isSet(object.snapshotUUID) ? globalThis.String(object.snapshotUUID) : "",
      snapshotSize: isSet(object.snapshotSize) ? globalThis.Number(object.snapshotSize) : 0,
      snapshotURL: isSet(object.snapshotURL) ? globalThis.String(object.snapshotURL) : "",
      snapshotWidth: isSet(object.snapshotWidth) ? globalThis.Number(object.snapshotWidth) : 0,
      snapshotHeight: isSet(object.snapshotHeight) ? globalThis.Number(object.snapshotHeight) : 0,
      snapshotType: isSet(object.snapshotType) ? globalThis.String(object.snapshotType) : "",
    };
  },

  toJSON(message: VideoElem): unknown {
    const obj: any = {};
    if (message.videoPath !== "") {
      obj.videoPath = message.videoPath;
    }
    if (message.videoUUID !== "") {
      obj.videoUUID = message.videoUUID;
    }
    if (message.videoURL !== "") {
      obj.videoURL = message.videoURL;
    }
    if (message.videoType !== "") {
      obj.videoType = message.videoType;
    }
    if (message.videoSize !== 0) {
      obj.videoSize = Math.round(message.videoSize);
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.snapshotPath !== "") {
      obj.snapshotPath = message.snapshotPath;
    }
    if (message.snapshotUUID !== "") {
      obj.snapshotUUID = message.snapshotUUID;
    }
    if (message.snapshotSize !== 0) {
      obj.snapshotSize = Math.round(message.snapshotSize);
    }
    if (message.snapshotURL !== "") {
      obj.snapshotURL = message.snapshotURL;
    }
    if (message.snapshotWidth !== 0) {
      obj.snapshotWidth = Math.round(message.snapshotWidth);
    }
    if (message.snapshotHeight !== 0) {
      obj.snapshotHeight = Math.round(message.snapshotHeight);
    }
    if (message.snapshotType !== "") {
      obj.snapshotType = message.snapshotType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VideoElem>, I>>(base?: I): VideoElem {
    return VideoElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VideoElem>, I>>(object: I): VideoElem {
    const message = createBaseVideoElem();
    message.videoPath = object.videoPath ?? "";
    message.videoUUID = object.videoUUID ?? "";
    message.videoURL = object.videoURL ?? "";
    message.videoType = object.videoType ?? "";
    message.videoSize = object.videoSize ?? 0;
    message.duration = object.duration ?? 0;
    message.snapshotPath = object.snapshotPath ?? "";
    message.snapshotUUID = object.snapshotUUID ?? "";
    message.snapshotSize = object.snapshotSize ?? 0;
    message.snapshotURL = object.snapshotURL ?? "";
    message.snapshotWidth = object.snapshotWidth ?? 0;
    message.snapshotHeight = object.snapshotHeight ?? 0;
    message.snapshotType = object.snapshotType ?? "";
    return message;
  },
};

function createBaseFileElem(): FileElem {
  return { filePath: "", uuid: "", sourceURL: "", fileName: "", fileSize: 0, fileType: "" };
}

export const FileElem: MessageFns<FileElem> = {
  encode(message: FileElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.uuid !== "") {
      writer.uint32(18).string(message.uuid);
    }
    if (message.sourceURL !== "") {
      writer.uint32(26).string(message.sourceURL);
    }
    if (message.fileName !== "") {
      writer.uint32(34).string(message.fileName);
    }
    if (message.fileSize !== 0) {
      writer.uint32(40).int64(message.fileSize);
    }
    if (message.fileType !== "") {
      writer.uint32(50).string(message.fileType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceURL = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fileSize = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fileType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileElem {
    return {
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      sourceURL: isSet(object.sourceURL) ? globalThis.String(object.sourceURL) : "",
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      fileSize: isSet(object.fileSize) ? globalThis.Number(object.fileSize) : 0,
      fileType: isSet(object.fileType) ? globalThis.String(object.fileType) : "",
    };
  },

  toJSON(message: FileElem): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.sourceURL !== "") {
      obj.sourceURL = message.sourceURL;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    if (message.fileType !== "") {
      obj.fileType = message.fileType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileElem>, I>>(base?: I): FileElem {
    return FileElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileElem>, I>>(object: I): FileElem {
    const message = createBaseFileElem();
    message.filePath = object.filePath ?? "";
    message.uuid = object.uuid ?? "";
    message.sourceURL = object.sourceURL ?? "";
    message.fileName = object.fileName ?? "";
    message.fileSize = object.fileSize ?? 0;
    message.fileType = object.fileType ?? "";
    return message;
  },
};

function createBaseMessageEntity(): MessageEntity {
  return { type: "", offset: 0, length: 0, url: "", ex: "" };
}

export const MessageEntity: MessageFns<MessageEntity> = {
  encode(message: MessageEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.offset !== 0) {
      writer.uint32(16).int32(message.offset);
    }
    if (message.length !== 0) {
      writer.uint32(24).int32(message.length);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    if (message.ex !== "") {
      writer.uint32(42).string(message.ex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageEntity {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
    };
  },

  toJSON(message: MessageEntity): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageEntity>, I>>(base?: I): MessageEntity {
    return MessageEntity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageEntity>, I>>(object: I): MessageEntity {
    const message = createBaseMessageEntity();
    message.type = object.type ?? "";
    message.offset = object.offset ?? 0;
    message.length = object.length ?? 0;
    message.url = object.url ?? "";
    message.ex = object.ex ?? "";
    return message;
  },
};

function createBaseMergeElem(): MergeElem {
  return { title: "", abstractList: [], multiMessage: [], messageEntityList: [] };
}

export const MergeElem: MessageFns<MergeElem> = {
  encode(message: MergeElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    for (const v of message.abstractList) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.multiMessage) {
      IMMessage.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.messageEntityList) {
      MessageEntity.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.abstractList.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.multiMessage.push(IMMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.messageEntityList.push(MessageEntity.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeElem {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      abstractList: globalThis.Array.isArray(object?.abstractList)
        ? object.abstractList.map((e: any) => globalThis.String(e))
        : [],
      multiMessage: globalThis.Array.isArray(object?.multiMessage)
        ? object.multiMessage.map((e: any) => IMMessage.fromJSON(e))
        : [],
      messageEntityList: globalThis.Array.isArray(object?.messageEntityList)
        ? object.messageEntityList.map((e: any) => MessageEntity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MergeElem): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.abstractList?.length) {
      obj.abstractList = message.abstractList;
    }
    if (message.multiMessage?.length) {
      obj.multiMessage = message.multiMessage.map((e) => IMMessage.toJSON(e));
    }
    if (message.messageEntityList?.length) {
      obj.messageEntityList = message.messageEntityList.map((e) => MessageEntity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MergeElem>, I>>(base?: I): MergeElem {
    return MergeElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MergeElem>, I>>(object: I): MergeElem {
    const message = createBaseMergeElem();
    message.title = object.title ?? "";
    message.abstractList = object.abstractList?.map((e) => e) || [];
    message.multiMessage = object.multiMessage?.map((e) => IMMessage.fromPartial(e)) || [];
    message.messageEntityList = object.messageEntityList?.map((e) => MessageEntity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAtTextElem(): AtTextElem {
  return { text: "", atUserList: [], atUsersInfo: [], quoteMessage: undefined, isAtSelf: false };
}

export const AtTextElem: MessageFns<AtTextElem> = {
  encode(message: AtTextElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.atUserList) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.atUsersInfo) {
      AtInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.quoteMessage !== undefined) {
      IMMessage.encode(message.quoteMessage, writer.uint32(34).fork()).join();
    }
    if (message.isAtSelf !== false) {
      writer.uint32(40).bool(message.isAtSelf);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AtTextElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAtTextElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.atUserList.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.atUsersInfo.push(AtInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.quoteMessage = IMMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isAtSelf = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AtTextElem {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      atUserList: globalThis.Array.isArray(object?.atUserList)
        ? object.atUserList.map((e: any) => globalThis.String(e))
        : [],
      atUsersInfo: globalThis.Array.isArray(object?.atUsersInfo)
        ? object.atUsersInfo.map((e: any) => AtInfo.fromJSON(e))
        : [],
      quoteMessage: isSet(object.quoteMessage) ? IMMessage.fromJSON(object.quoteMessage) : undefined,
      isAtSelf: isSet(object.isAtSelf) ? globalThis.Boolean(object.isAtSelf) : false,
    };
  },

  toJSON(message: AtTextElem): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.atUserList?.length) {
      obj.atUserList = message.atUserList;
    }
    if (message.atUsersInfo?.length) {
      obj.atUsersInfo = message.atUsersInfo.map((e) => AtInfo.toJSON(e));
    }
    if (message.quoteMessage !== undefined) {
      obj.quoteMessage = IMMessage.toJSON(message.quoteMessage);
    }
    if (message.isAtSelf !== false) {
      obj.isAtSelf = message.isAtSelf;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AtTextElem>, I>>(base?: I): AtTextElem {
    return AtTextElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AtTextElem>, I>>(object: I): AtTextElem {
    const message = createBaseAtTextElem();
    message.text = object.text ?? "";
    message.atUserList = object.atUserList?.map((e) => e) || [];
    message.atUsersInfo = object.atUsersInfo?.map((e) => AtInfo.fromPartial(e)) || [];
    message.quoteMessage = (object.quoteMessage !== undefined && object.quoteMessage !== null)
      ? IMMessage.fromPartial(object.quoteMessage)
      : undefined;
    message.isAtSelf = object.isAtSelf ?? false;
    return message;
  },
};

function createBaseFaceElem(): FaceElem {
  return { index: 0, data: "" };
}

export const FaceElem: MessageFns<FaceElem> = {
  encode(message: FaceElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FaceElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFaceElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FaceElem {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      data: isSet(object.data) ? globalThis.String(object.data) : "",
    };
  },

  toJSON(message: FaceElem): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FaceElem>, I>>(base?: I): FaceElem {
    return FaceElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FaceElem>, I>>(object: I): FaceElem {
    const message = createBaseFaceElem();
    message.index = object.index ?? 0;
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseLocationElem(): LocationElem {
  return { description: "", longitude: 0, latitude: 0 };
}

export const LocationElem: MessageFns<LocationElem> = {
  encode(message: LocationElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    if (message.latitude !== 0) {
      writer.uint32(25).double(message.latitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.latitude = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationElem {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
    };
  },

  toJSON(message: LocationElem): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocationElem>, I>>(base?: I): LocationElem {
    return LocationElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocationElem>, I>>(object: I): LocationElem {
    const message = createBaseLocationElem();
    message.description = object.description ?? "";
    message.longitude = object.longitude ?? 0;
    message.latitude = object.latitude ?? 0;
    return message;
  },
};

function createBaseCustomElem(): CustomElem {
  return { data: "", description: "", extension: "" };
}

export const CustomElem: MessageFns<CustomElem> = {
  encode(message: CustomElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.extension !== "") {
      writer.uint32(26).string(message.extension);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.extension = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomElem {
    return {
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      extension: isSet(object.extension) ? globalThis.String(object.extension) : "",
    };
  },

  toJSON(message: CustomElem): unknown {
    const obj: any = {};
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.extension !== "") {
      obj.extension = message.extension;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomElem>, I>>(base?: I): CustomElem {
    return CustomElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomElem>, I>>(object: I): CustomElem {
    const message = createBaseCustomElem();
    message.data = object.data ?? "";
    message.description = object.description ?? "";
    message.extension = object.extension ?? "";
    return message;
  },
};

function createBaseQuoteElem(): QuoteElem {
  return { text: "", quoteMessage: undefined, messageEntityList: [] };
}

export const QuoteElem: MessageFns<QuoteElem> = {
  encode(message: QuoteElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.quoteMessage !== undefined) {
      IMMessage.encode(message.quoteMessage, writer.uint32(18).fork()).join();
    }
    for (const v of message.messageEntityList) {
      MessageEntity.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuoteElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuoteElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quoteMessage = IMMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.messageEntityList.push(MessageEntity.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuoteElem {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      quoteMessage: isSet(object.quoteMessage) ? IMMessage.fromJSON(object.quoteMessage) : undefined,
      messageEntityList: globalThis.Array.isArray(object?.messageEntityList)
        ? object.messageEntityList.map((e: any) => MessageEntity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QuoteElem): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.quoteMessage !== undefined) {
      obj.quoteMessage = IMMessage.toJSON(message.quoteMessage);
    }
    if (message.messageEntityList?.length) {
      obj.messageEntityList = message.messageEntityList.map((e) => MessageEntity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteElem>, I>>(base?: I): QuoteElem {
    return QuoteElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteElem>, I>>(object: I): QuoteElem {
    const message = createBaseQuoteElem();
    message.text = object.text ?? "";
    message.quoteMessage = (object.quoteMessage !== undefined && object.quoteMessage !== null)
      ? IMMessage.fromPartial(object.quoteMessage)
      : undefined;
    message.messageEntityList = object.messageEntityList?.map((e) => MessageEntity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdvancedTextElem(): AdvancedTextElem {
  return { text: "", messageEntityList: [] };
}

export const AdvancedTextElem: MessageFns<AdvancedTextElem> = {
  encode(message: AdvancedTextElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.messageEntityList) {
      MessageEntity.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedTextElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedTextElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageEntityList.push(MessageEntity.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedTextElem {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      messageEntityList: globalThis.Array.isArray(object?.messageEntityList)
        ? object.messageEntityList.map((e: any) => MessageEntity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AdvancedTextElem): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.messageEntityList?.length) {
      obj.messageEntityList = message.messageEntityList.map((e) => MessageEntity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AdvancedTextElem>, I>>(base?: I): AdvancedTextElem {
    return AdvancedTextElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AdvancedTextElem>, I>>(object: I): AdvancedTextElem {
    const message = createBaseAdvancedTextElem();
    message.text = object.text ?? "";
    message.messageEntityList = object.messageEntityList?.map((e) => MessageEntity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTypingElem(): TypingElem {
  return { msgTips: "" };
}

export const TypingElem: MessageFns<TypingElem> = {
  encode(message: TypingElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgTips !== "") {
      writer.uint32(10).string(message.msgTips);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypingElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypingElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgTips = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypingElem {
    return { msgTips: isSet(object.msgTips) ? globalThis.String(object.msgTips) : "" };
  },

  toJSON(message: TypingElem): unknown {
    const obj: any = {};
    if (message.msgTips !== "") {
      obj.msgTips = message.msgTips;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypingElem>, I>>(base?: I): TypingElem {
    return TypingElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypingElem>, I>>(object: I): TypingElem {
    const message = createBaseTypingElem();
    message.msgTips = object.msgTips ?? "";
    return message;
  },
};

function createBaseStreamElem(): StreamElem {
  return { type: "", content: "", packets: [], end: false };
}

export const StreamElem: MessageFns<StreamElem> = {
  encode(message: StreamElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    for (const v of message.packets) {
      writer.uint32(26).string(v!);
    }
    if (message.end !== false) {
      writer.uint32(32).bool(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.packets.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.end = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamElem {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      packets: globalThis.Array.isArray(object?.packets) ? object.packets.map((e: any) => globalThis.String(e)) : [],
      end: isSet(object.end) ? globalThis.Boolean(object.end) : false,
    };
  },

  toJSON(message: StreamElem): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.packets?.length) {
      obj.packets = message.packets;
    }
    if (message.end !== false) {
      obj.end = message.end;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamElem>, I>>(base?: I): StreamElem {
    return StreamElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamElem>, I>>(object: I): StreamElem {
    const message = createBaseStreamElem();
    message.type = object.type ?? "";
    message.content = object.content ?? "";
    message.packets = object.packets?.map((e) => e) || [];
    message.end = object.end ?? false;
    return message;
  },
};

function createBaseGroupHasReadInfo(): GroupHasReadInfo {
  return { hasReadUserIDList: [], hasReadCount: 0, groupMemberCount: 0 };
}

export const GroupHasReadInfo: MessageFns<GroupHasReadInfo> = {
  encode(message: GroupHasReadInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.hasReadUserIDList) {
      writer.uint32(10).string(v!);
    }
    if (message.hasReadCount !== 0) {
      writer.uint32(16).int32(message.hasReadCount);
    }
    if (message.groupMemberCount !== 0) {
      writer.uint32(24).int32(message.groupMemberCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupHasReadInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupHasReadInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hasReadUserIDList.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hasReadCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupMemberCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupHasReadInfo {
    return {
      hasReadUserIDList: globalThis.Array.isArray(object?.hasReadUserIDList)
        ? object.hasReadUserIDList.map((e: any) => globalThis.String(e))
        : [],
      hasReadCount: isSet(object.hasReadCount) ? globalThis.Number(object.hasReadCount) : 0,
      groupMemberCount: isSet(object.groupMemberCount) ? globalThis.Number(object.groupMemberCount) : 0,
    };
  },

  toJSON(message: GroupHasReadInfo): unknown {
    const obj: any = {};
    if (message.hasReadUserIDList?.length) {
      obj.hasReadUserIDList = message.hasReadUserIDList;
    }
    if (message.hasReadCount !== 0) {
      obj.hasReadCount = Math.round(message.hasReadCount);
    }
    if (message.groupMemberCount !== 0) {
      obj.groupMemberCount = Math.round(message.groupMemberCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupHasReadInfo>, I>>(base?: I): GroupHasReadInfo {
    return GroupHasReadInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupHasReadInfo>, I>>(object: I): GroupHasReadInfo {
    const message = createBaseGroupHasReadInfo();
    message.hasReadUserIDList = object.hasReadUserIDList?.map((e) => e) || [];
    message.hasReadCount = object.hasReadCount ?? 0;
    message.groupMemberCount = object.groupMemberCount ?? 0;
    return message;
  },
};

function createBaseUploadProgress(): UploadProgress {
  return { total: 0, save: 0, current: 0, uploadID: "" };
}

export const UploadProgress: MessageFns<UploadProgress> = {
  encode(message: UploadProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int64(message.total);
    }
    if (message.save !== 0) {
      writer.uint32(16).int64(message.save);
    }
    if (message.current !== 0) {
      writer.uint32(24).int64(message.current);
    }
    if (message.uploadID !== "") {
      writer.uint32(34).string(message.uploadID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.save = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.current = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uploadID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadProgress {
    return {
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      save: isSet(object.save) ? globalThis.Number(object.save) : 0,
      current: isSet(object.current) ? globalThis.Number(object.current) : 0,
      uploadID: isSet(object.uploadID) ? globalThis.String(object.uploadID) : "",
    };
  },

  toJSON(message: UploadProgress): unknown {
    const obj: any = {};
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.save !== 0) {
      obj.save = Math.round(message.save);
    }
    if (message.current !== 0) {
      obj.current = Math.round(message.current);
    }
    if (message.uploadID !== "") {
      obj.uploadID = message.uploadID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadProgress>, I>>(base?: I): UploadProgress {
    return UploadProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadProgress>, I>>(object: I): UploadProgress {
    const message = createBaseUploadProgress();
    message.total = object.total ?? 0;
    message.save = object.save ?? 0;
    message.current = object.current ?? 0;
    message.uploadID = object.uploadID ?? "";
    return message;
  },
};

function createBaseAttachedInfoElem(): AttachedInfoElem {
  return { groupHasReadInfo: undefined, isPrivateChat: false, burnDuration: 0, hasReadTime: 0, progress: undefined };
}

export const AttachedInfoElem: MessageFns<AttachedInfoElem> = {
  encode(message: AttachedInfoElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupHasReadInfo !== undefined) {
      GroupHasReadInfo.encode(message.groupHasReadInfo, writer.uint32(10).fork()).join();
    }
    if (message.isPrivateChat !== false) {
      writer.uint32(16).bool(message.isPrivateChat);
    }
    if (message.burnDuration !== 0) {
      writer.uint32(24).int32(message.burnDuration);
    }
    if (message.hasReadTime !== 0) {
      writer.uint32(32).int64(message.hasReadTime);
    }
    if (message.progress !== undefined) {
      UploadProgress.encode(message.progress, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachedInfoElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachedInfoElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupHasReadInfo = GroupHasReadInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isPrivateChat = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.burnDuration = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hasReadTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.progress = UploadProgress.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttachedInfoElem {
    return {
      groupHasReadInfo: isSet(object.groupHasReadInfo) ? GroupHasReadInfo.fromJSON(object.groupHasReadInfo) : undefined,
      isPrivateChat: isSet(object.isPrivateChat) ? globalThis.Boolean(object.isPrivateChat) : false,
      burnDuration: isSet(object.burnDuration) ? globalThis.Number(object.burnDuration) : 0,
      hasReadTime: isSet(object.hasReadTime) ? globalThis.Number(object.hasReadTime) : 0,
      progress: isSet(object.progress) ? UploadProgress.fromJSON(object.progress) : undefined,
    };
  },

  toJSON(message: AttachedInfoElem): unknown {
    const obj: any = {};
    if (message.groupHasReadInfo !== undefined) {
      obj.groupHasReadInfo = GroupHasReadInfo.toJSON(message.groupHasReadInfo);
    }
    if (message.isPrivateChat !== false) {
      obj.isPrivateChat = message.isPrivateChat;
    }
    if (message.burnDuration !== 0) {
      obj.burnDuration = Math.round(message.burnDuration);
    }
    if (message.hasReadTime !== 0) {
      obj.hasReadTime = Math.round(message.hasReadTime);
    }
    if (message.progress !== undefined) {
      obj.progress = UploadProgress.toJSON(message.progress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttachedInfoElem>, I>>(base?: I): AttachedInfoElem {
    return AttachedInfoElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttachedInfoElem>, I>>(object: I): AttachedInfoElem {
    const message = createBaseAttachedInfoElem();
    message.groupHasReadInfo = (object.groupHasReadInfo !== undefined && object.groupHasReadInfo !== null)
      ? GroupHasReadInfo.fromPartial(object.groupHasReadInfo)
      : undefined;
    message.isPrivateChat = object.isPrivateChat ?? false;
    message.burnDuration = object.burnDuration ?? 0;
    message.hasReadTime = object.hasReadTime ?? 0;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? UploadProgress.fromPartial(object.progress)
      : undefined;
    return message;
  },
};

function createBaseGroupCreatedTips(): GroupCreatedTips {
  return { group: undefined, opUser: undefined, memberList: [], operationTime: 0, groupOwnerUser: undefined };
}

export const GroupCreatedTips: MessageFns<GroupCreatedTips> = {
  encode(message: GroupCreatedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    for (const v of message.memberList) {
      GroupMemberInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(32).int64(message.operationTime);
    }
    if (message.groupOwnerUser !== undefined) {
      GroupMemberInfo.encode(message.groupOwnerUser, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupCreatedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupCreatedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.memberList.push(GroupMemberInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.groupOwnerUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupCreatedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      memberList: globalThis.Array.isArray(object?.memberList)
        ? object.memberList.map((e: any) => GroupMemberInfo.fromJSON(e))
        : [],
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
      groupOwnerUser: isSet(object.groupOwnerUser) ? GroupMemberInfo.fromJSON(object.groupOwnerUser) : undefined,
    };
  },

  toJSON(message: GroupCreatedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.memberList?.length) {
      obj.memberList = message.memberList.map((e) => GroupMemberInfo.toJSON(e));
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    if (message.groupOwnerUser !== undefined) {
      obj.groupOwnerUser = GroupMemberInfo.toJSON(message.groupOwnerUser);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupCreatedTips>, I>>(base?: I): GroupCreatedTips {
    return GroupCreatedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupCreatedTips>, I>>(object: I): GroupCreatedTips {
    const message = createBaseGroupCreatedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.memberList = object.memberList?.map((e) => GroupMemberInfo.fromPartial(e)) || [];
    message.operationTime = object.operationTime ?? 0;
    message.groupOwnerUser = (object.groupOwnerUser !== undefined && object.groupOwnerUser !== null)
      ? GroupMemberInfo.fromPartial(object.groupOwnerUser)
      : undefined;
    return message;
  },
};

function createBaseGroupInfoSetTips(): GroupInfoSetTips {
  return { opUser: undefined, muteTime: 0, group: undefined };
}

export const GroupInfoSetTips: MessageFns<GroupInfoSetTips> = {
  encode(message: GroupInfoSetTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(10).fork()).join();
    }
    if (message.muteTime !== 0) {
      writer.uint32(16).int64(message.muteTime);
    }
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupInfoSetTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupInfoSetTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.muteTime = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupInfoSetTips {
    return {
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      muteTime: isSet(object.muteTime) ? globalThis.Number(object.muteTime) : 0,
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
    };
  },

  toJSON(message: GroupInfoSetTips): unknown {
    const obj: any = {};
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.muteTime !== 0) {
      obj.muteTime = Math.round(message.muteTime);
    }
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupInfoSetTips>, I>>(base?: I): GroupInfoSetTips {
    return GroupInfoSetTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupInfoSetTips>, I>>(object: I): GroupInfoSetTips {
    const message = createBaseGroupInfoSetTips();
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.muteTime = object.muteTime ?? 0;
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    return message;
  },
};

function createBaseGroupInfoSetNameTips(): GroupInfoSetNameTips {
  return { opUser: undefined, group: undefined };
}

export const GroupInfoSetNameTips: MessageFns<GroupInfoSetNameTips> = {
  encode(message: GroupInfoSetNameTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(10).fork()).join();
    }
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupInfoSetNameTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupInfoSetNameTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupInfoSetNameTips {
    return {
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
    };
  },

  toJSON(message: GroupInfoSetNameTips): unknown {
    const obj: any = {};
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupInfoSetNameTips>, I>>(base?: I): GroupInfoSetNameTips {
    return GroupInfoSetNameTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupInfoSetNameTips>, I>>(object: I): GroupInfoSetNameTips {
    const message = createBaseGroupInfoSetNameTips();
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    return message;
  },
};

function createBaseGroupInfoSetAnnouncementTips(): GroupInfoSetAnnouncementTips {
  return { opUser: undefined, group: undefined };
}

export const GroupInfoSetAnnouncementTips: MessageFns<GroupInfoSetAnnouncementTips> = {
  encode(message: GroupInfoSetAnnouncementTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(10).fork()).join();
    }
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupInfoSetAnnouncementTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupInfoSetAnnouncementTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupInfoSetAnnouncementTips {
    return {
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
    };
  },

  toJSON(message: GroupInfoSetAnnouncementTips): unknown {
    const obj: any = {};
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupInfoSetAnnouncementTips>, I>>(base?: I): GroupInfoSetAnnouncementTips {
    return GroupInfoSetAnnouncementTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupInfoSetAnnouncementTips>, I>>(object: I): GroupInfoSetAnnouncementTips {
    const message = createBaseGroupInfoSetAnnouncementTips();
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    return message;
  },
};

function createBaseJoinGroupApplicationTips(): JoinGroupApplicationTips {
  return { group: undefined, applicant: undefined, reqMsg: "" };
}

export const JoinGroupApplicationTips: MessageFns<JoinGroupApplicationTips> = {
  encode(message: JoinGroupApplicationTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.applicant !== undefined) {
      UserInfo.encode(message.applicant, writer.uint32(18).fork()).join();
    }
    if (message.reqMsg !== "") {
      writer.uint32(26).string(message.reqMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinGroupApplicationTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinGroupApplicationTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.applicant = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reqMsg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinGroupApplicationTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      applicant: isSet(object.applicant) ? UserInfo.fromJSON(object.applicant) : undefined,
      reqMsg: isSet(object.reqMsg) ? globalThis.String(object.reqMsg) : "",
    };
  },

  toJSON(message: JoinGroupApplicationTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.applicant !== undefined) {
      obj.applicant = UserInfo.toJSON(message.applicant);
    }
    if (message.reqMsg !== "") {
      obj.reqMsg = message.reqMsg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinGroupApplicationTips>, I>>(base?: I): JoinGroupApplicationTips {
    return JoinGroupApplicationTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinGroupApplicationTips>, I>>(object: I): JoinGroupApplicationTips {
    const message = createBaseJoinGroupApplicationTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.applicant = (object.applicant !== undefined && object.applicant !== null)
      ? UserInfo.fromPartial(object.applicant)
      : undefined;
    message.reqMsg = object.reqMsg ?? "";
    return message;
  },
};

function createBaseMemberQuitTips(): MemberQuitTips {
  return { group: undefined, quitUser: undefined, operationTime: 0 };
}

export const MemberQuitTips: MessageFns<MemberQuitTips> = {
  encode(message: MemberQuitTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.quitUser !== undefined) {
      GroupMemberInfo.encode(message.quitUser, writer.uint32(18).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(24).int64(message.operationTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemberQuitTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemberQuitTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quitUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemberQuitTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      quitUser: isSet(object.quitUser) ? GroupMemberInfo.fromJSON(object.quitUser) : undefined,
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
    };
  },

  toJSON(message: MemberQuitTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.quitUser !== undefined) {
      obj.quitUser = GroupMemberInfo.toJSON(message.quitUser);
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemberQuitTips>, I>>(base?: I): MemberQuitTips {
    return MemberQuitTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemberQuitTips>, I>>(object: I): MemberQuitTips {
    const message = createBaseMemberQuitTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.quitUser = (object.quitUser !== undefined && object.quitUser !== null)
      ? GroupMemberInfo.fromPartial(object.quitUser)
      : undefined;
    message.operationTime = object.operationTime ?? 0;
    return message;
  },
};

function createBaseGroupApplicationAcceptedTips(): GroupApplicationAcceptedTips {
  return { group: undefined, opUser: undefined, handleMsg: "", receiverAs: 0 };
}

export const GroupApplicationAcceptedTips: MessageFns<GroupApplicationAcceptedTips> = {
  encode(message: GroupApplicationAcceptedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    if (message.handleMsg !== "") {
      writer.uint32(34).string(message.handleMsg);
    }
    if (message.receiverAs !== 0) {
      writer.uint32(40).int32(message.receiverAs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupApplicationAcceptedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupApplicationAcceptedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.handleMsg = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.receiverAs = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupApplicationAcceptedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      handleMsg: isSet(object.handleMsg) ? globalThis.String(object.handleMsg) : "",
      receiverAs: isSet(object.receiverAs) ? globalThis.Number(object.receiverAs) : 0,
    };
  },

  toJSON(message: GroupApplicationAcceptedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.handleMsg !== "") {
      obj.handleMsg = message.handleMsg;
    }
    if (message.receiverAs !== 0) {
      obj.receiverAs = Math.round(message.receiverAs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupApplicationAcceptedTips>, I>>(base?: I): GroupApplicationAcceptedTips {
    return GroupApplicationAcceptedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupApplicationAcceptedTips>, I>>(object: I): GroupApplicationAcceptedTips {
    const message = createBaseGroupApplicationAcceptedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.handleMsg = object.handleMsg ?? "";
    message.receiverAs = object.receiverAs ?? 0;
    return message;
  },
};

function createBaseGroupApplicationRejectedTips(): GroupApplicationRejectedTips {
  return { group: undefined, opUser: undefined, handleMsg: "", receiverAs: 0 };
}

export const GroupApplicationRejectedTips: MessageFns<GroupApplicationRejectedTips> = {
  encode(message: GroupApplicationRejectedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    if (message.handleMsg !== "") {
      writer.uint32(34).string(message.handleMsg);
    }
    if (message.receiverAs !== 0) {
      writer.uint32(40).int32(message.receiverAs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupApplicationRejectedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupApplicationRejectedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.handleMsg = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.receiverAs = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupApplicationRejectedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      handleMsg: isSet(object.handleMsg) ? globalThis.String(object.handleMsg) : "",
      receiverAs: isSet(object.receiverAs) ? globalThis.Number(object.receiverAs) : 0,
    };
  },

  toJSON(message: GroupApplicationRejectedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.handleMsg !== "") {
      obj.handleMsg = message.handleMsg;
    }
    if (message.receiverAs !== 0) {
      obj.receiverAs = Math.round(message.receiverAs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupApplicationRejectedTips>, I>>(base?: I): GroupApplicationRejectedTips {
    return GroupApplicationRejectedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupApplicationRejectedTips>, I>>(object: I): GroupApplicationRejectedTips {
    const message = createBaseGroupApplicationRejectedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.handleMsg = object.handleMsg ?? "";
    message.receiverAs = object.receiverAs ?? 0;
    return message;
  },
};

function createBaseGroupOwnerTransferredTips(): GroupOwnerTransferredTips {
  return {
    group: undefined,
    opUser: undefined,
    newGroupOwner: undefined,
    oldGroupOwner: "",
    operationTime: 0,
    oldGroupOwnerInfo: undefined,
  };
}

export const GroupOwnerTransferredTips: MessageFns<GroupOwnerTransferredTips> = {
  encode(message: GroupOwnerTransferredTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    if (message.newGroupOwner !== undefined) {
      GroupMemberInfo.encode(message.newGroupOwner, writer.uint32(26).fork()).join();
    }
    if (message.oldGroupOwner !== "") {
      writer.uint32(34).string(message.oldGroupOwner);
    }
    if (message.operationTime !== 0) {
      writer.uint32(40).int64(message.operationTime);
    }
    if (message.oldGroupOwnerInfo !== undefined) {
      GroupMemberInfo.encode(message.oldGroupOwnerInfo, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupOwnerTransferredTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupOwnerTransferredTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newGroupOwner = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oldGroupOwner = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.oldGroupOwnerInfo = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupOwnerTransferredTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      newGroupOwner: isSet(object.newGroupOwner) ? GroupMemberInfo.fromJSON(object.newGroupOwner) : undefined,
      oldGroupOwner: isSet(object.oldGroupOwner) ? globalThis.String(object.oldGroupOwner) : "",
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
      oldGroupOwnerInfo: isSet(object.oldGroupOwnerInfo)
        ? GroupMemberInfo.fromJSON(object.oldGroupOwnerInfo)
        : undefined,
    };
  },

  toJSON(message: GroupOwnerTransferredTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.newGroupOwner !== undefined) {
      obj.newGroupOwner = GroupMemberInfo.toJSON(message.newGroupOwner);
    }
    if (message.oldGroupOwner !== "") {
      obj.oldGroupOwner = message.oldGroupOwner;
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    if (message.oldGroupOwnerInfo !== undefined) {
      obj.oldGroupOwnerInfo = GroupMemberInfo.toJSON(message.oldGroupOwnerInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupOwnerTransferredTips>, I>>(base?: I): GroupOwnerTransferredTips {
    return GroupOwnerTransferredTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupOwnerTransferredTips>, I>>(object: I): GroupOwnerTransferredTips {
    const message = createBaseGroupOwnerTransferredTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.newGroupOwner = (object.newGroupOwner !== undefined && object.newGroupOwner !== null)
      ? GroupMemberInfo.fromPartial(object.newGroupOwner)
      : undefined;
    message.oldGroupOwner = object.oldGroupOwner ?? "";
    message.operationTime = object.operationTime ?? 0;
    message.oldGroupOwnerInfo = (object.oldGroupOwnerInfo !== undefined && object.oldGroupOwnerInfo !== null)
      ? GroupMemberInfo.fromPartial(object.oldGroupOwnerInfo)
      : undefined;
    return message;
  },
};

function createBaseMemberKickedTips(): MemberKickedTips {
  return { group: undefined, opUser: undefined, kickedUserList: [], operationTime: 0 };
}

export const MemberKickedTips: MessageFns<MemberKickedTips> = {
  encode(message: MemberKickedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    for (const v of message.kickedUserList) {
      GroupMemberInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(32).int64(message.operationTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemberKickedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemberKickedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kickedUserList.push(GroupMemberInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemberKickedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      kickedUserList: globalThis.Array.isArray(object?.kickedUserList)
        ? object.kickedUserList.map((e: any) => GroupMemberInfo.fromJSON(e))
        : [],
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
    };
  },

  toJSON(message: MemberKickedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.kickedUserList?.length) {
      obj.kickedUserList = message.kickedUserList.map((e) => GroupMemberInfo.toJSON(e));
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemberKickedTips>, I>>(base?: I): MemberKickedTips {
    return MemberKickedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemberKickedTips>, I>>(object: I): MemberKickedTips {
    const message = createBaseMemberKickedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.kickedUserList = object.kickedUserList?.map((e) => GroupMemberInfo.fromPartial(e)) || [];
    message.operationTime = object.operationTime ?? 0;
    return message;
  },
};

function createBaseMemberInvitedTips(): MemberInvitedTips {
  return { group: undefined, opUser: undefined, invitedUserList: [], operationTime: 0, inviterUser: undefined };
}

export const MemberInvitedTips: MessageFns<MemberInvitedTips> = {
  encode(message: MemberInvitedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    for (const v of message.invitedUserList) {
      GroupMemberInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(32).int64(message.operationTime);
    }
    if (message.inviterUser !== undefined) {
      GroupMemberInfo.encode(message.inviterUser, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemberInvitedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemberInvitedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.invitedUserList.push(GroupMemberInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inviterUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemberInvitedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      invitedUserList: globalThis.Array.isArray(object?.invitedUserList)
        ? object.invitedUserList.map((e: any) => GroupMemberInfo.fromJSON(e))
        : [],
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
      inviterUser: isSet(object.inviterUser) ? GroupMemberInfo.fromJSON(object.inviterUser) : undefined,
    };
  },

  toJSON(message: MemberInvitedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.invitedUserList?.length) {
      obj.invitedUserList = message.invitedUserList.map((e) => GroupMemberInfo.toJSON(e));
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    if (message.inviterUser !== undefined) {
      obj.inviterUser = GroupMemberInfo.toJSON(message.inviterUser);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemberInvitedTips>, I>>(base?: I): MemberInvitedTips {
    return MemberInvitedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemberInvitedTips>, I>>(object: I): MemberInvitedTips {
    const message = createBaseMemberInvitedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.invitedUserList = object.invitedUserList?.map((e) => GroupMemberInfo.fromPartial(e)) || [];
    message.operationTime = object.operationTime ?? 0;
    message.inviterUser = (object.inviterUser !== undefined && object.inviterUser !== null)
      ? GroupMemberInfo.fromPartial(object.inviterUser)
      : undefined;
    return message;
  },
};

function createBaseMemberEnterTips(): MemberEnterTips {
  return { group: undefined, entrantUser: undefined, operationTime: 0 };
}

export const MemberEnterTips: MessageFns<MemberEnterTips> = {
  encode(message: MemberEnterTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.entrantUser !== undefined) {
      GroupMemberInfo.encode(message.entrantUser, writer.uint32(18).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(24).int64(message.operationTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemberEnterTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemberEnterTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entrantUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemberEnterTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      entrantUser: isSet(object.entrantUser) ? GroupMemberInfo.fromJSON(object.entrantUser) : undefined,
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
    };
  },

  toJSON(message: MemberEnterTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.entrantUser !== undefined) {
      obj.entrantUser = GroupMemberInfo.toJSON(message.entrantUser);
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemberEnterTips>, I>>(base?: I): MemberEnterTips {
    return MemberEnterTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemberEnterTips>, I>>(object: I): MemberEnterTips {
    const message = createBaseMemberEnterTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.entrantUser = (object.entrantUser !== undefined && object.entrantUser !== null)
      ? GroupMemberInfo.fromPartial(object.entrantUser)
      : undefined;
    message.operationTime = object.operationTime ?? 0;
    return message;
  },
};

function createBaseGroupDismissedTips(): GroupDismissedTips {
  return { group: undefined, opUser: undefined, operationTime: 0 };
}

export const GroupDismissedTips: MessageFns<GroupDismissedTips> = {
  encode(message: GroupDismissedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(24).int64(message.operationTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupDismissedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupDismissedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupDismissedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
    };
  },

  toJSON(message: GroupDismissedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupDismissedTips>, I>>(base?: I): GroupDismissedTips {
    return GroupDismissedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupDismissedTips>, I>>(object: I): GroupDismissedTips {
    const message = createBaseGroupDismissedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.operationTime = object.operationTime ?? 0;
    return message;
  },
};

function createBaseGroupMemberMutedTips(): GroupMemberMutedTips {
  return { group: undefined, opUser: undefined, operationTime: 0, mutedUser: undefined, mutedSeconds: 0 };
}

export const GroupMemberMutedTips: MessageFns<GroupMemberMutedTips> = {
  encode(message: GroupMemberMutedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(24).int64(message.operationTime);
    }
    if (message.mutedUser !== undefined) {
      GroupMemberInfo.encode(message.mutedUser, writer.uint32(34).fork()).join();
    }
    if (message.mutedSeconds !== 0) {
      writer.uint32(40).uint32(message.mutedSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMemberMutedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMemberMutedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mutedUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.mutedSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMemberMutedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
      mutedUser: isSet(object.mutedUser) ? GroupMemberInfo.fromJSON(object.mutedUser) : undefined,
      mutedSeconds: isSet(object.mutedSeconds) ? globalThis.Number(object.mutedSeconds) : 0,
    };
  },

  toJSON(message: GroupMemberMutedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    if (message.mutedUser !== undefined) {
      obj.mutedUser = GroupMemberInfo.toJSON(message.mutedUser);
    }
    if (message.mutedSeconds !== 0) {
      obj.mutedSeconds = Math.round(message.mutedSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMemberMutedTips>, I>>(base?: I): GroupMemberMutedTips {
    return GroupMemberMutedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMemberMutedTips>, I>>(object: I): GroupMemberMutedTips {
    const message = createBaseGroupMemberMutedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.operationTime = object.operationTime ?? 0;
    message.mutedUser = (object.mutedUser !== undefined && object.mutedUser !== null)
      ? GroupMemberInfo.fromPartial(object.mutedUser)
      : undefined;
    message.mutedSeconds = object.mutedSeconds ?? 0;
    return message;
  },
};

function createBaseGroupMemberCancelMutedTips(): GroupMemberCancelMutedTips {
  return { group: undefined, opUser: undefined, operationTime: 0, mutedUser: undefined };
}

export const GroupMemberCancelMutedTips: MessageFns<GroupMemberCancelMutedTips> = {
  encode(message: GroupMemberCancelMutedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(24).int64(message.operationTime);
    }
    if (message.mutedUser !== undefined) {
      GroupMemberInfo.encode(message.mutedUser, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMemberCancelMutedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMemberCancelMutedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mutedUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMemberCancelMutedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
      mutedUser: isSet(object.mutedUser) ? GroupMemberInfo.fromJSON(object.mutedUser) : undefined,
    };
  },

  toJSON(message: GroupMemberCancelMutedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    if (message.mutedUser !== undefined) {
      obj.mutedUser = GroupMemberInfo.toJSON(message.mutedUser);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMemberCancelMutedTips>, I>>(base?: I): GroupMemberCancelMutedTips {
    return GroupMemberCancelMutedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMemberCancelMutedTips>, I>>(object: I): GroupMemberCancelMutedTips {
    const message = createBaseGroupMemberCancelMutedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.operationTime = object.operationTime ?? 0;
    message.mutedUser = (object.mutedUser !== undefined && object.mutedUser !== null)
      ? GroupMemberInfo.fromPartial(object.mutedUser)
      : undefined;
    return message;
  },
};

function createBaseGroupMutedTips(): GroupMutedTips {
  return { group: undefined, opUser: undefined, operationTime: 0 };
}

export const GroupMutedTips: MessageFns<GroupMutedTips> = {
  encode(message: GroupMutedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(24).int64(message.operationTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMutedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMutedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMutedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
    };
  },

  toJSON(message: GroupMutedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMutedTips>, I>>(base?: I): GroupMutedTips {
    return GroupMutedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMutedTips>, I>>(object: I): GroupMutedTips {
    const message = createBaseGroupMutedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.operationTime = object.operationTime ?? 0;
    return message;
  },
};

function createBaseGroupCancelMutedTips(): GroupCancelMutedTips {
  return { group: undefined, opUser: undefined, operationTime: 0 };
}

export const GroupCancelMutedTips: MessageFns<GroupCancelMutedTips> = {
  encode(message: GroupCancelMutedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(24).int64(message.operationTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupCancelMutedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupCancelMutedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupCancelMutedTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
    };
  },

  toJSON(message: GroupCancelMutedTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupCancelMutedTips>, I>>(base?: I): GroupCancelMutedTips {
    return GroupCancelMutedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupCancelMutedTips>, I>>(object: I): GroupCancelMutedTips {
    const message = createBaseGroupCancelMutedTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.operationTime = object.operationTime ?? 0;
    return message;
  },
};

function createBaseGroupMemberInfoSetTips(): GroupMemberInfoSetTips {
  return { group: undefined, opUser: undefined, operationTime: 0, changedUser: undefined };
}

export const GroupMemberInfoSetTips: MessageFns<GroupMemberInfoSetTips> = {
  encode(message: GroupMemberInfoSetTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    if (message.opUser !== undefined) {
      GroupMemberInfo.encode(message.opUser, writer.uint32(18).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(24).int64(message.operationTime);
    }
    if (message.changedUser !== undefined) {
      GroupMemberInfo.encode(message.changedUser, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMemberInfoSetTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMemberInfoSetTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.opUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.changedUser = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMemberInfoSetTips {
    return {
      group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined,
      opUser: isSet(object.opUser) ? GroupMemberInfo.fromJSON(object.opUser) : undefined,
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
      changedUser: isSet(object.changedUser) ? GroupMemberInfo.fromJSON(object.changedUser) : undefined,
    };
  },

  toJSON(message: GroupMemberInfoSetTips): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    if (message.opUser !== undefined) {
      obj.opUser = GroupMemberInfo.toJSON(message.opUser);
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    if (message.changedUser !== undefined) {
      obj.changedUser = GroupMemberInfo.toJSON(message.changedUser);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMemberInfoSetTips>, I>>(base?: I): GroupMemberInfoSetTips {
    return GroupMemberInfoSetTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMemberInfoSetTips>, I>>(object: I): GroupMemberInfoSetTips {
    const message = createBaseGroupMemberInfoSetTips();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? GroupMemberInfo.fromPartial(object.opUser)
      : undefined;
    message.operationTime = object.operationTime ?? 0;
    message.changedUser = (object.changedUser !== undefined && object.changedUser !== null)
      ? GroupMemberInfo.fromPartial(object.changedUser)
      : undefined;
    return message;
  },
};

function createBaseFriendApplication(): FriendApplication {
  return { addTime: 0, addSource: "", addWording: "" };
}

export const FriendApplication: MessageFns<FriendApplication> = {
  encode(message: FriendApplication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addTime !== 0) {
      writer.uint32(8).int64(message.addTime);
    }
    if (message.addSource !== "") {
      writer.uint32(18).string(message.addSource);
    }
    if (message.addWording !== "") {
      writer.uint32(26).string(message.addWording);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendApplication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendApplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.addTime = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addSource = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addWording = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendApplication {
    return {
      addTime: isSet(object.addTime) ? globalThis.Number(object.addTime) : 0,
      addSource: isSet(object.addSource) ? globalThis.String(object.addSource) : "",
      addWording: isSet(object.addWording) ? globalThis.String(object.addWording) : "",
    };
  },

  toJSON(message: FriendApplication): unknown {
    const obj: any = {};
    if (message.addTime !== 0) {
      obj.addTime = Math.round(message.addTime);
    }
    if (message.addSource !== "") {
      obj.addSource = message.addSource;
    }
    if (message.addWording !== "") {
      obj.addWording = message.addWording;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendApplication>, I>>(base?: I): FriendApplication {
    return FriendApplication.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendApplication>, I>>(object: I): FriendApplication {
    const message = createBaseFriendApplication();
    message.addTime = object.addTime ?? 0;
    message.addSource = object.addSource ?? "";
    message.addWording = object.addWording ?? "";
    return message;
  },
};

function createBaseFromToUserID(): FromToUserID {
  return { fromUserID: "", toUserID: "" };
}

export const FromToUserID: MessageFns<FromToUserID> = {
  encode(message: FromToUserID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserID !== "") {
      writer.uint32(10).string(message.fromUserID);
    }
    if (message.toUserID !== "") {
      writer.uint32(18).string(message.toUserID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FromToUserID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFromToUserID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toUserID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FromToUserID {
    return {
      fromUserID: isSet(object.fromUserID) ? globalThis.String(object.fromUserID) : "",
      toUserID: isSet(object.toUserID) ? globalThis.String(object.toUserID) : "",
    };
  },

  toJSON(message: FromToUserID): unknown {
    const obj: any = {};
    if (message.fromUserID !== "") {
      obj.fromUserID = message.fromUserID;
    }
    if (message.toUserID !== "") {
      obj.toUserID = message.toUserID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FromToUserID>, I>>(base?: I): FromToUserID {
    return FromToUserID.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FromToUserID>, I>>(object: I): FromToUserID {
    const message = createBaseFromToUserID();
    message.fromUserID = object.fromUserID ?? "";
    message.toUserID = object.toUserID ?? "";
    return message;
  },
};

function createBaseFriendApplicationTips(): FriendApplicationTips {
  return { fromToUserID: undefined };
}

export const FriendApplicationTips: MessageFns<FriendApplicationTips> = {
  encode(message: FriendApplicationTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromToUserID !== undefined) {
      FromToUserID.encode(message.fromToUserID, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendApplicationTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendApplicationTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromToUserID = FromToUserID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendApplicationTips {
    return { fromToUserID: isSet(object.fromToUserID) ? FromToUserID.fromJSON(object.fromToUserID) : undefined };
  },

  toJSON(message: FriendApplicationTips): unknown {
    const obj: any = {};
    if (message.fromToUserID !== undefined) {
      obj.fromToUserID = FromToUserID.toJSON(message.fromToUserID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendApplicationTips>, I>>(base?: I): FriendApplicationTips {
    return FriendApplicationTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendApplicationTips>, I>>(object: I): FriendApplicationTips {
    const message = createBaseFriendApplicationTips();
    message.fromToUserID = (object.fromToUserID !== undefined && object.fromToUserID !== null)
      ? FromToUserID.fromPartial(object.fromToUserID)
      : undefined;
    return message;
  },
};

function createBaseFriendApplicationApprovedTips(): FriendApplicationApprovedTips {
  return { fromToUserID: undefined };
}

export const FriendApplicationApprovedTips: MessageFns<FriendApplicationApprovedTips> = {
  encode(message: FriendApplicationApprovedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromToUserID !== undefined) {
      FromToUserID.encode(message.fromToUserID, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendApplicationApprovedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendApplicationApprovedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromToUserID = FromToUserID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendApplicationApprovedTips {
    return { fromToUserID: isSet(object.fromToUserID) ? FromToUserID.fromJSON(object.fromToUserID) : undefined };
  },

  toJSON(message: FriendApplicationApprovedTips): unknown {
    const obj: any = {};
    if (message.fromToUserID !== undefined) {
      obj.fromToUserID = FromToUserID.toJSON(message.fromToUserID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendApplicationApprovedTips>, I>>(base?: I): FriendApplicationApprovedTips {
    return FriendApplicationApprovedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendApplicationApprovedTips>, I>>(
    object: I,
  ): FriendApplicationApprovedTips {
    const message = createBaseFriendApplicationApprovedTips();
    message.fromToUserID = (object.fromToUserID !== undefined && object.fromToUserID !== null)
      ? FromToUserID.fromPartial(object.fromToUserID)
      : undefined;
    return message;
  },
};

function createBaseFriendApplicationRejectedTips(): FriendApplicationRejectedTips {
  return { fromToUserID: undefined, handleMsg: "" };
}

export const FriendApplicationRejectedTips: MessageFns<FriendApplicationRejectedTips> = {
  encode(message: FriendApplicationRejectedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromToUserID !== undefined) {
      FromToUserID.encode(message.fromToUserID, writer.uint32(10).fork()).join();
    }
    if (message.handleMsg !== "") {
      writer.uint32(18).string(message.handleMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendApplicationRejectedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendApplicationRejectedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromToUserID = FromToUserID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.handleMsg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendApplicationRejectedTips {
    return {
      fromToUserID: isSet(object.fromToUserID) ? FromToUserID.fromJSON(object.fromToUserID) : undefined,
      handleMsg: isSet(object.handleMsg) ? globalThis.String(object.handleMsg) : "",
    };
  },

  toJSON(message: FriendApplicationRejectedTips): unknown {
    const obj: any = {};
    if (message.fromToUserID !== undefined) {
      obj.fromToUserID = FromToUserID.toJSON(message.fromToUserID);
    }
    if (message.handleMsg !== "") {
      obj.handleMsg = message.handleMsg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendApplicationRejectedTips>, I>>(base?: I): FriendApplicationRejectedTips {
    return FriendApplicationRejectedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendApplicationRejectedTips>, I>>(
    object: I,
  ): FriendApplicationRejectedTips {
    const message = createBaseFriendApplicationRejectedTips();
    message.fromToUserID = (object.fromToUserID !== undefined && object.fromToUserID !== null)
      ? FromToUserID.fromPartial(object.fromToUserID)
      : undefined;
    message.handleMsg = object.handleMsg ?? "";
    return message;
  },
};

function createBaseFriendAddedTips(): FriendAddedTips {
  return { friend: undefined, operationTime: 0, opUser: undefined };
}

export const FriendAddedTips: MessageFns<FriendAddedTips> = {
  encode(message: FriendAddedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.friend !== undefined) {
      FriendInfo.encode(message.friend, writer.uint32(10).fork()).join();
    }
    if (message.operationTime !== 0) {
      writer.uint32(16).int64(message.operationTime);
    }
    if (message.opUser !== undefined) {
      UserInfo.encode(message.opUser, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendAddedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendAddedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.friend = FriendInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operationTime = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.opUser = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendAddedTips {
    return {
      friend: isSet(object.friend) ? FriendInfo.fromJSON(object.friend) : undefined,
      operationTime: isSet(object.operationTime) ? globalThis.Number(object.operationTime) : 0,
      opUser: isSet(object.opUser) ? UserInfo.fromJSON(object.opUser) : undefined,
    };
  },

  toJSON(message: FriendAddedTips): unknown {
    const obj: any = {};
    if (message.friend !== undefined) {
      obj.friend = FriendInfo.toJSON(message.friend);
    }
    if (message.operationTime !== 0) {
      obj.operationTime = Math.round(message.operationTime);
    }
    if (message.opUser !== undefined) {
      obj.opUser = UserInfo.toJSON(message.opUser);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendAddedTips>, I>>(base?: I): FriendAddedTips {
    return FriendAddedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendAddedTips>, I>>(object: I): FriendAddedTips {
    const message = createBaseFriendAddedTips();
    message.friend = (object.friend !== undefined && object.friend !== null)
      ? FriendInfo.fromPartial(object.friend)
      : undefined;
    message.operationTime = object.operationTime ?? 0;
    message.opUser = (object.opUser !== undefined && object.opUser !== null)
      ? UserInfo.fromPartial(object.opUser)
      : undefined;
    return message;
  },
};

function createBaseFriendDeletedTips(): FriendDeletedTips {
  return { fromToUserID: undefined };
}

export const FriendDeletedTips: MessageFns<FriendDeletedTips> = {
  encode(message: FriendDeletedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromToUserID !== undefined) {
      FromToUserID.encode(message.fromToUserID, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendDeletedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendDeletedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromToUserID = FromToUserID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendDeletedTips {
    return { fromToUserID: isSet(object.fromToUserID) ? FromToUserID.fromJSON(object.fromToUserID) : undefined };
  },

  toJSON(message: FriendDeletedTips): unknown {
    const obj: any = {};
    if (message.fromToUserID !== undefined) {
      obj.fromToUserID = FromToUserID.toJSON(message.fromToUserID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendDeletedTips>, I>>(base?: I): FriendDeletedTips {
    return FriendDeletedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendDeletedTips>, I>>(object: I): FriendDeletedTips {
    const message = createBaseFriendDeletedTips();
    message.fromToUserID = (object.fromToUserID !== undefined && object.fromToUserID !== null)
      ? FromToUserID.fromPartial(object.fromToUserID)
      : undefined;
    return message;
  },
};

function createBaseBlackAddedTips(): BlackAddedTips {
  return { fromToUserID: undefined };
}

export const BlackAddedTips: MessageFns<BlackAddedTips> = {
  encode(message: BlackAddedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromToUserID !== undefined) {
      FromToUserID.encode(message.fromToUserID, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlackAddedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlackAddedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromToUserID = FromToUserID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlackAddedTips {
    return { fromToUserID: isSet(object.fromToUserID) ? FromToUserID.fromJSON(object.fromToUserID) : undefined };
  },

  toJSON(message: BlackAddedTips): unknown {
    const obj: any = {};
    if (message.fromToUserID !== undefined) {
      obj.fromToUserID = FromToUserID.toJSON(message.fromToUserID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlackAddedTips>, I>>(base?: I): BlackAddedTips {
    return BlackAddedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlackAddedTips>, I>>(object: I): BlackAddedTips {
    const message = createBaseBlackAddedTips();
    message.fromToUserID = (object.fromToUserID !== undefined && object.fromToUserID !== null)
      ? FromToUserID.fromPartial(object.fromToUserID)
      : undefined;
    return message;
  },
};

function createBaseBlackDeletedTips(): BlackDeletedTips {
  return { fromToUserID: undefined };
}

export const BlackDeletedTips: MessageFns<BlackDeletedTips> = {
  encode(message: BlackDeletedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromToUserID !== undefined) {
      FromToUserID.encode(message.fromToUserID, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlackDeletedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlackDeletedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromToUserID = FromToUserID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlackDeletedTips {
    return { fromToUserID: isSet(object.fromToUserID) ? FromToUserID.fromJSON(object.fromToUserID) : undefined };
  },

  toJSON(message: BlackDeletedTips): unknown {
    const obj: any = {};
    if (message.fromToUserID !== undefined) {
      obj.fromToUserID = FromToUserID.toJSON(message.fromToUserID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlackDeletedTips>, I>>(base?: I): BlackDeletedTips {
    return BlackDeletedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlackDeletedTips>, I>>(object: I): BlackDeletedTips {
    const message = createBaseBlackDeletedTips();
    message.fromToUserID = (object.fromToUserID !== undefined && object.fromToUserID !== null)
      ? FromToUserID.fromPartial(object.fromToUserID)
      : undefined;
    return message;
  },
};

function createBaseFriendInfoChangedTips(): FriendInfoChangedTips {
  return { fromToUserID: undefined };
}

export const FriendInfoChangedTips: MessageFns<FriendInfoChangedTips> = {
  encode(message: FriendInfoChangedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromToUserID !== undefined) {
      FromToUserID.encode(message.fromToUserID, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendInfoChangedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendInfoChangedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromToUserID = FromToUserID.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendInfoChangedTips {
    return { fromToUserID: isSet(object.fromToUserID) ? FromToUserID.fromJSON(object.fromToUserID) : undefined };
  },

  toJSON(message: FriendInfoChangedTips): unknown {
    const obj: any = {};
    if (message.fromToUserID !== undefined) {
      obj.fromToUserID = FromToUserID.toJSON(message.fromToUserID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendInfoChangedTips>, I>>(base?: I): FriendInfoChangedTips {
    return FriendInfoChangedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendInfoChangedTips>, I>>(object: I): FriendInfoChangedTips {
    const message = createBaseFriendInfoChangedTips();
    message.fromToUserID = (object.fromToUserID !== undefined && object.fromToUserID !== null)
      ? FromToUserID.fromPartial(object.fromToUserID)
      : undefined;
    return message;
  },
};

function createBaseUserInfoUpdatedTips(): UserInfoUpdatedTips {
  return { userID: "" };
}

export const UserInfoUpdatedTips: MessageFns<UserInfoUpdatedTips> = {
  encode(message: UserInfoUpdatedTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfoUpdatedTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfoUpdatedTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfoUpdatedTips {
    return { userID: isSet(object.userID) ? globalThis.String(object.userID) : "" };
  },

  toJSON(message: UserInfoUpdatedTips): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfoUpdatedTips>, I>>(base?: I): UserInfoUpdatedTips {
    return UserInfoUpdatedTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfoUpdatedTips>, I>>(object: I): UserInfoUpdatedTips {
    const message = createBaseUserInfoUpdatedTips();
    message.userID = object.userID ?? "";
    return message;
  },
};

function createBaseUserStatusChangeTips(): UserStatusChangeTips {
  return { fromUserID: "", toUserID: "", status: 0, platformID: 0 };
}

export const UserStatusChangeTips: MessageFns<UserStatusChangeTips> = {
  encode(message: UserStatusChangeTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserID !== "") {
      writer.uint32(10).string(message.fromUserID);
    }
    if (message.toUserID !== "") {
      writer.uint32(18).string(message.toUserID);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.platformID !== 0) {
      writer.uint32(32).int32(message.platformID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserStatusChangeTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStatusChangeTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toUserID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.platformID = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserStatusChangeTips {
    return {
      fromUserID: isSet(object.fromUserID) ? globalThis.String(object.fromUserID) : "",
      toUserID: isSet(object.toUserID) ? globalThis.String(object.toUserID) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      platformID: isSet(object.platformID) ? globalThis.Number(object.platformID) : 0,
    };
  },

  toJSON(message: UserStatusChangeTips): unknown {
    const obj: any = {};
    if (message.fromUserID !== "") {
      obj.fromUserID = message.fromUserID;
    }
    if (message.toUserID !== "") {
      obj.toUserID = message.toUserID;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.platformID !== 0) {
      obj.platformID = Math.round(message.platformID);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStatusChangeTips>, I>>(base?: I): UserStatusChangeTips {
    return UserStatusChangeTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserStatusChangeTips>, I>>(object: I): UserStatusChangeTips {
    const message = createBaseUserStatusChangeTips();
    message.fromUserID = object.fromUserID ?? "";
    message.toUserID = object.toUserID ?? "";
    message.status = object.status ?? 0;
    message.platformID = object.platformID ?? 0;
    return message;
  },
};

function createBaseUserCommandAddTips(): UserCommandAddTips {
  return { fromUserID: "", toUserID: "" };
}

export const UserCommandAddTips: MessageFns<UserCommandAddTips> = {
  encode(message: UserCommandAddTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserID !== "") {
      writer.uint32(10).string(message.fromUserID);
    }
    if (message.toUserID !== "") {
      writer.uint32(18).string(message.toUserID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserCommandAddTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCommandAddTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toUserID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCommandAddTips {
    return {
      fromUserID: isSet(object.fromUserID) ? globalThis.String(object.fromUserID) : "",
      toUserID: isSet(object.toUserID) ? globalThis.String(object.toUserID) : "",
    };
  },

  toJSON(message: UserCommandAddTips): unknown {
    const obj: any = {};
    if (message.fromUserID !== "") {
      obj.fromUserID = message.fromUserID;
    }
    if (message.toUserID !== "") {
      obj.toUserID = message.toUserID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserCommandAddTips>, I>>(base?: I): UserCommandAddTips {
    return UserCommandAddTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserCommandAddTips>, I>>(object: I): UserCommandAddTips {
    const message = createBaseUserCommandAddTips();
    message.fromUserID = object.fromUserID ?? "";
    message.toUserID = object.toUserID ?? "";
    return message;
  },
};

function createBaseUserCommandUpdateTips(): UserCommandUpdateTips {
  return { fromUserID: "", toUserID: "" };
}

export const UserCommandUpdateTips: MessageFns<UserCommandUpdateTips> = {
  encode(message: UserCommandUpdateTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserID !== "") {
      writer.uint32(10).string(message.fromUserID);
    }
    if (message.toUserID !== "") {
      writer.uint32(18).string(message.toUserID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserCommandUpdateTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCommandUpdateTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toUserID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCommandUpdateTips {
    return {
      fromUserID: isSet(object.fromUserID) ? globalThis.String(object.fromUserID) : "",
      toUserID: isSet(object.toUserID) ? globalThis.String(object.toUserID) : "",
    };
  },

  toJSON(message: UserCommandUpdateTips): unknown {
    const obj: any = {};
    if (message.fromUserID !== "") {
      obj.fromUserID = message.fromUserID;
    }
    if (message.toUserID !== "") {
      obj.toUserID = message.toUserID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserCommandUpdateTips>, I>>(base?: I): UserCommandUpdateTips {
    return UserCommandUpdateTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserCommandUpdateTips>, I>>(object: I): UserCommandUpdateTips {
    const message = createBaseUserCommandUpdateTips();
    message.fromUserID = object.fromUserID ?? "";
    message.toUserID = object.toUserID ?? "";
    return message;
  },
};

function createBaseUserCommandDeleteTips(): UserCommandDeleteTips {
  return { fromUserID: "", toUserID: "" };
}

export const UserCommandDeleteTips: MessageFns<UserCommandDeleteTips> = {
  encode(message: UserCommandDeleteTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromUserID !== "") {
      writer.uint32(10).string(message.fromUserID);
    }
    if (message.toUserID !== "") {
      writer.uint32(18).string(message.toUserID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserCommandDeleteTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCommandDeleteTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toUserID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCommandDeleteTips {
    return {
      fromUserID: isSet(object.fromUserID) ? globalThis.String(object.fromUserID) : "",
      toUserID: isSet(object.toUserID) ? globalThis.String(object.toUserID) : "",
    };
  },

  toJSON(message: UserCommandDeleteTips): unknown {
    const obj: any = {};
    if (message.fromUserID !== "") {
      obj.fromUserID = message.fromUserID;
    }
    if (message.toUserID !== "") {
      obj.toUserID = message.toUserID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserCommandDeleteTips>, I>>(base?: I): UserCommandDeleteTips {
    return UserCommandDeleteTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserCommandDeleteTips>, I>>(object: I): UserCommandDeleteTips {
    const message = createBaseUserCommandDeleteTips();
    message.fromUserID = object.fromUserID ?? "";
    message.toUserID = object.toUserID ?? "";
    return message;
  },
};

function createBaseConversationUpdateTips(): ConversationUpdateTips {
  return { userID: "", conversationIDList: [] };
}

export const ConversationUpdateTips: MessageFns<ConversationUpdateTips> = {
  encode(message: ConversationUpdateTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    for (const v of message.conversationIDList) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationUpdateTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationUpdateTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationIDList.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationUpdateTips {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      conversationIDList: globalThis.Array.isArray(object?.conversationIDList)
        ? object.conversationIDList.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ConversationUpdateTips): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.conversationIDList?.length) {
      obj.conversationIDList = message.conversationIDList;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationUpdateTips>, I>>(base?: I): ConversationUpdateTips {
    return ConversationUpdateTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationUpdateTips>, I>>(object: I): ConversationUpdateTips {
    const message = createBaseConversationUpdateTips();
    message.userID = object.userID ?? "";
    message.conversationIDList = object.conversationIDList?.map((e) => e) || [];
    return message;
  },
};

function createBaseConversationSetPrivateTips(): ConversationSetPrivateTips {
  return { recvID: "", sendID: "", isPrivate: false, conversationID: "" };
}

export const ConversationSetPrivateTips: MessageFns<ConversationSetPrivateTips> = {
  encode(message: ConversationSetPrivateTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recvID !== "") {
      writer.uint32(10).string(message.recvID);
    }
    if (message.sendID !== "") {
      writer.uint32(18).string(message.sendID);
    }
    if (message.isPrivate !== false) {
      writer.uint32(24).bool(message.isPrivate);
    }
    if (message.conversationID !== "") {
      writer.uint32(34).string(message.conversationID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationSetPrivateTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationSetPrivateTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recvID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sendID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isPrivate = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationSetPrivateTips {
    return {
      recvID: isSet(object.recvID) ? globalThis.String(object.recvID) : "",
      sendID: isSet(object.sendID) ? globalThis.String(object.sendID) : "",
      isPrivate: isSet(object.isPrivate) ? globalThis.Boolean(object.isPrivate) : false,
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
    };
  },

  toJSON(message: ConversationSetPrivateTips): unknown {
    const obj: any = {};
    if (message.recvID !== "") {
      obj.recvID = message.recvID;
    }
    if (message.sendID !== "") {
      obj.sendID = message.sendID;
    }
    if (message.isPrivate !== false) {
      obj.isPrivate = message.isPrivate;
    }
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationSetPrivateTips>, I>>(base?: I): ConversationSetPrivateTips {
    return ConversationSetPrivateTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationSetPrivateTips>, I>>(object: I): ConversationSetPrivateTips {
    const message = createBaseConversationSetPrivateTips();
    message.recvID = object.recvID ?? "";
    message.sendID = object.sendID ?? "";
    message.isPrivate = object.isPrivate ?? false;
    message.conversationID = object.conversationID ?? "";
    return message;
  },
};

function createBaseConversationHasReadTips(): ConversationHasReadTips {
  return { userID: "", conversationID: "", hasReadSeq: 0, unreadCountTime: 0 };
}

export const ConversationHasReadTips: MessageFns<ConversationHasReadTips> = {
  encode(message: ConversationHasReadTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    if (message.conversationID !== "") {
      writer.uint32(18).string(message.conversationID);
    }
    if (message.hasReadSeq !== 0) {
      writer.uint32(24).int64(message.hasReadSeq);
    }
    if (message.unreadCountTime !== 0) {
      writer.uint32(32).int64(message.unreadCountTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationHasReadTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationHasReadTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasReadSeq = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.unreadCountTime = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationHasReadTips {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      hasReadSeq: isSet(object.hasReadSeq) ? globalThis.Number(object.hasReadSeq) : 0,
      unreadCountTime: isSet(object.unreadCountTime) ? globalThis.Number(object.unreadCountTime) : 0,
    };
  },

  toJSON(message: ConversationHasReadTips): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.hasReadSeq !== 0) {
      obj.hasReadSeq = Math.round(message.hasReadSeq);
    }
    if (message.unreadCountTime !== 0) {
      obj.unreadCountTime = Math.round(message.unreadCountTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationHasReadTips>, I>>(base?: I): ConversationHasReadTips {
    return ConversationHasReadTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationHasReadTips>, I>>(object: I): ConversationHasReadTips {
    const message = createBaseConversationHasReadTips();
    message.userID = object.userID ?? "";
    message.conversationID = object.conversationID ?? "";
    message.hasReadSeq = object.hasReadSeq ?? 0;
    message.unreadCountTime = object.unreadCountTime ?? 0;
    return message;
  },
};

function createBaseDeleteMessageTips(): DeleteMessageTips {
  return { opUserID: "", userID: "", seqs: [] };
}

export const DeleteMessageTips: MessageFns<DeleteMessageTips> = {
  encode(message: DeleteMessageTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.opUserID !== "") {
      writer.uint32(10).string(message.opUserID);
    }
    if (message.userID !== "") {
      writer.uint32(18).string(message.userID);
    }
    writer.uint32(26).fork();
    for (const v of message.seqs) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.opUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.seqs.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.seqs.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMessageTips {
    return {
      opUserID: isSet(object.opUserID) ? globalThis.String(object.opUserID) : "",
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      seqs: globalThis.Array.isArray(object?.seqs) ? object.seqs.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: DeleteMessageTips): unknown {
    const obj: any = {};
    if (message.opUserID !== "") {
      obj.opUserID = message.opUserID;
    }
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.seqs?.length) {
      obj.seqs = message.seqs.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageTips>, I>>(base?: I): DeleteMessageTips {
    return DeleteMessageTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageTips>, I>>(object: I): DeleteMessageTips {
    const message = createBaseDeleteMessageTips();
    message.opUserID = object.opUserID ?? "";
    message.userID = object.userID ?? "";
    message.seqs = object.seqs?.map((e) => e) || [];
    return message;
  },
};

function createBaseRevokeMsgTips(): RevokeMsgTips {
  return {
    revokerUserID: "",
    clientMsgID: "",
    revokeTime: 0,
    sesstionType: 0,
    seq: 0,
    conversationID: "",
    isAdminRevoke: false,
  };
}

export const RevokeMsgTips: MessageFns<RevokeMsgTips> = {
  encode(message: RevokeMsgTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revokerUserID !== "") {
      writer.uint32(10).string(message.revokerUserID);
    }
    if (message.clientMsgID !== "") {
      writer.uint32(18).string(message.clientMsgID);
    }
    if (message.revokeTime !== 0) {
      writer.uint32(24).int64(message.revokeTime);
    }
    if (message.sesstionType !== 0) {
      writer.uint32(40).int32(message.sesstionType);
    }
    if (message.seq !== 0) {
      writer.uint32(48).int64(message.seq);
    }
    if (message.conversationID !== "") {
      writer.uint32(58).string(message.conversationID);
    }
    if (message.isAdminRevoke !== false) {
      writer.uint32(64).bool(message.isAdminRevoke);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeMsgTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeMsgTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.revokerUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientMsgID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.revokeTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sesstionType = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.seq = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isAdminRevoke = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeMsgTips {
    return {
      revokerUserID: isSet(object.revokerUserID) ? globalThis.String(object.revokerUserID) : "",
      clientMsgID: isSet(object.clientMsgID) ? globalThis.String(object.clientMsgID) : "",
      revokeTime: isSet(object.revokeTime) ? globalThis.Number(object.revokeTime) : 0,
      sesstionType: isSet(object.sesstionType) ? globalThis.Number(object.sesstionType) : 0,
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      isAdminRevoke: isSet(object.isAdminRevoke) ? globalThis.Boolean(object.isAdminRevoke) : false,
    };
  },

  toJSON(message: RevokeMsgTips): unknown {
    const obj: any = {};
    if (message.revokerUserID !== "") {
      obj.revokerUserID = message.revokerUserID;
    }
    if (message.clientMsgID !== "") {
      obj.clientMsgID = message.clientMsgID;
    }
    if (message.revokeTime !== 0) {
      obj.revokeTime = Math.round(message.revokeTime);
    }
    if (message.sesstionType !== 0) {
      obj.sesstionType = Math.round(message.sesstionType);
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.isAdminRevoke !== false) {
      obj.isAdminRevoke = message.isAdminRevoke;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeMsgTips>, I>>(base?: I): RevokeMsgTips {
    return RevokeMsgTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeMsgTips>, I>>(object: I): RevokeMsgTips {
    const message = createBaseRevokeMsgTips();
    message.revokerUserID = object.revokerUserID ?? "";
    message.clientMsgID = object.clientMsgID ?? "";
    message.revokeTime = object.revokeTime ?? 0;
    message.sesstionType = object.sesstionType ?? 0;
    message.seq = object.seq ?? 0;
    message.conversationID = object.conversationID ?? "";
    message.isAdminRevoke = object.isAdminRevoke ?? false;
    return message;
  },
};

function createBaseMessageRevokedContent(): MessageRevokedContent {
  return {
    revokerID: "",
    revokerRole: 0,
    clientMsgID: "",
    revokerNickname: "",
    revokeTime: 0,
    sourceMessageSendTime: 0,
    sourceMessageSendID: "",
    sourceMessageSenderNickname: "",
    sessionType: 0,
    seq: 0,
    ex: "",
  };
}

export const MessageRevokedContent: MessageFns<MessageRevokedContent> = {
  encode(message: MessageRevokedContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revokerID !== "") {
      writer.uint32(10).string(message.revokerID);
    }
    if (message.revokerRole !== 0) {
      writer.uint32(16).int32(message.revokerRole);
    }
    if (message.clientMsgID !== "") {
      writer.uint32(26).string(message.clientMsgID);
    }
    if (message.revokerNickname !== "") {
      writer.uint32(34).string(message.revokerNickname);
    }
    if (message.revokeTime !== 0) {
      writer.uint32(40).int64(message.revokeTime);
    }
    if (message.sourceMessageSendTime !== 0) {
      writer.uint32(48).int64(message.sourceMessageSendTime);
    }
    if (message.sourceMessageSendID !== "") {
      writer.uint32(58).string(message.sourceMessageSendID);
    }
    if (message.sourceMessageSenderNickname !== "") {
      writer.uint32(66).string(message.sourceMessageSenderNickname);
    }
    if (message.sessionType !== 0) {
      writer.uint32(80).int32(message.sessionType);
    }
    if (message.seq !== 0) {
      writer.uint32(88).int64(message.seq);
    }
    if (message.ex !== "") {
      writer.uint32(98).string(message.ex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageRevokedContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageRevokedContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.revokerID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.revokerRole = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientMsgID = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.revokerNickname = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.revokeTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sourceMessageSendTime = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sourceMessageSendID = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sourceMessageSenderNickname = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sessionType = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.seq = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageRevokedContent {
    return {
      revokerID: isSet(object.revokerID) ? globalThis.String(object.revokerID) : "",
      revokerRole: isSet(object.revokerRole) ? globalThis.Number(object.revokerRole) : 0,
      clientMsgID: isSet(object.clientMsgID) ? globalThis.String(object.clientMsgID) : "",
      revokerNickname: isSet(object.revokerNickname) ? globalThis.String(object.revokerNickname) : "",
      revokeTime: isSet(object.revokeTime) ? globalThis.Number(object.revokeTime) : 0,
      sourceMessageSendTime: isSet(object.sourceMessageSendTime) ? globalThis.Number(object.sourceMessageSendTime) : 0,
      sourceMessageSendID: isSet(object.sourceMessageSendID) ? globalThis.String(object.sourceMessageSendID) : "",
      sourceMessageSenderNickname: isSet(object.sourceMessageSenderNickname)
        ? globalThis.String(object.sourceMessageSenderNickname)
        : "",
      sessionType: isSet(object.sessionType) ? globalThis.Number(object.sessionType) : 0,
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
    };
  },

  toJSON(message: MessageRevokedContent): unknown {
    const obj: any = {};
    if (message.revokerID !== "") {
      obj.revokerID = message.revokerID;
    }
    if (message.revokerRole !== 0) {
      obj.revokerRole = Math.round(message.revokerRole);
    }
    if (message.clientMsgID !== "") {
      obj.clientMsgID = message.clientMsgID;
    }
    if (message.revokerNickname !== "") {
      obj.revokerNickname = message.revokerNickname;
    }
    if (message.revokeTime !== 0) {
      obj.revokeTime = Math.round(message.revokeTime);
    }
    if (message.sourceMessageSendTime !== 0) {
      obj.sourceMessageSendTime = Math.round(message.sourceMessageSendTime);
    }
    if (message.sourceMessageSendID !== "") {
      obj.sourceMessageSendID = message.sourceMessageSendID;
    }
    if (message.sourceMessageSenderNickname !== "") {
      obj.sourceMessageSenderNickname = message.sourceMessageSenderNickname;
    }
    if (message.sessionType !== 0) {
      obj.sessionType = Math.round(message.sessionType);
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageRevokedContent>, I>>(base?: I): MessageRevokedContent {
    return MessageRevokedContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageRevokedContent>, I>>(object: I): MessageRevokedContent {
    const message = createBaseMessageRevokedContent();
    message.revokerID = object.revokerID ?? "";
    message.revokerRole = object.revokerRole ?? 0;
    message.clientMsgID = object.clientMsgID ?? "";
    message.revokerNickname = object.revokerNickname ?? "";
    message.revokeTime = object.revokeTime ?? 0;
    message.sourceMessageSendTime = object.sourceMessageSendTime ?? 0;
    message.sourceMessageSendID = object.sourceMessageSendID ?? "";
    message.sourceMessageSenderNickname = object.sourceMessageSenderNickname ?? "";
    message.sessionType = object.sessionType ?? 0;
    message.seq = object.seq ?? 0;
    message.ex = object.ex ?? "";
    return message;
  },
};

function createBaseClearConversationTips(): ClearConversationTips {
  return { userID: "", conversationIDs: [] };
}

export const ClearConversationTips: MessageFns<ClearConversationTips> = {
  encode(message: ClearConversationTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    for (const v of message.conversationIDs) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearConversationTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearConversationTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationIDs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClearConversationTips {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      conversationIDs: globalThis.Array.isArray(object?.conversationIDs)
        ? object.conversationIDs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ClearConversationTips): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.conversationIDs?.length) {
      obj.conversationIDs = message.conversationIDs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearConversationTips>, I>>(base?: I): ClearConversationTips {
    return ClearConversationTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearConversationTips>, I>>(object: I): ClearConversationTips {
    const message = createBaseClearConversationTips();
    message.userID = object.userID ?? "";
    message.conversationIDs = object.conversationIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteMsgsTips(): DeleteMsgsTips {
  return { userID: "", conversationID: "", seqs: [] };
}

export const DeleteMsgsTips: MessageFns<DeleteMsgsTips> = {
  encode(message: DeleteMsgsTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    if (message.conversationID !== "") {
      writer.uint32(18).string(message.conversationID);
    }
    writer.uint32(26).fork();
    for (const v of message.seqs) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMsgsTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMsgsTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.seqs.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.seqs.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMsgsTips {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      seqs: globalThis.Array.isArray(object?.seqs) ? object.seqs.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: DeleteMsgsTips): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.seqs?.length) {
      obj.seqs = message.seqs.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMsgsTips>, I>>(base?: I): DeleteMsgsTips {
    return DeleteMsgsTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMsgsTips>, I>>(object: I): DeleteMsgsTips {
    const message = createBaseDeleteMsgsTips();
    message.userID = object.userID ?? "";
    message.conversationID = object.conversationID ?? "";
    message.seqs = object.seqs?.map((e) => e) || [];
    return message;
  },
};

function createBaseMarkAsReadTips(): MarkAsReadTips {
  return { markAsReadUserID: "", conversationID: "", seqs: [], hasReadSeq: 0 };
}

export const MarkAsReadTips: MessageFns<MarkAsReadTips> = {
  encode(message: MarkAsReadTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.markAsReadUserID !== "") {
      writer.uint32(10).string(message.markAsReadUserID);
    }
    if (message.conversationID !== "") {
      writer.uint32(18).string(message.conversationID);
    }
    writer.uint32(26).fork();
    for (const v of message.seqs) {
      writer.int64(v);
    }
    writer.join();
    if (message.hasReadSeq !== 0) {
      writer.uint32(32).int64(message.hasReadSeq);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkAsReadTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkAsReadTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markAsReadUserID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.seqs.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.seqs.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hasReadSeq = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkAsReadTips {
    return {
      markAsReadUserID: isSet(object.markAsReadUserID) ? globalThis.String(object.markAsReadUserID) : "",
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      seqs: globalThis.Array.isArray(object?.seqs) ? object.seqs.map((e: any) => globalThis.Number(e)) : [],
      hasReadSeq: isSet(object.hasReadSeq) ? globalThis.Number(object.hasReadSeq) : 0,
    };
  },

  toJSON(message: MarkAsReadTips): unknown {
    const obj: any = {};
    if (message.markAsReadUserID !== "") {
      obj.markAsReadUserID = message.markAsReadUserID;
    }
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.seqs?.length) {
      obj.seqs = message.seqs.map((e) => Math.round(e));
    }
    if (message.hasReadSeq !== 0) {
      obj.hasReadSeq = Math.round(message.hasReadSeq);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkAsReadTips>, I>>(base?: I): MarkAsReadTips {
    return MarkAsReadTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkAsReadTips>, I>>(object: I): MarkAsReadTips {
    const message = createBaseMarkAsReadTips();
    message.markAsReadUserID = object.markAsReadUserID ?? "";
    message.conversationID = object.conversationID ?? "";
    message.seqs = object.seqs?.map((e) => e) || [];
    message.hasReadSeq = object.hasReadSeq ?? 0;
    return message;
  },
};

function createBaseFriendsInfoUpdateTips(): FriendsInfoUpdateTips {
  return { fromToUserID: undefined, friendIDs: [] };
}

export const FriendsInfoUpdateTips: MessageFns<FriendsInfoUpdateTips> = {
  encode(message: FriendsInfoUpdateTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromToUserID !== undefined) {
      FromToUserID.encode(message.fromToUserID, writer.uint32(10).fork()).join();
    }
    for (const v of message.friendIDs) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FriendsInfoUpdateTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendsInfoUpdateTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromToUserID = FromToUserID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.friendIDs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FriendsInfoUpdateTips {
    return {
      fromToUserID: isSet(object.fromToUserID) ? FromToUserID.fromJSON(object.fromToUserID) : undefined,
      friendIDs: globalThis.Array.isArray(object?.friendIDs)
        ? object.friendIDs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FriendsInfoUpdateTips): unknown {
    const obj: any = {};
    if (message.fromToUserID !== undefined) {
      obj.fromToUserID = FromToUserID.toJSON(message.fromToUserID);
    }
    if (message.friendIDs?.length) {
      obj.friendIDs = message.friendIDs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FriendsInfoUpdateTips>, I>>(base?: I): FriendsInfoUpdateTips {
    return FriendsInfoUpdateTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FriendsInfoUpdateTips>, I>>(object: I): FriendsInfoUpdateTips {
    const message = createBaseFriendsInfoUpdateTips();
    message.fromToUserID = (object.fromToUserID !== undefined && object.fromToUserID !== null)
      ? FromToUserID.fromPartial(object.fromToUserID)
      : undefined;
    message.friendIDs = object.friendIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseSubUserOnlineStatusElem(): SubUserOnlineStatusElem {
  return { userID: "", onlinePlatformIDs: [] };
}

export const SubUserOnlineStatusElem: MessageFns<SubUserOnlineStatusElem> = {
  encode(message: SubUserOnlineStatusElem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    writer.uint32(18).fork();
    for (const v of message.onlinePlatformIDs) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubUserOnlineStatusElem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubUserOnlineStatusElem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.onlinePlatformIDs.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.onlinePlatformIDs.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubUserOnlineStatusElem {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      onlinePlatformIDs: globalThis.Array.isArray(object?.onlinePlatformIDs)
        ? object.onlinePlatformIDs.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: SubUserOnlineStatusElem): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.onlinePlatformIDs?.length) {
      obj.onlinePlatformIDs = message.onlinePlatformIDs.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubUserOnlineStatusElem>, I>>(base?: I): SubUserOnlineStatusElem {
    return SubUserOnlineStatusElem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubUserOnlineStatusElem>, I>>(object: I): SubUserOnlineStatusElem {
    const message = createBaseSubUserOnlineStatusElem();
    message.userID = object.userID ?? "";
    message.onlinePlatformIDs = object.onlinePlatformIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseSubUserOnlineStatusTips(): SubUserOnlineStatusTips {
  return { subscribers: [] };
}

export const SubUserOnlineStatusTips: MessageFns<SubUserOnlineStatusTips> = {
  encode(message: SubUserOnlineStatusTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subscribers) {
      SubUserOnlineStatusElem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubUserOnlineStatusTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubUserOnlineStatusTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscribers.push(SubUserOnlineStatusElem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubUserOnlineStatusTips {
    return {
      subscribers: globalThis.Array.isArray(object?.subscribers)
        ? object.subscribers.map((e: any) => SubUserOnlineStatusElem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubUserOnlineStatusTips): unknown {
    const obj: any = {};
    if (message.subscribers?.length) {
      obj.subscribers = message.subscribers.map((e) => SubUserOnlineStatusElem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubUserOnlineStatusTips>, I>>(base?: I): SubUserOnlineStatusTips {
    return SubUserOnlineStatusTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubUserOnlineStatusTips>, I>>(object: I): SubUserOnlineStatusTips {
    const message = createBaseSubUserOnlineStatusTips();
    message.subscribers = object.subscribers?.map((e) => SubUserOnlineStatusElem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubUserOnlineStatus(): SubUserOnlineStatus {
  return { subscribeUserID: [], unsubscribeUserID: [] };
}

export const SubUserOnlineStatus: MessageFns<SubUserOnlineStatus> = {
  encode(message: SubUserOnlineStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subscribeUserID) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.unsubscribeUserID) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubUserOnlineStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubUserOnlineStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscribeUserID.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unsubscribeUserID.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubUserOnlineStatus {
    return {
      subscribeUserID: globalThis.Array.isArray(object?.subscribeUserID)
        ? object.subscribeUserID.map((e: any) => globalThis.String(e))
        : [],
      unsubscribeUserID: globalThis.Array.isArray(object?.unsubscribeUserID)
        ? object.unsubscribeUserID.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SubUserOnlineStatus): unknown {
    const obj: any = {};
    if (message.subscribeUserID?.length) {
      obj.subscribeUserID = message.subscribeUserID;
    }
    if (message.unsubscribeUserID?.length) {
      obj.unsubscribeUserID = message.unsubscribeUserID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubUserOnlineStatus>, I>>(base?: I): SubUserOnlineStatus {
    return SubUserOnlineStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubUserOnlineStatus>, I>>(object: I): SubUserOnlineStatus {
    const message = createBaseSubUserOnlineStatus();
    message.subscribeUserID = object.subscribeUserID?.map((e) => e) || [];
    message.unsubscribeUserID = object.unsubscribeUserID?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamMsgTips(): StreamMsgTips {
  return { conversationID: "", clientMsgID: "", startIndex: 0, packets: [], end: false };
}

export const StreamMsgTips: MessageFns<StreamMsgTips> = {
  encode(message: StreamMsgTips, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.clientMsgID !== "") {
      writer.uint32(18).string(message.clientMsgID);
    }
    if (message.startIndex !== 0) {
      writer.uint32(24).int64(message.startIndex);
    }
    for (const v of message.packets) {
      writer.uint32(34).string(v!);
    }
    if (message.end !== false) {
      writer.uint32(40).bool(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamMsgTips {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamMsgTips();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientMsgID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startIndex = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.packets.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.end = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamMsgTips {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      clientMsgID: isSet(object.clientMsgID) ? globalThis.String(object.clientMsgID) : "",
      startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : 0,
      packets: globalThis.Array.isArray(object?.packets) ? object.packets.map((e: any) => globalThis.String(e)) : [],
      end: isSet(object.end) ? globalThis.Boolean(object.end) : false,
    };
  },

  toJSON(message: StreamMsgTips): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.clientMsgID !== "") {
      obj.clientMsgID = message.clientMsgID;
    }
    if (message.startIndex !== 0) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.packets?.length) {
      obj.packets = message.packets;
    }
    if (message.end !== false) {
      obj.end = message.end;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamMsgTips>, I>>(base?: I): StreamMsgTips {
    return StreamMsgTips.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamMsgTips>, I>>(object: I): StreamMsgTips {
    const message = createBaseStreamMsgTips();
    message.conversationID = object.conversationID ?? "";
    message.clientMsgID = object.clientMsgID ?? "";
    message.startIndex = object.startIndex ?? 0;
    message.packets = object.packets?.map((e) => e) || [];
    message.end = object.end ?? false;
    return message;
  },
};

function createBaseIMMessage(): IMMessage {
  return {
    clientMsgID: "",
    serverMsgID: "",
    createTime: 0,
    sendTime: 0,
    sessionType: 0,
    sendID: "",
    recvID: "",
    msgFrom: 0,
    contentType: 0,
    senderPlatformID: 0,
    senderNickname: "",
    senderFaceURL: "",
    groupID: "",
    seq: 0,
    isRead: false,
    status: 0,
    offlinePush: undefined,
    ex: "",
    localEx: "",
    attachedInfoElem: undefined,
    textElem: undefined,
    cardElem: undefined,
    pictureElem: undefined,
    soundElem: undefined,
    videoElem: undefined,
    fileElem: undefined,
    mergeElem: undefined,
    atTextElem: undefined,
    faceElem: undefined,
    locationElem: undefined,
    customElem: undefined,
    quoteElem: undefined,
    advancedTextElem: undefined,
    typingElem: undefined,
    streamElem: undefined,
    groupCreatedTips: undefined,
    groupInfoSetTips: undefined,
    groupInfoSetNameTips: undefined,
    groupInfoSetAnnouncementTips: undefined,
    joinGroupApplicationTips: undefined,
    memberQuitTips: undefined,
    groupApplicationAcceptedTips: undefined,
    groupApplicationRejectedTips: undefined,
    groupOwnerTransferredTips: undefined,
    memberKickedTips: undefined,
    memberInvitedTips: undefined,
    memberEnterTips: undefined,
    groupDismissedTips: undefined,
    groupMemberMutedTips: undefined,
    groupMemberCancelMutedTips: undefined,
    groupMutedTips: undefined,
    groupCancelMutedTips: undefined,
    groupMemberInfoSetTips: undefined,
    friendApplicationTips: undefined,
    friendApplicationApprovedTips: undefined,
    friendApplicationRejectedTips: undefined,
    friendAddedTips: undefined,
    friendDeletedTips: undefined,
    blackAddedTips: undefined,
    blackDeletedTips: undefined,
    friendInfoChangedTips: undefined,
    userInfoUpdatedTips: undefined,
    userStatusChangeTips: undefined,
    userCommandAddTips: undefined,
    userCommandUpdateTips: undefined,
    userCommandDeleteTips: undefined,
    conversationUpdateTips: undefined,
    conversationSetPrivateTips: undefined,
    conversationHasReadTips: undefined,
    deleteMessageTips: undefined,
    revokeMsgTips: undefined,
    clearConversationTips: undefined,
    deleteMsgsTips: undefined,
    markAsReadTips: undefined,
    friendsInfoUpdateTips: undefined,
    subUserOnlineStatusTips: undefined,
    streamMsgTips: undefined,
  };
}

export const IMMessage: MessageFns<IMMessage> = {
  encode(message: IMMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientMsgID !== "") {
      writer.uint32(10).string(message.clientMsgID);
    }
    if (message.serverMsgID !== "") {
      writer.uint32(18).string(message.serverMsgID);
    }
    if (message.createTime !== 0) {
      writer.uint32(24).int64(message.createTime);
    }
    if (message.sendTime !== 0) {
      writer.uint32(32).int64(message.sendTime);
    }
    if (message.sessionType !== 0) {
      writer.uint32(40).int32(message.sessionType);
    }
    if (message.sendID !== "") {
      writer.uint32(50).string(message.sendID);
    }
    if (message.recvID !== "") {
      writer.uint32(58).string(message.recvID);
    }
    if (message.msgFrom !== 0) {
      writer.uint32(64).int32(message.msgFrom);
    }
    if (message.contentType !== 0) {
      writer.uint32(72).int32(message.contentType);
    }
    if (message.senderPlatformID !== 0) {
      writer.uint32(80).int32(message.senderPlatformID);
    }
    if (message.senderNickname !== "") {
      writer.uint32(90).string(message.senderNickname);
    }
    if (message.senderFaceURL !== "") {
      writer.uint32(98).string(message.senderFaceURL);
    }
    if (message.groupID !== "") {
      writer.uint32(106).string(message.groupID);
    }
    if (message.seq !== 0) {
      writer.uint32(120).int64(message.seq);
    }
    if (message.isRead !== false) {
      writer.uint32(128).bool(message.isRead);
    }
    if (message.status !== 0) {
      writer.uint32(136).int32(message.status);
    }
    if (message.offlinePush !== undefined) {
      OfflinePushInfo.encode(message.offlinePush, writer.uint32(146).fork()).join();
    }
    if (message.ex !== "") {
      writer.uint32(162).string(message.ex);
    }
    if (message.localEx !== "") {
      writer.uint32(170).string(message.localEx);
    }
    if (message.attachedInfoElem !== undefined) {
      AttachedInfoElem.encode(message.attachedInfoElem, writer.uint32(178).fork()).join();
    }
    if (message.textElem !== undefined) {
      TextElem.encode(message.textElem, writer.uint32(186).fork()).join();
    }
    if (message.cardElem !== undefined) {
      CardElem.encode(message.cardElem, writer.uint32(194).fork()).join();
    }
    if (message.pictureElem !== undefined) {
      PictureElem.encode(message.pictureElem, writer.uint32(202).fork()).join();
    }
    if (message.soundElem !== undefined) {
      SoundElem.encode(message.soundElem, writer.uint32(210).fork()).join();
    }
    if (message.videoElem !== undefined) {
      VideoElem.encode(message.videoElem, writer.uint32(218).fork()).join();
    }
    if (message.fileElem !== undefined) {
      FileElem.encode(message.fileElem, writer.uint32(226).fork()).join();
    }
    if (message.mergeElem !== undefined) {
      MergeElem.encode(message.mergeElem, writer.uint32(234).fork()).join();
    }
    if (message.atTextElem !== undefined) {
      AtTextElem.encode(message.atTextElem, writer.uint32(242).fork()).join();
    }
    if (message.faceElem !== undefined) {
      FaceElem.encode(message.faceElem, writer.uint32(250).fork()).join();
    }
    if (message.locationElem !== undefined) {
      LocationElem.encode(message.locationElem, writer.uint32(258).fork()).join();
    }
    if (message.customElem !== undefined) {
      CustomElem.encode(message.customElem, writer.uint32(266).fork()).join();
    }
    if (message.quoteElem !== undefined) {
      QuoteElem.encode(message.quoteElem, writer.uint32(274).fork()).join();
    }
    if (message.advancedTextElem !== undefined) {
      AdvancedTextElem.encode(message.advancedTextElem, writer.uint32(282).fork()).join();
    }
    if (message.typingElem !== undefined) {
      TypingElem.encode(message.typingElem, writer.uint32(290).fork()).join();
    }
    if (message.streamElem !== undefined) {
      StreamElem.encode(message.streamElem, writer.uint32(298).fork()).join();
    }
    if (message.groupCreatedTips !== undefined) {
      GroupCreatedTips.encode(message.groupCreatedTips, writer.uint32(306).fork()).join();
    }
    if (message.groupInfoSetTips !== undefined) {
      GroupInfoSetTips.encode(message.groupInfoSetTips, writer.uint32(314).fork()).join();
    }
    if (message.groupInfoSetNameTips !== undefined) {
      GroupInfoSetNameTips.encode(message.groupInfoSetNameTips, writer.uint32(322).fork()).join();
    }
    if (message.groupInfoSetAnnouncementTips !== undefined) {
      GroupInfoSetAnnouncementTips.encode(message.groupInfoSetAnnouncementTips, writer.uint32(330).fork()).join();
    }
    if (message.joinGroupApplicationTips !== undefined) {
      JoinGroupApplicationTips.encode(message.joinGroupApplicationTips, writer.uint32(338).fork()).join();
    }
    if (message.memberQuitTips !== undefined) {
      MemberQuitTips.encode(message.memberQuitTips, writer.uint32(346).fork()).join();
    }
    if (message.groupApplicationAcceptedTips !== undefined) {
      GroupApplicationAcceptedTips.encode(message.groupApplicationAcceptedTips, writer.uint32(354).fork()).join();
    }
    if (message.groupApplicationRejectedTips !== undefined) {
      GroupApplicationRejectedTips.encode(message.groupApplicationRejectedTips, writer.uint32(362).fork()).join();
    }
    if (message.groupOwnerTransferredTips !== undefined) {
      GroupOwnerTransferredTips.encode(message.groupOwnerTransferredTips, writer.uint32(370).fork()).join();
    }
    if (message.memberKickedTips !== undefined) {
      MemberKickedTips.encode(message.memberKickedTips, writer.uint32(378).fork()).join();
    }
    if (message.memberInvitedTips !== undefined) {
      MemberInvitedTips.encode(message.memberInvitedTips, writer.uint32(386).fork()).join();
    }
    if (message.memberEnterTips !== undefined) {
      MemberEnterTips.encode(message.memberEnterTips, writer.uint32(394).fork()).join();
    }
    if (message.groupDismissedTips !== undefined) {
      GroupDismissedTips.encode(message.groupDismissedTips, writer.uint32(402).fork()).join();
    }
    if (message.groupMemberMutedTips !== undefined) {
      GroupMemberMutedTips.encode(message.groupMemberMutedTips, writer.uint32(410).fork()).join();
    }
    if (message.groupMemberCancelMutedTips !== undefined) {
      GroupMemberCancelMutedTips.encode(message.groupMemberCancelMutedTips, writer.uint32(418).fork()).join();
    }
    if (message.groupMutedTips !== undefined) {
      GroupMutedTips.encode(message.groupMutedTips, writer.uint32(426).fork()).join();
    }
    if (message.groupCancelMutedTips !== undefined) {
      GroupCancelMutedTips.encode(message.groupCancelMutedTips, writer.uint32(434).fork()).join();
    }
    if (message.groupMemberInfoSetTips !== undefined) {
      GroupMemberInfoSetTips.encode(message.groupMemberInfoSetTips, writer.uint32(442).fork()).join();
    }
    if (message.friendApplicationTips !== undefined) {
      FriendApplicationTips.encode(message.friendApplicationTips, writer.uint32(450).fork()).join();
    }
    if (message.friendApplicationApprovedTips !== undefined) {
      FriendApplicationApprovedTips.encode(message.friendApplicationApprovedTips, writer.uint32(458).fork()).join();
    }
    if (message.friendApplicationRejectedTips !== undefined) {
      FriendApplicationRejectedTips.encode(message.friendApplicationRejectedTips, writer.uint32(466).fork()).join();
    }
    if (message.friendAddedTips !== undefined) {
      FriendAddedTips.encode(message.friendAddedTips, writer.uint32(474).fork()).join();
    }
    if (message.friendDeletedTips !== undefined) {
      FriendDeletedTips.encode(message.friendDeletedTips, writer.uint32(482).fork()).join();
    }
    if (message.blackAddedTips !== undefined) {
      BlackAddedTips.encode(message.blackAddedTips, writer.uint32(490).fork()).join();
    }
    if (message.blackDeletedTips !== undefined) {
      BlackDeletedTips.encode(message.blackDeletedTips, writer.uint32(498).fork()).join();
    }
    if (message.friendInfoChangedTips !== undefined) {
      FriendInfoChangedTips.encode(message.friendInfoChangedTips, writer.uint32(506).fork()).join();
    }
    if (message.userInfoUpdatedTips !== undefined) {
      UserInfoUpdatedTips.encode(message.userInfoUpdatedTips, writer.uint32(514).fork()).join();
    }
    if (message.userStatusChangeTips !== undefined) {
      UserStatusChangeTips.encode(message.userStatusChangeTips, writer.uint32(522).fork()).join();
    }
    if (message.userCommandAddTips !== undefined) {
      UserCommandAddTips.encode(message.userCommandAddTips, writer.uint32(530).fork()).join();
    }
    if (message.userCommandUpdateTips !== undefined) {
      UserCommandUpdateTips.encode(message.userCommandUpdateTips, writer.uint32(538).fork()).join();
    }
    if (message.userCommandDeleteTips !== undefined) {
      UserCommandDeleteTips.encode(message.userCommandDeleteTips, writer.uint32(546).fork()).join();
    }
    if (message.conversationUpdateTips !== undefined) {
      ConversationUpdateTips.encode(message.conversationUpdateTips, writer.uint32(554).fork()).join();
    }
    if (message.conversationSetPrivateTips !== undefined) {
      ConversationSetPrivateTips.encode(message.conversationSetPrivateTips, writer.uint32(562).fork()).join();
    }
    if (message.conversationHasReadTips !== undefined) {
      ConversationHasReadTips.encode(message.conversationHasReadTips, writer.uint32(570).fork()).join();
    }
    if (message.deleteMessageTips !== undefined) {
      DeleteMessageTips.encode(message.deleteMessageTips, writer.uint32(578).fork()).join();
    }
    if (message.revokeMsgTips !== undefined) {
      RevokeMsgTips.encode(message.revokeMsgTips, writer.uint32(586).fork()).join();
    }
    if (message.clearConversationTips !== undefined) {
      ClearConversationTips.encode(message.clearConversationTips, writer.uint32(594).fork()).join();
    }
    if (message.deleteMsgsTips !== undefined) {
      DeleteMsgsTips.encode(message.deleteMsgsTips, writer.uint32(602).fork()).join();
    }
    if (message.markAsReadTips !== undefined) {
      MarkAsReadTips.encode(message.markAsReadTips, writer.uint32(610).fork()).join();
    }
    if (message.friendsInfoUpdateTips !== undefined) {
      FriendsInfoUpdateTips.encode(message.friendsInfoUpdateTips, writer.uint32(618).fork()).join();
    }
    if (message.subUserOnlineStatusTips !== undefined) {
      SubUserOnlineStatusTips.encode(message.subUserOnlineStatusTips, writer.uint32(626).fork()).join();
    }
    if (message.streamMsgTips !== undefined) {
      StreamMsgTips.encode(message.streamMsgTips, writer.uint32(634).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IMMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIMMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientMsgID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serverMsgID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.createTime = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sendTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sessionType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sendID = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.recvID = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.msgFrom = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.senderPlatformID = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.senderNickname = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.senderFaceURL = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.seq = longToNumber(reader.int64());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.isRead = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.offlinePush = OfflinePushInfo.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.localEx = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.attachedInfoElem = AttachedInfoElem.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.textElem = TextElem.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.cardElem = CardElem.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.pictureElem = PictureElem.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.soundElem = SoundElem.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.videoElem = VideoElem.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.fileElem = FileElem.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.mergeElem = MergeElem.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.atTextElem = AtTextElem.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.faceElem = FaceElem.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.locationElem = LocationElem.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.customElem = CustomElem.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.quoteElem = QuoteElem.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.advancedTextElem = AdvancedTextElem.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.typingElem = TypingElem.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.streamElem = StreamElem.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.groupCreatedTips = GroupCreatedTips.decode(reader, reader.uint32());
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.groupInfoSetTips = GroupInfoSetTips.decode(reader, reader.uint32());
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.groupInfoSetNameTips = GroupInfoSetNameTips.decode(reader, reader.uint32());
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.groupInfoSetAnnouncementTips = GroupInfoSetAnnouncementTips.decode(reader, reader.uint32());
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.joinGroupApplicationTips = JoinGroupApplicationTips.decode(reader, reader.uint32());
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.memberQuitTips = MemberQuitTips.decode(reader, reader.uint32());
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.groupApplicationAcceptedTips = GroupApplicationAcceptedTips.decode(reader, reader.uint32());
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.groupApplicationRejectedTips = GroupApplicationRejectedTips.decode(reader, reader.uint32());
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.groupOwnerTransferredTips = GroupOwnerTransferredTips.decode(reader, reader.uint32());
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.memberKickedTips = MemberKickedTips.decode(reader, reader.uint32());
          continue;
        }
        case 48: {
          if (tag !== 386) {
            break;
          }

          message.memberInvitedTips = MemberInvitedTips.decode(reader, reader.uint32());
          continue;
        }
        case 49: {
          if (tag !== 394) {
            break;
          }

          message.memberEnterTips = MemberEnterTips.decode(reader, reader.uint32());
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.groupDismissedTips = GroupDismissedTips.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.groupMemberMutedTips = GroupMemberMutedTips.decode(reader, reader.uint32());
          continue;
        }
        case 52: {
          if (tag !== 418) {
            break;
          }

          message.groupMemberCancelMutedTips = GroupMemberCancelMutedTips.decode(reader, reader.uint32());
          continue;
        }
        case 53: {
          if (tag !== 426) {
            break;
          }

          message.groupMutedTips = GroupMutedTips.decode(reader, reader.uint32());
          continue;
        }
        case 54: {
          if (tag !== 434) {
            break;
          }

          message.groupCancelMutedTips = GroupCancelMutedTips.decode(reader, reader.uint32());
          continue;
        }
        case 55: {
          if (tag !== 442) {
            break;
          }

          message.groupMemberInfoSetTips = GroupMemberInfoSetTips.decode(reader, reader.uint32());
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.friendApplicationTips = FriendApplicationTips.decode(reader, reader.uint32());
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.friendApplicationApprovedTips = FriendApplicationApprovedTips.decode(reader, reader.uint32());
          continue;
        }
        case 58: {
          if (tag !== 466) {
            break;
          }

          message.friendApplicationRejectedTips = FriendApplicationRejectedTips.decode(reader, reader.uint32());
          continue;
        }
        case 59: {
          if (tag !== 474) {
            break;
          }

          message.friendAddedTips = FriendAddedTips.decode(reader, reader.uint32());
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.friendDeletedTips = FriendDeletedTips.decode(reader, reader.uint32());
          continue;
        }
        case 61: {
          if (tag !== 490) {
            break;
          }

          message.blackAddedTips = BlackAddedTips.decode(reader, reader.uint32());
          continue;
        }
        case 62: {
          if (tag !== 498) {
            break;
          }

          message.blackDeletedTips = BlackDeletedTips.decode(reader, reader.uint32());
          continue;
        }
        case 63: {
          if (tag !== 506) {
            break;
          }

          message.friendInfoChangedTips = FriendInfoChangedTips.decode(reader, reader.uint32());
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.userInfoUpdatedTips = UserInfoUpdatedTips.decode(reader, reader.uint32());
          continue;
        }
        case 65: {
          if (tag !== 522) {
            break;
          }

          message.userStatusChangeTips = UserStatusChangeTips.decode(reader, reader.uint32());
          continue;
        }
        case 66: {
          if (tag !== 530) {
            break;
          }

          message.userCommandAddTips = UserCommandAddTips.decode(reader, reader.uint32());
          continue;
        }
        case 67: {
          if (tag !== 538) {
            break;
          }

          message.userCommandUpdateTips = UserCommandUpdateTips.decode(reader, reader.uint32());
          continue;
        }
        case 68: {
          if (tag !== 546) {
            break;
          }

          message.userCommandDeleteTips = UserCommandDeleteTips.decode(reader, reader.uint32());
          continue;
        }
        case 69: {
          if (tag !== 554) {
            break;
          }

          message.conversationUpdateTips = ConversationUpdateTips.decode(reader, reader.uint32());
          continue;
        }
        case 70: {
          if (tag !== 562) {
            break;
          }

          message.conversationSetPrivateTips = ConversationSetPrivateTips.decode(reader, reader.uint32());
          continue;
        }
        case 71: {
          if (tag !== 570) {
            break;
          }

          message.conversationHasReadTips = ConversationHasReadTips.decode(reader, reader.uint32());
          continue;
        }
        case 72: {
          if (tag !== 578) {
            break;
          }

          message.deleteMessageTips = DeleteMessageTips.decode(reader, reader.uint32());
          continue;
        }
        case 73: {
          if (tag !== 586) {
            break;
          }

          message.revokeMsgTips = RevokeMsgTips.decode(reader, reader.uint32());
          continue;
        }
        case 74: {
          if (tag !== 594) {
            break;
          }

          message.clearConversationTips = ClearConversationTips.decode(reader, reader.uint32());
          continue;
        }
        case 75: {
          if (tag !== 602) {
            break;
          }

          message.deleteMsgsTips = DeleteMsgsTips.decode(reader, reader.uint32());
          continue;
        }
        case 76: {
          if (tag !== 610) {
            break;
          }

          message.markAsReadTips = MarkAsReadTips.decode(reader, reader.uint32());
          continue;
        }
        case 77: {
          if (tag !== 618) {
            break;
          }

          message.friendsInfoUpdateTips = FriendsInfoUpdateTips.decode(reader, reader.uint32());
          continue;
        }
        case 78: {
          if (tag !== 626) {
            break;
          }

          message.subUserOnlineStatusTips = SubUserOnlineStatusTips.decode(reader, reader.uint32());
          continue;
        }
        case 79: {
          if (tag !== 634) {
            break;
          }

          message.streamMsgTips = StreamMsgTips.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IMMessage {
    return {
      clientMsgID: isSet(object.clientMsgID) ? globalThis.String(object.clientMsgID) : "",
      serverMsgID: isSet(object.serverMsgID) ? globalThis.String(object.serverMsgID) : "",
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      sendTime: isSet(object.sendTime) ? globalThis.Number(object.sendTime) : 0,
      sessionType: isSet(object.sessionType) ? sessionTypeFromJSON(object.sessionType) : 0,
      sendID: isSet(object.sendID) ? globalThis.String(object.sendID) : "",
      recvID: isSet(object.recvID) ? globalThis.String(object.recvID) : "",
      msgFrom: isSet(object.msgFrom) ? msgFromFromJSON(object.msgFrom) : 0,
      contentType: isSet(object.contentType) ? contentTypeFromJSON(object.contentType) : 0,
      senderPlatformID: isSet(object.senderPlatformID) ? platformFromJSON(object.senderPlatformID) : 0,
      senderNickname: isSet(object.senderNickname) ? globalThis.String(object.senderNickname) : "",
      senderFaceURL: isSet(object.senderFaceURL) ? globalThis.String(object.senderFaceURL) : "",
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      isRead: isSet(object.isRead) ? globalThis.Boolean(object.isRead) : false,
      status: isSet(object.status) ? msgStatusFromJSON(object.status) : 0,
      offlinePush: isSet(object.offlinePush) ? OfflinePushInfo.fromJSON(object.offlinePush) : undefined,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      localEx: isSet(object.localEx) ? globalThis.String(object.localEx) : "",
      attachedInfoElem: isSet(object.attachedInfoElem) ? AttachedInfoElem.fromJSON(object.attachedInfoElem) : undefined,
      textElem: isSet(object.textElem) ? TextElem.fromJSON(object.textElem) : undefined,
      cardElem: isSet(object.cardElem) ? CardElem.fromJSON(object.cardElem) : undefined,
      pictureElem: isSet(object.pictureElem) ? PictureElem.fromJSON(object.pictureElem) : undefined,
      soundElem: isSet(object.soundElem) ? SoundElem.fromJSON(object.soundElem) : undefined,
      videoElem: isSet(object.videoElem) ? VideoElem.fromJSON(object.videoElem) : undefined,
      fileElem: isSet(object.fileElem) ? FileElem.fromJSON(object.fileElem) : undefined,
      mergeElem: isSet(object.mergeElem) ? MergeElem.fromJSON(object.mergeElem) : undefined,
      atTextElem: isSet(object.atTextElem) ? AtTextElem.fromJSON(object.atTextElem) : undefined,
      faceElem: isSet(object.faceElem) ? FaceElem.fromJSON(object.faceElem) : undefined,
      locationElem: isSet(object.locationElem) ? LocationElem.fromJSON(object.locationElem) : undefined,
      customElem: isSet(object.customElem) ? CustomElem.fromJSON(object.customElem) : undefined,
      quoteElem: isSet(object.quoteElem) ? QuoteElem.fromJSON(object.quoteElem) : undefined,
      advancedTextElem: isSet(object.advancedTextElem) ? AdvancedTextElem.fromJSON(object.advancedTextElem) : undefined,
      typingElem: isSet(object.typingElem) ? TypingElem.fromJSON(object.typingElem) : undefined,
      streamElem: isSet(object.streamElem) ? StreamElem.fromJSON(object.streamElem) : undefined,
      groupCreatedTips: isSet(object.groupCreatedTips) ? GroupCreatedTips.fromJSON(object.groupCreatedTips) : undefined,
      groupInfoSetTips: isSet(object.groupInfoSetTips) ? GroupInfoSetTips.fromJSON(object.groupInfoSetTips) : undefined,
      groupInfoSetNameTips: isSet(object.groupInfoSetNameTips)
        ? GroupInfoSetNameTips.fromJSON(object.groupInfoSetNameTips)
        : undefined,
      groupInfoSetAnnouncementTips: isSet(object.groupInfoSetAnnouncementTips)
        ? GroupInfoSetAnnouncementTips.fromJSON(object.groupInfoSetAnnouncementTips)
        : undefined,
      joinGroupApplicationTips: isSet(object.joinGroupApplicationTips)
        ? JoinGroupApplicationTips.fromJSON(object.joinGroupApplicationTips)
        : undefined,
      memberQuitTips: isSet(object.memberQuitTips) ? MemberQuitTips.fromJSON(object.memberQuitTips) : undefined,
      groupApplicationAcceptedTips: isSet(object.groupApplicationAcceptedTips)
        ? GroupApplicationAcceptedTips.fromJSON(object.groupApplicationAcceptedTips)
        : undefined,
      groupApplicationRejectedTips: isSet(object.groupApplicationRejectedTips)
        ? GroupApplicationRejectedTips.fromJSON(object.groupApplicationRejectedTips)
        : undefined,
      groupOwnerTransferredTips: isSet(object.groupOwnerTransferredTips)
        ? GroupOwnerTransferredTips.fromJSON(object.groupOwnerTransferredTips)
        : undefined,
      memberKickedTips: isSet(object.memberKickedTips) ? MemberKickedTips.fromJSON(object.memberKickedTips) : undefined,
      memberInvitedTips: isSet(object.memberInvitedTips)
        ? MemberInvitedTips.fromJSON(object.memberInvitedTips)
        : undefined,
      memberEnterTips: isSet(object.memberEnterTips) ? MemberEnterTips.fromJSON(object.memberEnterTips) : undefined,
      groupDismissedTips: isSet(object.groupDismissedTips)
        ? GroupDismissedTips.fromJSON(object.groupDismissedTips)
        : undefined,
      groupMemberMutedTips: isSet(object.groupMemberMutedTips)
        ? GroupMemberMutedTips.fromJSON(object.groupMemberMutedTips)
        : undefined,
      groupMemberCancelMutedTips: isSet(object.groupMemberCancelMutedTips)
        ? GroupMemberCancelMutedTips.fromJSON(object.groupMemberCancelMutedTips)
        : undefined,
      groupMutedTips: isSet(object.groupMutedTips) ? GroupMutedTips.fromJSON(object.groupMutedTips) : undefined,
      groupCancelMutedTips: isSet(object.groupCancelMutedTips)
        ? GroupCancelMutedTips.fromJSON(object.groupCancelMutedTips)
        : undefined,
      groupMemberInfoSetTips: isSet(object.groupMemberInfoSetTips)
        ? GroupMemberInfoSetTips.fromJSON(object.groupMemberInfoSetTips)
        : undefined,
      friendApplicationTips: isSet(object.friendApplicationTips)
        ? FriendApplicationTips.fromJSON(object.friendApplicationTips)
        : undefined,
      friendApplicationApprovedTips: isSet(object.friendApplicationApprovedTips)
        ? FriendApplicationApprovedTips.fromJSON(object.friendApplicationApprovedTips)
        : undefined,
      friendApplicationRejectedTips: isSet(object.friendApplicationRejectedTips)
        ? FriendApplicationRejectedTips.fromJSON(object.friendApplicationRejectedTips)
        : undefined,
      friendAddedTips: isSet(object.friendAddedTips) ? FriendAddedTips.fromJSON(object.friendAddedTips) : undefined,
      friendDeletedTips: isSet(object.friendDeletedTips)
        ? FriendDeletedTips.fromJSON(object.friendDeletedTips)
        : undefined,
      blackAddedTips: isSet(object.blackAddedTips) ? BlackAddedTips.fromJSON(object.blackAddedTips) : undefined,
      blackDeletedTips: isSet(object.blackDeletedTips) ? BlackDeletedTips.fromJSON(object.blackDeletedTips) : undefined,
      friendInfoChangedTips: isSet(object.friendInfoChangedTips)
        ? FriendInfoChangedTips.fromJSON(object.friendInfoChangedTips)
        : undefined,
      userInfoUpdatedTips: isSet(object.userInfoUpdatedTips)
        ? UserInfoUpdatedTips.fromJSON(object.userInfoUpdatedTips)
        : undefined,
      userStatusChangeTips: isSet(object.userStatusChangeTips)
        ? UserStatusChangeTips.fromJSON(object.userStatusChangeTips)
        : undefined,
      userCommandAddTips: isSet(object.userCommandAddTips)
        ? UserCommandAddTips.fromJSON(object.userCommandAddTips)
        : undefined,
      userCommandUpdateTips: isSet(object.userCommandUpdateTips)
        ? UserCommandUpdateTips.fromJSON(object.userCommandUpdateTips)
        : undefined,
      userCommandDeleteTips: isSet(object.userCommandDeleteTips)
        ? UserCommandDeleteTips.fromJSON(object.userCommandDeleteTips)
        : undefined,
      conversationUpdateTips: isSet(object.conversationUpdateTips)
        ? ConversationUpdateTips.fromJSON(object.conversationUpdateTips)
        : undefined,
      conversationSetPrivateTips: isSet(object.conversationSetPrivateTips)
        ? ConversationSetPrivateTips.fromJSON(object.conversationSetPrivateTips)
        : undefined,
      conversationHasReadTips: isSet(object.conversationHasReadTips)
        ? ConversationHasReadTips.fromJSON(object.conversationHasReadTips)
        : undefined,
      deleteMessageTips: isSet(object.deleteMessageTips)
        ? DeleteMessageTips.fromJSON(object.deleteMessageTips)
        : undefined,
      revokeMsgTips: isSet(object.revokeMsgTips) ? RevokeMsgTips.fromJSON(object.revokeMsgTips) : undefined,
      clearConversationTips: isSet(object.clearConversationTips)
        ? ClearConversationTips.fromJSON(object.clearConversationTips)
        : undefined,
      deleteMsgsTips: isSet(object.deleteMsgsTips) ? DeleteMsgsTips.fromJSON(object.deleteMsgsTips) : undefined,
      markAsReadTips: isSet(object.markAsReadTips) ? MarkAsReadTips.fromJSON(object.markAsReadTips) : undefined,
      friendsInfoUpdateTips: isSet(object.friendsInfoUpdateTips)
        ? FriendsInfoUpdateTips.fromJSON(object.friendsInfoUpdateTips)
        : undefined,
      subUserOnlineStatusTips: isSet(object.subUserOnlineStatusTips)
        ? SubUserOnlineStatusTips.fromJSON(object.subUserOnlineStatusTips)
        : undefined,
      streamMsgTips: isSet(object.streamMsgTips) ? StreamMsgTips.fromJSON(object.streamMsgTips) : undefined,
    };
  },

  toJSON(message: IMMessage): unknown {
    const obj: any = {};
    if (message.clientMsgID !== "") {
      obj.clientMsgID = message.clientMsgID;
    }
    if (message.serverMsgID !== "") {
      obj.serverMsgID = message.serverMsgID;
    }
    if (message.createTime !== 0) {
      obj.createTime = Math.round(message.createTime);
    }
    if (message.sendTime !== 0) {
      obj.sendTime = Math.round(message.sendTime);
    }
    if (message.sessionType !== 0) {
      obj.sessionType = sessionTypeToJSON(message.sessionType);
    }
    if (message.sendID !== "") {
      obj.sendID = message.sendID;
    }
    if (message.recvID !== "") {
      obj.recvID = message.recvID;
    }
    if (message.msgFrom !== 0) {
      obj.msgFrom = msgFromToJSON(message.msgFrom);
    }
    if (message.contentType !== 0) {
      obj.contentType = contentTypeToJSON(message.contentType);
    }
    if (message.senderPlatformID !== 0) {
      obj.senderPlatformID = platformToJSON(message.senderPlatformID);
    }
    if (message.senderNickname !== "") {
      obj.senderNickname = message.senderNickname;
    }
    if (message.senderFaceURL !== "") {
      obj.senderFaceURL = message.senderFaceURL;
    }
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.isRead !== false) {
      obj.isRead = message.isRead;
    }
    if (message.status !== 0) {
      obj.status = msgStatusToJSON(message.status);
    }
    if (message.offlinePush !== undefined) {
      obj.offlinePush = OfflinePushInfo.toJSON(message.offlinePush);
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.localEx !== "") {
      obj.localEx = message.localEx;
    }
    if (message.attachedInfoElem !== undefined) {
      obj.attachedInfoElem = AttachedInfoElem.toJSON(message.attachedInfoElem);
    }
    if (message.textElem !== undefined) {
      obj.textElem = TextElem.toJSON(message.textElem);
    }
    if (message.cardElem !== undefined) {
      obj.cardElem = CardElem.toJSON(message.cardElem);
    }
    if (message.pictureElem !== undefined) {
      obj.pictureElem = PictureElem.toJSON(message.pictureElem);
    }
    if (message.soundElem !== undefined) {
      obj.soundElem = SoundElem.toJSON(message.soundElem);
    }
    if (message.videoElem !== undefined) {
      obj.videoElem = VideoElem.toJSON(message.videoElem);
    }
    if (message.fileElem !== undefined) {
      obj.fileElem = FileElem.toJSON(message.fileElem);
    }
    if (message.mergeElem !== undefined) {
      obj.mergeElem = MergeElem.toJSON(message.mergeElem);
    }
    if (message.atTextElem !== undefined) {
      obj.atTextElem = AtTextElem.toJSON(message.atTextElem);
    }
    if (message.faceElem !== undefined) {
      obj.faceElem = FaceElem.toJSON(message.faceElem);
    }
    if (message.locationElem !== undefined) {
      obj.locationElem = LocationElem.toJSON(message.locationElem);
    }
    if (message.customElem !== undefined) {
      obj.customElem = CustomElem.toJSON(message.customElem);
    }
    if (message.quoteElem !== undefined) {
      obj.quoteElem = QuoteElem.toJSON(message.quoteElem);
    }
    if (message.advancedTextElem !== undefined) {
      obj.advancedTextElem = AdvancedTextElem.toJSON(message.advancedTextElem);
    }
    if (message.typingElem !== undefined) {
      obj.typingElem = TypingElem.toJSON(message.typingElem);
    }
    if (message.streamElem !== undefined) {
      obj.streamElem = StreamElem.toJSON(message.streamElem);
    }
    if (message.groupCreatedTips !== undefined) {
      obj.groupCreatedTips = GroupCreatedTips.toJSON(message.groupCreatedTips);
    }
    if (message.groupInfoSetTips !== undefined) {
      obj.groupInfoSetTips = GroupInfoSetTips.toJSON(message.groupInfoSetTips);
    }
    if (message.groupInfoSetNameTips !== undefined) {
      obj.groupInfoSetNameTips = GroupInfoSetNameTips.toJSON(message.groupInfoSetNameTips);
    }
    if (message.groupInfoSetAnnouncementTips !== undefined) {
      obj.groupInfoSetAnnouncementTips = GroupInfoSetAnnouncementTips.toJSON(message.groupInfoSetAnnouncementTips);
    }
    if (message.joinGroupApplicationTips !== undefined) {
      obj.joinGroupApplicationTips = JoinGroupApplicationTips.toJSON(message.joinGroupApplicationTips);
    }
    if (message.memberQuitTips !== undefined) {
      obj.memberQuitTips = MemberQuitTips.toJSON(message.memberQuitTips);
    }
    if (message.groupApplicationAcceptedTips !== undefined) {
      obj.groupApplicationAcceptedTips = GroupApplicationAcceptedTips.toJSON(message.groupApplicationAcceptedTips);
    }
    if (message.groupApplicationRejectedTips !== undefined) {
      obj.groupApplicationRejectedTips = GroupApplicationRejectedTips.toJSON(message.groupApplicationRejectedTips);
    }
    if (message.groupOwnerTransferredTips !== undefined) {
      obj.groupOwnerTransferredTips = GroupOwnerTransferredTips.toJSON(message.groupOwnerTransferredTips);
    }
    if (message.memberKickedTips !== undefined) {
      obj.memberKickedTips = MemberKickedTips.toJSON(message.memberKickedTips);
    }
    if (message.memberInvitedTips !== undefined) {
      obj.memberInvitedTips = MemberInvitedTips.toJSON(message.memberInvitedTips);
    }
    if (message.memberEnterTips !== undefined) {
      obj.memberEnterTips = MemberEnterTips.toJSON(message.memberEnterTips);
    }
    if (message.groupDismissedTips !== undefined) {
      obj.groupDismissedTips = GroupDismissedTips.toJSON(message.groupDismissedTips);
    }
    if (message.groupMemberMutedTips !== undefined) {
      obj.groupMemberMutedTips = GroupMemberMutedTips.toJSON(message.groupMemberMutedTips);
    }
    if (message.groupMemberCancelMutedTips !== undefined) {
      obj.groupMemberCancelMutedTips = GroupMemberCancelMutedTips.toJSON(message.groupMemberCancelMutedTips);
    }
    if (message.groupMutedTips !== undefined) {
      obj.groupMutedTips = GroupMutedTips.toJSON(message.groupMutedTips);
    }
    if (message.groupCancelMutedTips !== undefined) {
      obj.groupCancelMutedTips = GroupCancelMutedTips.toJSON(message.groupCancelMutedTips);
    }
    if (message.groupMemberInfoSetTips !== undefined) {
      obj.groupMemberInfoSetTips = GroupMemberInfoSetTips.toJSON(message.groupMemberInfoSetTips);
    }
    if (message.friendApplicationTips !== undefined) {
      obj.friendApplicationTips = FriendApplicationTips.toJSON(message.friendApplicationTips);
    }
    if (message.friendApplicationApprovedTips !== undefined) {
      obj.friendApplicationApprovedTips = FriendApplicationApprovedTips.toJSON(message.friendApplicationApprovedTips);
    }
    if (message.friendApplicationRejectedTips !== undefined) {
      obj.friendApplicationRejectedTips = FriendApplicationRejectedTips.toJSON(message.friendApplicationRejectedTips);
    }
    if (message.friendAddedTips !== undefined) {
      obj.friendAddedTips = FriendAddedTips.toJSON(message.friendAddedTips);
    }
    if (message.friendDeletedTips !== undefined) {
      obj.friendDeletedTips = FriendDeletedTips.toJSON(message.friendDeletedTips);
    }
    if (message.blackAddedTips !== undefined) {
      obj.blackAddedTips = BlackAddedTips.toJSON(message.blackAddedTips);
    }
    if (message.blackDeletedTips !== undefined) {
      obj.blackDeletedTips = BlackDeletedTips.toJSON(message.blackDeletedTips);
    }
    if (message.friendInfoChangedTips !== undefined) {
      obj.friendInfoChangedTips = FriendInfoChangedTips.toJSON(message.friendInfoChangedTips);
    }
    if (message.userInfoUpdatedTips !== undefined) {
      obj.userInfoUpdatedTips = UserInfoUpdatedTips.toJSON(message.userInfoUpdatedTips);
    }
    if (message.userStatusChangeTips !== undefined) {
      obj.userStatusChangeTips = UserStatusChangeTips.toJSON(message.userStatusChangeTips);
    }
    if (message.userCommandAddTips !== undefined) {
      obj.userCommandAddTips = UserCommandAddTips.toJSON(message.userCommandAddTips);
    }
    if (message.userCommandUpdateTips !== undefined) {
      obj.userCommandUpdateTips = UserCommandUpdateTips.toJSON(message.userCommandUpdateTips);
    }
    if (message.userCommandDeleteTips !== undefined) {
      obj.userCommandDeleteTips = UserCommandDeleteTips.toJSON(message.userCommandDeleteTips);
    }
    if (message.conversationUpdateTips !== undefined) {
      obj.conversationUpdateTips = ConversationUpdateTips.toJSON(message.conversationUpdateTips);
    }
    if (message.conversationSetPrivateTips !== undefined) {
      obj.conversationSetPrivateTips = ConversationSetPrivateTips.toJSON(message.conversationSetPrivateTips);
    }
    if (message.conversationHasReadTips !== undefined) {
      obj.conversationHasReadTips = ConversationHasReadTips.toJSON(message.conversationHasReadTips);
    }
    if (message.deleteMessageTips !== undefined) {
      obj.deleteMessageTips = DeleteMessageTips.toJSON(message.deleteMessageTips);
    }
    if (message.revokeMsgTips !== undefined) {
      obj.revokeMsgTips = RevokeMsgTips.toJSON(message.revokeMsgTips);
    }
    if (message.clearConversationTips !== undefined) {
      obj.clearConversationTips = ClearConversationTips.toJSON(message.clearConversationTips);
    }
    if (message.deleteMsgsTips !== undefined) {
      obj.deleteMsgsTips = DeleteMsgsTips.toJSON(message.deleteMsgsTips);
    }
    if (message.markAsReadTips !== undefined) {
      obj.markAsReadTips = MarkAsReadTips.toJSON(message.markAsReadTips);
    }
    if (message.friendsInfoUpdateTips !== undefined) {
      obj.friendsInfoUpdateTips = FriendsInfoUpdateTips.toJSON(message.friendsInfoUpdateTips);
    }
    if (message.subUserOnlineStatusTips !== undefined) {
      obj.subUserOnlineStatusTips = SubUserOnlineStatusTips.toJSON(message.subUserOnlineStatusTips);
    }
    if (message.streamMsgTips !== undefined) {
      obj.streamMsgTips = StreamMsgTips.toJSON(message.streamMsgTips);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IMMessage>, I>>(base?: I): IMMessage {
    return IMMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IMMessage>, I>>(object: I): IMMessage {
    const message = createBaseIMMessage();
    message.clientMsgID = object.clientMsgID ?? "";
    message.serverMsgID = object.serverMsgID ?? "";
    message.createTime = object.createTime ?? 0;
    message.sendTime = object.sendTime ?? 0;
    message.sessionType = object.sessionType ?? 0;
    message.sendID = object.sendID ?? "";
    message.recvID = object.recvID ?? "";
    message.msgFrom = object.msgFrom ?? 0;
    message.contentType = object.contentType ?? 0;
    message.senderPlatformID = object.senderPlatformID ?? 0;
    message.senderNickname = object.senderNickname ?? "";
    message.senderFaceURL = object.senderFaceURL ?? "";
    message.groupID = object.groupID ?? "";
    message.seq = object.seq ?? 0;
    message.isRead = object.isRead ?? false;
    message.status = object.status ?? 0;
    message.offlinePush = (object.offlinePush !== undefined && object.offlinePush !== null)
      ? OfflinePushInfo.fromPartial(object.offlinePush)
      : undefined;
    message.ex = object.ex ?? "";
    message.localEx = object.localEx ?? "";
    message.attachedInfoElem = (object.attachedInfoElem !== undefined && object.attachedInfoElem !== null)
      ? AttachedInfoElem.fromPartial(object.attachedInfoElem)
      : undefined;
    message.textElem = (object.textElem !== undefined && object.textElem !== null)
      ? TextElem.fromPartial(object.textElem)
      : undefined;
    message.cardElem = (object.cardElem !== undefined && object.cardElem !== null)
      ? CardElem.fromPartial(object.cardElem)
      : undefined;
    message.pictureElem = (object.pictureElem !== undefined && object.pictureElem !== null)
      ? PictureElem.fromPartial(object.pictureElem)
      : undefined;
    message.soundElem = (object.soundElem !== undefined && object.soundElem !== null)
      ? SoundElem.fromPartial(object.soundElem)
      : undefined;
    message.videoElem = (object.videoElem !== undefined && object.videoElem !== null)
      ? VideoElem.fromPartial(object.videoElem)
      : undefined;
    message.fileElem = (object.fileElem !== undefined && object.fileElem !== null)
      ? FileElem.fromPartial(object.fileElem)
      : undefined;
    message.mergeElem = (object.mergeElem !== undefined && object.mergeElem !== null)
      ? MergeElem.fromPartial(object.mergeElem)
      : undefined;
    message.atTextElem = (object.atTextElem !== undefined && object.atTextElem !== null)
      ? AtTextElem.fromPartial(object.atTextElem)
      : undefined;
    message.faceElem = (object.faceElem !== undefined && object.faceElem !== null)
      ? FaceElem.fromPartial(object.faceElem)
      : undefined;
    message.locationElem = (object.locationElem !== undefined && object.locationElem !== null)
      ? LocationElem.fromPartial(object.locationElem)
      : undefined;
    message.customElem = (object.customElem !== undefined && object.customElem !== null)
      ? CustomElem.fromPartial(object.customElem)
      : undefined;
    message.quoteElem = (object.quoteElem !== undefined && object.quoteElem !== null)
      ? QuoteElem.fromPartial(object.quoteElem)
      : undefined;
    message.advancedTextElem = (object.advancedTextElem !== undefined && object.advancedTextElem !== null)
      ? AdvancedTextElem.fromPartial(object.advancedTextElem)
      : undefined;
    message.typingElem = (object.typingElem !== undefined && object.typingElem !== null)
      ? TypingElem.fromPartial(object.typingElem)
      : undefined;
    message.streamElem = (object.streamElem !== undefined && object.streamElem !== null)
      ? StreamElem.fromPartial(object.streamElem)
      : undefined;
    message.groupCreatedTips = (object.groupCreatedTips !== undefined && object.groupCreatedTips !== null)
      ? GroupCreatedTips.fromPartial(object.groupCreatedTips)
      : undefined;
    message.groupInfoSetTips = (object.groupInfoSetTips !== undefined && object.groupInfoSetTips !== null)
      ? GroupInfoSetTips.fromPartial(object.groupInfoSetTips)
      : undefined;
    message.groupInfoSetNameTips = (object.groupInfoSetNameTips !== undefined && object.groupInfoSetNameTips !== null)
      ? GroupInfoSetNameTips.fromPartial(object.groupInfoSetNameTips)
      : undefined;
    message.groupInfoSetAnnouncementTips =
      (object.groupInfoSetAnnouncementTips !== undefined && object.groupInfoSetAnnouncementTips !== null)
        ? GroupInfoSetAnnouncementTips.fromPartial(object.groupInfoSetAnnouncementTips)
        : undefined;
    message.joinGroupApplicationTips =
      (object.joinGroupApplicationTips !== undefined && object.joinGroupApplicationTips !== null)
        ? JoinGroupApplicationTips.fromPartial(object.joinGroupApplicationTips)
        : undefined;
    message.memberQuitTips = (object.memberQuitTips !== undefined && object.memberQuitTips !== null)
      ? MemberQuitTips.fromPartial(object.memberQuitTips)
      : undefined;
    message.groupApplicationAcceptedTips =
      (object.groupApplicationAcceptedTips !== undefined && object.groupApplicationAcceptedTips !== null)
        ? GroupApplicationAcceptedTips.fromPartial(object.groupApplicationAcceptedTips)
        : undefined;
    message.groupApplicationRejectedTips =
      (object.groupApplicationRejectedTips !== undefined && object.groupApplicationRejectedTips !== null)
        ? GroupApplicationRejectedTips.fromPartial(object.groupApplicationRejectedTips)
        : undefined;
    message.groupOwnerTransferredTips =
      (object.groupOwnerTransferredTips !== undefined && object.groupOwnerTransferredTips !== null)
        ? GroupOwnerTransferredTips.fromPartial(object.groupOwnerTransferredTips)
        : undefined;
    message.memberKickedTips = (object.memberKickedTips !== undefined && object.memberKickedTips !== null)
      ? MemberKickedTips.fromPartial(object.memberKickedTips)
      : undefined;
    message.memberInvitedTips = (object.memberInvitedTips !== undefined && object.memberInvitedTips !== null)
      ? MemberInvitedTips.fromPartial(object.memberInvitedTips)
      : undefined;
    message.memberEnterTips = (object.memberEnterTips !== undefined && object.memberEnterTips !== null)
      ? MemberEnterTips.fromPartial(object.memberEnterTips)
      : undefined;
    message.groupDismissedTips = (object.groupDismissedTips !== undefined && object.groupDismissedTips !== null)
      ? GroupDismissedTips.fromPartial(object.groupDismissedTips)
      : undefined;
    message.groupMemberMutedTips = (object.groupMemberMutedTips !== undefined && object.groupMemberMutedTips !== null)
      ? GroupMemberMutedTips.fromPartial(object.groupMemberMutedTips)
      : undefined;
    message.groupMemberCancelMutedTips =
      (object.groupMemberCancelMutedTips !== undefined && object.groupMemberCancelMutedTips !== null)
        ? GroupMemberCancelMutedTips.fromPartial(object.groupMemberCancelMutedTips)
        : undefined;
    message.groupMutedTips = (object.groupMutedTips !== undefined && object.groupMutedTips !== null)
      ? GroupMutedTips.fromPartial(object.groupMutedTips)
      : undefined;
    message.groupCancelMutedTips = (object.groupCancelMutedTips !== undefined && object.groupCancelMutedTips !== null)
      ? GroupCancelMutedTips.fromPartial(object.groupCancelMutedTips)
      : undefined;
    message.groupMemberInfoSetTips =
      (object.groupMemberInfoSetTips !== undefined && object.groupMemberInfoSetTips !== null)
        ? GroupMemberInfoSetTips.fromPartial(object.groupMemberInfoSetTips)
        : undefined;
    message.friendApplicationTips =
      (object.friendApplicationTips !== undefined && object.friendApplicationTips !== null)
        ? FriendApplicationTips.fromPartial(object.friendApplicationTips)
        : undefined;
    message.friendApplicationApprovedTips =
      (object.friendApplicationApprovedTips !== undefined && object.friendApplicationApprovedTips !== null)
        ? FriendApplicationApprovedTips.fromPartial(object.friendApplicationApprovedTips)
        : undefined;
    message.friendApplicationRejectedTips =
      (object.friendApplicationRejectedTips !== undefined && object.friendApplicationRejectedTips !== null)
        ? FriendApplicationRejectedTips.fromPartial(object.friendApplicationRejectedTips)
        : undefined;
    message.friendAddedTips = (object.friendAddedTips !== undefined && object.friendAddedTips !== null)
      ? FriendAddedTips.fromPartial(object.friendAddedTips)
      : undefined;
    message.friendDeletedTips = (object.friendDeletedTips !== undefined && object.friendDeletedTips !== null)
      ? FriendDeletedTips.fromPartial(object.friendDeletedTips)
      : undefined;
    message.blackAddedTips = (object.blackAddedTips !== undefined && object.blackAddedTips !== null)
      ? BlackAddedTips.fromPartial(object.blackAddedTips)
      : undefined;
    message.blackDeletedTips = (object.blackDeletedTips !== undefined && object.blackDeletedTips !== null)
      ? BlackDeletedTips.fromPartial(object.blackDeletedTips)
      : undefined;
    message.friendInfoChangedTips =
      (object.friendInfoChangedTips !== undefined && object.friendInfoChangedTips !== null)
        ? FriendInfoChangedTips.fromPartial(object.friendInfoChangedTips)
        : undefined;
    message.userInfoUpdatedTips = (object.userInfoUpdatedTips !== undefined && object.userInfoUpdatedTips !== null)
      ? UserInfoUpdatedTips.fromPartial(object.userInfoUpdatedTips)
      : undefined;
    message.userStatusChangeTips = (object.userStatusChangeTips !== undefined && object.userStatusChangeTips !== null)
      ? UserStatusChangeTips.fromPartial(object.userStatusChangeTips)
      : undefined;
    message.userCommandAddTips = (object.userCommandAddTips !== undefined && object.userCommandAddTips !== null)
      ? UserCommandAddTips.fromPartial(object.userCommandAddTips)
      : undefined;
    message.userCommandUpdateTips =
      (object.userCommandUpdateTips !== undefined && object.userCommandUpdateTips !== null)
        ? UserCommandUpdateTips.fromPartial(object.userCommandUpdateTips)
        : undefined;
    message.userCommandDeleteTips =
      (object.userCommandDeleteTips !== undefined && object.userCommandDeleteTips !== null)
        ? UserCommandDeleteTips.fromPartial(object.userCommandDeleteTips)
        : undefined;
    message.conversationUpdateTips =
      (object.conversationUpdateTips !== undefined && object.conversationUpdateTips !== null)
        ? ConversationUpdateTips.fromPartial(object.conversationUpdateTips)
        : undefined;
    message.conversationSetPrivateTips =
      (object.conversationSetPrivateTips !== undefined && object.conversationSetPrivateTips !== null)
        ? ConversationSetPrivateTips.fromPartial(object.conversationSetPrivateTips)
        : undefined;
    message.conversationHasReadTips =
      (object.conversationHasReadTips !== undefined && object.conversationHasReadTips !== null)
        ? ConversationHasReadTips.fromPartial(object.conversationHasReadTips)
        : undefined;
    message.deleteMessageTips = (object.deleteMessageTips !== undefined && object.deleteMessageTips !== null)
      ? DeleteMessageTips.fromPartial(object.deleteMessageTips)
      : undefined;
    message.revokeMsgTips = (object.revokeMsgTips !== undefined && object.revokeMsgTips !== null)
      ? RevokeMsgTips.fromPartial(object.revokeMsgTips)
      : undefined;
    message.clearConversationTips =
      (object.clearConversationTips !== undefined && object.clearConversationTips !== null)
        ? ClearConversationTips.fromPartial(object.clearConversationTips)
        : undefined;
    message.deleteMsgsTips = (object.deleteMsgsTips !== undefined && object.deleteMsgsTips !== null)
      ? DeleteMsgsTips.fromPartial(object.deleteMsgsTips)
      : undefined;
    message.markAsReadTips = (object.markAsReadTips !== undefined && object.markAsReadTips !== null)
      ? MarkAsReadTips.fromPartial(object.markAsReadTips)
      : undefined;
    message.friendsInfoUpdateTips =
      (object.friendsInfoUpdateTips !== undefined && object.friendsInfoUpdateTips !== null)
        ? FriendsInfoUpdateTips.fromPartial(object.friendsInfoUpdateTips)
        : undefined;
    message.subUserOnlineStatusTips =
      (object.subUserOnlineStatusTips !== undefined && object.subUserOnlineStatusTips !== null)
        ? SubUserOnlineStatusTips.fromPartial(object.subUserOnlineStatusTips)
        : undefined;
    message.streamMsgTips = (object.streamMsgTips !== undefined && object.streamMsgTips !== null)
      ? StreamMsgTips.fromPartial(object.streamMsgTips)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
