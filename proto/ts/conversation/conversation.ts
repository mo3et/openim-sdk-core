// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v5.27.1
// source: conversation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Conversation, IMMessage } from "./shared";

export const protobufPackage = "openim.sdk.conversation";

export interface ConversationArgs {
  conversationID: string;
  clientMsgIDList: string[];
}

export interface FindMessageListCallback {
  totalCount: number;
  findResultItems: SearchByConversationResult[];
}

export interface SearchLocalMessagesParams {
  conversationID: string;
  keywordList: string[];
  keywordListMatchType: number;
  senderUserIDList: string[];
  messageTypeList: number[];
  searchTimePosition: number;
  searchTimePeriod: number;
  pageIndex: number;
  count: number;
}

export interface SearchLocalMessagesCallback {
  totalCount: number;
  searchResultItems: SearchByConversationResult[];
}

export interface SearchByConversationResult {
  conversationID: string;
  conversationType: number;
  showName: string;
  faceURL: string;
  latestMsgSendTime: number;
  messageCount: number;
  messageList: IMMessage[];
}

/** ----------------------------------------------------------------------------------------------------------------- */
export interface GetAllConversationListReq {
}

export interface GetAllConversationListResp {
  conversationList: Conversation[];
}

export interface GetConversationListSplitReq {
  offset: number;
  count: number;
}

export interface GetConversationListSplitResp {
  conversationList: Conversation[];
}

export interface HideConversationReq {
  conversationID: string;
}

export interface HideConversationResp {
}

export interface GetAtAllTagReq {
}

export interface GetAtAllTagResp {
  tag: string;
}

export interface GetOneConversationReq {
  sessionType: number;
  sourceID: string;
}

export interface GetOneConversationResp {
  conversation: Conversation | undefined;
}

export interface GetMultipleConversationReq {
  conversationIDList: string[];
}

export interface GetMultipleConversationResp {
  conversationList: Conversation[];
}

export interface HideAllConversationsReq {
}

export interface HideAllConversationsResp {
}

export interface SetConversationDraftReq {
  conversationID: string;
  draftText: string;
}

export interface SetConversationDraftResp {
}

export interface SetConversationReq {
  conversationID: string;
  recvMsgOpt?: number | undefined;
  groupAtType?: number | undefined;
  isPinned?: boolean | undefined;
  isPrivateChat?: boolean | undefined;
  burnDuration?: number | undefined;
  ex?: string | undefined;
  msgDestructTime?: number | undefined;
  isMsgDestruct?: boolean | undefined;
}

export interface SetConversationResp {
}

export interface GetTotalUnreadMsgCountReq {
}

export interface GetTotalUnreadMsgCountResp {
  totalUnreadCount: number;
}

export interface GetConversationIDBySessionTypeReq {
  sourceID: string;
  sessionType: number;
}

export interface GetConversationIDBySessionTypeResp {
  conversationID: string;
}

export interface FindMessageListReq {
  conversationsArgs: ConversationArgs[];
}

export interface FindMessageListResp {
  findResultItems: SearchByConversationResult[];
  totalCount: number;
}

export interface MarkConversationMessageAsReadReq {
  conversationID: string;
}

export interface MarkConversationMessageAsReadResp {
}

export interface MarkAllConversationMessageAsReadReq {
}

export interface MarkAllConversationMessageAsReadResp {
}

export interface DeleteMessageFromLocalStorageReq {
  conversationID: string;
  clientMsgID: string;
}

export interface DeleteMessageFromLocalStorageResp {
}

export interface ClearConversationAndDeleteAllMsgReq {
  conversationID: string;
}

export interface ClearConversationAndDeleteAllMsgResp {
}

export interface DeleteConversationAndDeleteAllMsgReq {
  conversationID: string;
}

export interface DeleteConversationAndDeleteAllMsgResp {
}

export interface SearchLocalMessagesReq {
  searchParam: SearchLocalMessagesParams | undefined;
}

export interface SearchLocalMessagesResp {
  searchResult: SearchLocalMessagesCallback | undefined;
}

export interface SetMessageLocalExReq {
  conversationID: string;
  clientMsgID: string;
  localEx: string;
}

export interface SetMessageLocalExResp {
  success: boolean;
}

export interface SearchConversationReq {
  searchParam: string;
}

export interface SearchConversationResp {
  conversationList: Conversation[];
}

function createBaseConversationArgs(): ConversationArgs {
  return { conversationID: "", clientMsgIDList: [] };
}

export const ConversationArgs: MessageFns<ConversationArgs> = {
  encode(message: ConversationArgs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    for (const v of message.clientMsgIDList) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationArgs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationArgs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientMsgIDList.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationArgs {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      clientMsgIDList: globalThis.Array.isArray(object?.clientMsgIDList)
        ? object.clientMsgIDList.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ConversationArgs): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.clientMsgIDList?.length) {
      obj.clientMsgIDList = message.clientMsgIDList;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationArgs>, I>>(base?: I): ConversationArgs {
    return ConversationArgs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationArgs>, I>>(object: I): ConversationArgs {
    const message = createBaseConversationArgs();
    message.conversationID = object.conversationID ?? "";
    message.clientMsgIDList = object.clientMsgIDList?.map((e) => e) || [];
    return message;
  },
};

function createBaseFindMessageListCallback(): FindMessageListCallback {
  return { totalCount: 0, findResultItems: [] };
}

export const FindMessageListCallback: MessageFns<FindMessageListCallback> = {
  encode(message: FindMessageListCallback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCount !== 0) {
      writer.uint32(8).int32(message.totalCount);
    }
    for (const v of message.findResultItems) {
      SearchByConversationResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindMessageListCallback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindMessageListCallback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.findResultItems.push(SearchByConversationResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindMessageListCallback {
    return {
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      findResultItems: globalThis.Array.isArray(object?.findResultItems)
        ? object.findResultItems.map((e: any) => SearchByConversationResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FindMessageListCallback): unknown {
    const obj: any = {};
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.findResultItems?.length) {
      obj.findResultItems = message.findResultItems.map((e) => SearchByConversationResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindMessageListCallback>, I>>(base?: I): FindMessageListCallback {
    return FindMessageListCallback.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindMessageListCallback>, I>>(object: I): FindMessageListCallback {
    const message = createBaseFindMessageListCallback();
    message.totalCount = object.totalCount ?? 0;
    message.findResultItems = object.findResultItems?.map((e) => SearchByConversationResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchLocalMessagesParams(): SearchLocalMessagesParams {
  return {
    conversationID: "",
    keywordList: [],
    keywordListMatchType: 0,
    senderUserIDList: [],
    messageTypeList: [],
    searchTimePosition: 0,
    searchTimePeriod: 0,
    pageIndex: 0,
    count: 0,
  };
}

export const SearchLocalMessagesParams: MessageFns<SearchLocalMessagesParams> = {
  encode(message: SearchLocalMessagesParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    for (const v of message.keywordList) {
      writer.uint32(18).string(v!);
    }
    if (message.keywordListMatchType !== 0) {
      writer.uint32(24).int32(message.keywordListMatchType);
    }
    for (const v of message.senderUserIDList) {
      writer.uint32(34).string(v!);
    }
    writer.uint32(42).fork();
    for (const v of message.messageTypeList) {
      writer.int32(v);
    }
    writer.join();
    if (message.searchTimePosition !== 0) {
      writer.uint32(48).int64(message.searchTimePosition);
    }
    if (message.searchTimePeriod !== 0) {
      writer.uint32(56).int64(message.searchTimePeriod);
    }
    if (message.pageIndex !== 0) {
      writer.uint32(64).int32(message.pageIndex);
    }
    if (message.count !== 0) {
      writer.uint32(72).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchLocalMessagesParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchLocalMessagesParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keywordList.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keywordListMatchType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.senderUserIDList.push(reader.string());
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.messageTypeList.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.messageTypeList.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.searchTimePosition = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.searchTimePeriod = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.pageIndex = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchLocalMessagesParams {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      keywordList: globalThis.Array.isArray(object?.keywordList)
        ? object.keywordList.map((e: any) => globalThis.String(e))
        : [],
      keywordListMatchType: isSet(object.keywordListMatchType) ? globalThis.Number(object.keywordListMatchType) : 0,
      senderUserIDList: globalThis.Array.isArray(object?.senderUserIDList)
        ? object.senderUserIDList.map((e: any) => globalThis.String(e))
        : [],
      messageTypeList: globalThis.Array.isArray(object?.messageTypeList)
        ? object.messageTypeList.map((e: any) => globalThis.Number(e))
        : [],
      searchTimePosition: isSet(object.searchTimePosition) ? globalThis.Number(object.searchTimePosition) : 0,
      searchTimePeriod: isSet(object.searchTimePeriod) ? globalThis.Number(object.searchTimePeriod) : 0,
      pageIndex: isSet(object.pageIndex) ? globalThis.Number(object.pageIndex) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: SearchLocalMessagesParams): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.keywordList?.length) {
      obj.keywordList = message.keywordList;
    }
    if (message.keywordListMatchType !== 0) {
      obj.keywordListMatchType = Math.round(message.keywordListMatchType);
    }
    if (message.senderUserIDList?.length) {
      obj.senderUserIDList = message.senderUserIDList;
    }
    if (message.messageTypeList?.length) {
      obj.messageTypeList = message.messageTypeList.map((e) => Math.round(e));
    }
    if (message.searchTimePosition !== 0) {
      obj.searchTimePosition = Math.round(message.searchTimePosition);
    }
    if (message.searchTimePeriod !== 0) {
      obj.searchTimePeriod = Math.round(message.searchTimePeriod);
    }
    if (message.pageIndex !== 0) {
      obj.pageIndex = Math.round(message.pageIndex);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchLocalMessagesParams>, I>>(base?: I): SearchLocalMessagesParams {
    return SearchLocalMessagesParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchLocalMessagesParams>, I>>(object: I): SearchLocalMessagesParams {
    const message = createBaseSearchLocalMessagesParams();
    message.conversationID = object.conversationID ?? "";
    message.keywordList = object.keywordList?.map((e) => e) || [];
    message.keywordListMatchType = object.keywordListMatchType ?? 0;
    message.senderUserIDList = object.senderUserIDList?.map((e) => e) || [];
    message.messageTypeList = object.messageTypeList?.map((e) => e) || [];
    message.searchTimePosition = object.searchTimePosition ?? 0;
    message.searchTimePeriod = object.searchTimePeriod ?? 0;
    message.pageIndex = object.pageIndex ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseSearchLocalMessagesCallback(): SearchLocalMessagesCallback {
  return { totalCount: 0, searchResultItems: [] };
}

export const SearchLocalMessagesCallback: MessageFns<SearchLocalMessagesCallback> = {
  encode(message: SearchLocalMessagesCallback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalCount !== 0) {
      writer.uint32(8).int32(message.totalCount);
    }
    for (const v of message.searchResultItems) {
      SearchByConversationResult.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchLocalMessagesCallback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchLocalMessagesCallback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searchResultItems.push(SearchByConversationResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchLocalMessagesCallback {
    return {
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      searchResultItems: globalThis.Array.isArray(object?.searchResultItems)
        ? object.searchResultItems.map((e: any) => SearchByConversationResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchLocalMessagesCallback): unknown {
    const obj: any = {};
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.searchResultItems?.length) {
      obj.searchResultItems = message.searchResultItems.map((e) => SearchByConversationResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchLocalMessagesCallback>, I>>(base?: I): SearchLocalMessagesCallback {
    return SearchLocalMessagesCallback.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchLocalMessagesCallback>, I>>(object: I): SearchLocalMessagesCallback {
    const message = createBaseSearchLocalMessagesCallback();
    message.totalCount = object.totalCount ?? 0;
    message.searchResultItems = object.searchResultItems?.map((e) => SearchByConversationResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchByConversationResult(): SearchByConversationResult {
  return {
    conversationID: "",
    conversationType: 0,
    showName: "",
    faceURL: "",
    latestMsgSendTime: 0,
    messageCount: 0,
    messageList: [],
  };
}

export const SearchByConversationResult: MessageFns<SearchByConversationResult> = {
  encode(message: SearchByConversationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.conversationType !== 0) {
      writer.uint32(16).int32(message.conversationType);
    }
    if (message.showName !== "") {
      writer.uint32(26).string(message.showName);
    }
    if (message.faceURL !== "") {
      writer.uint32(34).string(message.faceURL);
    }
    if (message.latestMsgSendTime !== 0) {
      writer.uint32(40).int64(message.latestMsgSendTime);
    }
    if (message.messageCount !== 0) {
      writer.uint32(48).int32(message.messageCount);
    }
    for (const v of message.messageList) {
      IMMessage.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchByConversationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchByConversationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.conversationType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.showName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.latestMsgSendTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.messageCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.messageList.push(IMMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchByConversationResult {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      conversationType: isSet(object.conversationType) ? globalThis.Number(object.conversationType) : 0,
      showName: isSet(object.showName) ? globalThis.String(object.showName) : "",
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : "",
      latestMsgSendTime: isSet(object.latestMsgSendTime) ? globalThis.Number(object.latestMsgSendTime) : 0,
      messageCount: isSet(object.messageCount) ? globalThis.Number(object.messageCount) : 0,
      messageList: globalThis.Array.isArray(object?.messageList)
        ? object.messageList.map((e: any) => IMMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchByConversationResult): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.conversationType !== 0) {
      obj.conversationType = Math.round(message.conversationType);
    }
    if (message.showName !== "") {
      obj.showName = message.showName;
    }
    if (message.faceURL !== "") {
      obj.faceURL = message.faceURL;
    }
    if (message.latestMsgSendTime !== 0) {
      obj.latestMsgSendTime = Math.round(message.latestMsgSendTime);
    }
    if (message.messageCount !== 0) {
      obj.messageCount = Math.round(message.messageCount);
    }
    if (message.messageList?.length) {
      obj.messageList = message.messageList.map((e) => IMMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchByConversationResult>, I>>(base?: I): SearchByConversationResult {
    return SearchByConversationResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchByConversationResult>, I>>(object: I): SearchByConversationResult {
    const message = createBaseSearchByConversationResult();
    message.conversationID = object.conversationID ?? "";
    message.conversationType = object.conversationType ?? 0;
    message.showName = object.showName ?? "";
    message.faceURL = object.faceURL ?? "";
    message.latestMsgSendTime = object.latestMsgSendTime ?? 0;
    message.messageCount = object.messageCount ?? 0;
    message.messageList = object.messageList?.map((e) => IMMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAllConversationListReq(): GetAllConversationListReq {
  return {};
}

export const GetAllConversationListReq: MessageFns<GetAllConversationListReq> = {
  encode(_: GetAllConversationListReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllConversationListReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllConversationListReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAllConversationListReq {
    return {};
  },

  toJSON(_: GetAllConversationListReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllConversationListReq>, I>>(base?: I): GetAllConversationListReq {
    return GetAllConversationListReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllConversationListReq>, I>>(_: I): GetAllConversationListReq {
    const message = createBaseGetAllConversationListReq();
    return message;
  },
};

function createBaseGetAllConversationListResp(): GetAllConversationListResp {
  return { conversationList: [] };
}

export const GetAllConversationListResp: MessageFns<GetAllConversationListResp> = {
  encode(message: GetAllConversationListResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversationList) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllConversationListResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllConversationListResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationList.push(Conversation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllConversationListResp {
    return {
      conversationList: globalThis.Array.isArray(object?.conversationList)
        ? object.conversationList.map((e: any) => Conversation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllConversationListResp): unknown {
    const obj: any = {};
    if (message.conversationList?.length) {
      obj.conversationList = message.conversationList.map((e) => Conversation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllConversationListResp>, I>>(base?: I): GetAllConversationListResp {
    return GetAllConversationListResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllConversationListResp>, I>>(object: I): GetAllConversationListResp {
    const message = createBaseGetAllConversationListResp();
    message.conversationList = object.conversationList?.map((e) => Conversation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetConversationListSplitReq(): GetConversationListSplitReq {
  return { offset: 0, count: 0 };
}

export const GetConversationListSplitReq: MessageFns<GetConversationListSplitReq> = {
  encode(message: GetConversationListSplitReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0) {
      writer.uint32(8).int32(message.offset);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConversationListSplitReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationListSplitReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationListSplitReq {
    return {
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: GetConversationListSplitReq): unknown {
    const obj: any = {};
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationListSplitReq>, I>>(base?: I): GetConversationListSplitReq {
    return GetConversationListSplitReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationListSplitReq>, I>>(object: I): GetConversationListSplitReq {
    const message = createBaseGetConversationListSplitReq();
    message.offset = object.offset ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseGetConversationListSplitResp(): GetConversationListSplitResp {
  return { conversationList: [] };
}

export const GetConversationListSplitResp: MessageFns<GetConversationListSplitResp> = {
  encode(message: GetConversationListSplitResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversationList) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConversationListSplitResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationListSplitResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationList.push(Conversation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationListSplitResp {
    return {
      conversationList: globalThis.Array.isArray(object?.conversationList)
        ? object.conversationList.map((e: any) => Conversation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetConversationListSplitResp): unknown {
    const obj: any = {};
    if (message.conversationList?.length) {
      obj.conversationList = message.conversationList.map((e) => Conversation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationListSplitResp>, I>>(base?: I): GetConversationListSplitResp {
    return GetConversationListSplitResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationListSplitResp>, I>>(object: I): GetConversationListSplitResp {
    const message = createBaseGetConversationListSplitResp();
    message.conversationList = object.conversationList?.map((e) => Conversation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHideConversationReq(): HideConversationReq {
  return { conversationID: "" };
}

export const HideConversationReq: MessageFns<HideConversationReq> = {
  encode(message: HideConversationReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HideConversationReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHideConversationReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HideConversationReq {
    return { conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "" };
  },

  toJSON(message: HideConversationReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HideConversationReq>, I>>(base?: I): HideConversationReq {
    return HideConversationReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HideConversationReq>, I>>(object: I): HideConversationReq {
    const message = createBaseHideConversationReq();
    message.conversationID = object.conversationID ?? "";
    return message;
  },
};

function createBaseHideConversationResp(): HideConversationResp {
  return {};
}

export const HideConversationResp: MessageFns<HideConversationResp> = {
  encode(_: HideConversationResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HideConversationResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHideConversationResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HideConversationResp {
    return {};
  },

  toJSON(_: HideConversationResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HideConversationResp>, I>>(base?: I): HideConversationResp {
    return HideConversationResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HideConversationResp>, I>>(_: I): HideConversationResp {
    const message = createBaseHideConversationResp();
    return message;
  },
};

function createBaseGetAtAllTagReq(): GetAtAllTagReq {
  return {};
}

export const GetAtAllTagReq: MessageFns<GetAtAllTagReq> = {
  encode(_: GetAtAllTagReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAtAllTagReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAtAllTagReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAtAllTagReq {
    return {};
  },

  toJSON(_: GetAtAllTagReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAtAllTagReq>, I>>(base?: I): GetAtAllTagReq {
    return GetAtAllTagReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAtAllTagReq>, I>>(_: I): GetAtAllTagReq {
    const message = createBaseGetAtAllTagReq();
    return message;
  },
};

function createBaseGetAtAllTagResp(): GetAtAllTagResp {
  return { tag: "" };
}

export const GetAtAllTagResp: MessageFns<GetAtAllTagResp> = {
  encode(message: GetAtAllTagResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAtAllTagResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAtAllTagResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAtAllTagResp {
    return { tag: isSet(object.tag) ? globalThis.String(object.tag) : "" };
  },

  toJSON(message: GetAtAllTagResp): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAtAllTagResp>, I>>(base?: I): GetAtAllTagResp {
    return GetAtAllTagResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAtAllTagResp>, I>>(object: I): GetAtAllTagResp {
    const message = createBaseGetAtAllTagResp();
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseGetOneConversationReq(): GetOneConversationReq {
  return { sessionType: 0, sourceID: "" };
}

export const GetOneConversationReq: MessageFns<GetOneConversationReq> = {
  encode(message: GetOneConversationReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionType !== 0) {
      writer.uint32(8).int32(message.sessionType);
    }
    if (message.sourceID !== "") {
      writer.uint32(18).string(message.sourceID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneConversationReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneConversationReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneConversationReq {
    return {
      sessionType: isSet(object.sessionType) ? globalThis.Number(object.sessionType) : 0,
      sourceID: isSet(object.sourceID) ? globalThis.String(object.sourceID) : "",
    };
  },

  toJSON(message: GetOneConversationReq): unknown {
    const obj: any = {};
    if (message.sessionType !== 0) {
      obj.sessionType = Math.round(message.sessionType);
    }
    if (message.sourceID !== "") {
      obj.sourceID = message.sourceID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOneConversationReq>, I>>(base?: I): GetOneConversationReq {
    return GetOneConversationReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOneConversationReq>, I>>(object: I): GetOneConversationReq {
    const message = createBaseGetOneConversationReq();
    message.sessionType = object.sessionType ?? 0;
    message.sourceID = object.sourceID ?? "";
    return message;
  },
};

function createBaseGetOneConversationResp(): GetOneConversationResp {
  return { conversation: undefined };
}

export const GetOneConversationResp: MessageFns<GetOneConversationResp> = {
  encode(message: GetOneConversationResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversation !== undefined) {
      Conversation.encode(message.conversation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOneConversationResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOneConversationResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversation = Conversation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOneConversationResp {
    return { conversation: isSet(object.conversation) ? Conversation.fromJSON(object.conversation) : undefined };
  },

  toJSON(message: GetOneConversationResp): unknown {
    const obj: any = {};
    if (message.conversation !== undefined) {
      obj.conversation = Conversation.toJSON(message.conversation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOneConversationResp>, I>>(base?: I): GetOneConversationResp {
    return GetOneConversationResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOneConversationResp>, I>>(object: I): GetOneConversationResp {
    const message = createBaseGetOneConversationResp();
    message.conversation = (object.conversation !== undefined && object.conversation !== null)
      ? Conversation.fromPartial(object.conversation)
      : undefined;
    return message;
  },
};

function createBaseGetMultipleConversationReq(): GetMultipleConversationReq {
  return { conversationIDList: [] };
}

export const GetMultipleConversationReq: MessageFns<GetMultipleConversationReq> = {
  encode(message: GetMultipleConversationReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversationIDList) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMultipleConversationReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMultipleConversationReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationIDList.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMultipleConversationReq {
    return {
      conversationIDList: globalThis.Array.isArray(object?.conversationIDList)
        ? object.conversationIDList.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetMultipleConversationReq): unknown {
    const obj: any = {};
    if (message.conversationIDList?.length) {
      obj.conversationIDList = message.conversationIDList;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMultipleConversationReq>, I>>(base?: I): GetMultipleConversationReq {
    return GetMultipleConversationReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMultipleConversationReq>, I>>(object: I): GetMultipleConversationReq {
    const message = createBaseGetMultipleConversationReq();
    message.conversationIDList = object.conversationIDList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetMultipleConversationResp(): GetMultipleConversationResp {
  return { conversationList: [] };
}

export const GetMultipleConversationResp: MessageFns<GetMultipleConversationResp> = {
  encode(message: GetMultipleConversationResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversationList) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMultipleConversationResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMultipleConversationResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationList.push(Conversation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMultipleConversationResp {
    return {
      conversationList: globalThis.Array.isArray(object?.conversationList)
        ? object.conversationList.map((e: any) => Conversation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetMultipleConversationResp): unknown {
    const obj: any = {};
    if (message.conversationList?.length) {
      obj.conversationList = message.conversationList.map((e) => Conversation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMultipleConversationResp>, I>>(base?: I): GetMultipleConversationResp {
    return GetMultipleConversationResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetMultipleConversationResp>, I>>(object: I): GetMultipleConversationResp {
    const message = createBaseGetMultipleConversationResp();
    message.conversationList = object.conversationList?.map((e) => Conversation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHideAllConversationsReq(): HideAllConversationsReq {
  return {};
}

export const HideAllConversationsReq: MessageFns<HideAllConversationsReq> = {
  encode(_: HideAllConversationsReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HideAllConversationsReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHideAllConversationsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HideAllConversationsReq {
    return {};
  },

  toJSON(_: HideAllConversationsReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HideAllConversationsReq>, I>>(base?: I): HideAllConversationsReq {
    return HideAllConversationsReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HideAllConversationsReq>, I>>(_: I): HideAllConversationsReq {
    const message = createBaseHideAllConversationsReq();
    return message;
  },
};

function createBaseHideAllConversationsResp(): HideAllConversationsResp {
  return {};
}

export const HideAllConversationsResp: MessageFns<HideAllConversationsResp> = {
  encode(_: HideAllConversationsResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HideAllConversationsResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHideAllConversationsResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HideAllConversationsResp {
    return {};
  },

  toJSON(_: HideAllConversationsResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HideAllConversationsResp>, I>>(base?: I): HideAllConversationsResp {
    return HideAllConversationsResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HideAllConversationsResp>, I>>(_: I): HideAllConversationsResp {
    const message = createBaseHideAllConversationsResp();
    return message;
  },
};

function createBaseSetConversationDraftReq(): SetConversationDraftReq {
  return { conversationID: "", draftText: "" };
}

export const SetConversationDraftReq: MessageFns<SetConversationDraftReq> = {
  encode(message: SetConversationDraftReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.draftText !== "") {
      writer.uint32(18).string(message.draftText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetConversationDraftReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetConversationDraftReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.draftText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetConversationDraftReq {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      draftText: isSet(object.draftText) ? globalThis.String(object.draftText) : "",
    };
  },

  toJSON(message: SetConversationDraftReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.draftText !== "") {
      obj.draftText = message.draftText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetConversationDraftReq>, I>>(base?: I): SetConversationDraftReq {
    return SetConversationDraftReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetConversationDraftReq>, I>>(object: I): SetConversationDraftReq {
    const message = createBaseSetConversationDraftReq();
    message.conversationID = object.conversationID ?? "";
    message.draftText = object.draftText ?? "";
    return message;
  },
};

function createBaseSetConversationDraftResp(): SetConversationDraftResp {
  return {};
}

export const SetConversationDraftResp: MessageFns<SetConversationDraftResp> = {
  encode(_: SetConversationDraftResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetConversationDraftResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetConversationDraftResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetConversationDraftResp {
    return {};
  },

  toJSON(_: SetConversationDraftResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetConversationDraftResp>, I>>(base?: I): SetConversationDraftResp {
    return SetConversationDraftResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetConversationDraftResp>, I>>(_: I): SetConversationDraftResp {
    const message = createBaseSetConversationDraftResp();
    return message;
  },
};

function createBaseSetConversationReq(): SetConversationReq {
  return {
    conversationID: "",
    recvMsgOpt: undefined,
    groupAtType: undefined,
    isPinned: undefined,
    isPrivateChat: undefined,
    burnDuration: undefined,
    ex: undefined,
    msgDestructTime: undefined,
    isMsgDestruct: undefined,
  };
}

export const SetConversationReq: MessageFns<SetConversationReq> = {
  encode(message: SetConversationReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.recvMsgOpt !== undefined) {
      writer.uint32(16).int32(message.recvMsgOpt);
    }
    if (message.groupAtType !== undefined) {
      writer.uint32(24).int32(message.groupAtType);
    }
    if (message.isPinned !== undefined) {
      writer.uint32(32).bool(message.isPinned);
    }
    if (message.isPrivateChat !== undefined) {
      writer.uint32(40).bool(message.isPrivateChat);
    }
    if (message.burnDuration !== undefined) {
      writer.uint32(48).int32(message.burnDuration);
    }
    if (message.ex !== undefined) {
      writer.uint32(58).string(message.ex);
    }
    if (message.msgDestructTime !== undefined) {
      writer.uint32(64).int64(message.msgDestructTime);
    }
    if (message.isMsgDestruct !== undefined) {
      writer.uint32(72).bool(message.isMsgDestruct);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetConversationReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetConversationReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.recvMsgOpt = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupAtType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isPinned = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isPrivateChat = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.burnDuration = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.msgDestructTime = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isMsgDestruct = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetConversationReq {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      recvMsgOpt: isSet(object.recvMsgOpt) ? globalThis.Number(object.recvMsgOpt) : undefined,
      groupAtType: isSet(object.groupAtType) ? globalThis.Number(object.groupAtType) : undefined,
      isPinned: isSet(object.isPinned) ? globalThis.Boolean(object.isPinned) : undefined,
      isPrivateChat: isSet(object.isPrivateChat) ? globalThis.Boolean(object.isPrivateChat) : undefined,
      burnDuration: isSet(object.burnDuration) ? globalThis.Number(object.burnDuration) : undefined,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : undefined,
      msgDestructTime: isSet(object.msgDestructTime) ? globalThis.Number(object.msgDestructTime) : undefined,
      isMsgDestruct: isSet(object.isMsgDestruct) ? globalThis.Boolean(object.isMsgDestruct) : undefined,
    };
  },

  toJSON(message: SetConversationReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.recvMsgOpt !== undefined) {
      obj.recvMsgOpt = Math.round(message.recvMsgOpt);
    }
    if (message.groupAtType !== undefined) {
      obj.groupAtType = Math.round(message.groupAtType);
    }
    if (message.isPinned !== undefined) {
      obj.isPinned = message.isPinned;
    }
    if (message.isPrivateChat !== undefined) {
      obj.isPrivateChat = message.isPrivateChat;
    }
    if (message.burnDuration !== undefined) {
      obj.burnDuration = Math.round(message.burnDuration);
    }
    if (message.ex !== undefined) {
      obj.ex = message.ex;
    }
    if (message.msgDestructTime !== undefined) {
      obj.msgDestructTime = Math.round(message.msgDestructTime);
    }
    if (message.isMsgDestruct !== undefined) {
      obj.isMsgDestruct = message.isMsgDestruct;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetConversationReq>, I>>(base?: I): SetConversationReq {
    return SetConversationReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetConversationReq>, I>>(object: I): SetConversationReq {
    const message = createBaseSetConversationReq();
    message.conversationID = object.conversationID ?? "";
    message.recvMsgOpt = object.recvMsgOpt ?? undefined;
    message.groupAtType = object.groupAtType ?? undefined;
    message.isPinned = object.isPinned ?? undefined;
    message.isPrivateChat = object.isPrivateChat ?? undefined;
    message.burnDuration = object.burnDuration ?? undefined;
    message.ex = object.ex ?? undefined;
    message.msgDestructTime = object.msgDestructTime ?? undefined;
    message.isMsgDestruct = object.isMsgDestruct ?? undefined;
    return message;
  },
};

function createBaseSetConversationResp(): SetConversationResp {
  return {};
}

export const SetConversationResp: MessageFns<SetConversationResp> = {
  encode(_: SetConversationResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetConversationResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetConversationResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetConversationResp {
    return {};
  },

  toJSON(_: SetConversationResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetConversationResp>, I>>(base?: I): SetConversationResp {
    return SetConversationResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetConversationResp>, I>>(_: I): SetConversationResp {
    const message = createBaseSetConversationResp();
    return message;
  },
};

function createBaseGetTotalUnreadMsgCountReq(): GetTotalUnreadMsgCountReq {
  return {};
}

export const GetTotalUnreadMsgCountReq: MessageFns<GetTotalUnreadMsgCountReq> = {
  encode(_: GetTotalUnreadMsgCountReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalUnreadMsgCountReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalUnreadMsgCountReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetTotalUnreadMsgCountReq {
    return {};
  },

  toJSON(_: GetTotalUnreadMsgCountReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTotalUnreadMsgCountReq>, I>>(base?: I): GetTotalUnreadMsgCountReq {
    return GetTotalUnreadMsgCountReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTotalUnreadMsgCountReq>, I>>(_: I): GetTotalUnreadMsgCountReq {
    const message = createBaseGetTotalUnreadMsgCountReq();
    return message;
  },
};

function createBaseGetTotalUnreadMsgCountResp(): GetTotalUnreadMsgCountResp {
  return { totalUnreadCount: 0 };
}

export const GetTotalUnreadMsgCountResp: MessageFns<GetTotalUnreadMsgCountResp> = {
  encode(message: GetTotalUnreadMsgCountResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalUnreadCount !== 0) {
      writer.uint32(8).int32(message.totalUnreadCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTotalUnreadMsgCountResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTotalUnreadMsgCountResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalUnreadCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTotalUnreadMsgCountResp {
    return { totalUnreadCount: isSet(object.totalUnreadCount) ? globalThis.Number(object.totalUnreadCount) : 0 };
  },

  toJSON(message: GetTotalUnreadMsgCountResp): unknown {
    const obj: any = {};
    if (message.totalUnreadCount !== 0) {
      obj.totalUnreadCount = Math.round(message.totalUnreadCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTotalUnreadMsgCountResp>, I>>(base?: I): GetTotalUnreadMsgCountResp {
    return GetTotalUnreadMsgCountResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTotalUnreadMsgCountResp>, I>>(object: I): GetTotalUnreadMsgCountResp {
    const message = createBaseGetTotalUnreadMsgCountResp();
    message.totalUnreadCount = object.totalUnreadCount ?? 0;
    return message;
  },
};

function createBaseGetConversationIDBySessionTypeReq(): GetConversationIDBySessionTypeReq {
  return { sourceID: "", sessionType: 0 };
}

export const GetConversationIDBySessionTypeReq: MessageFns<GetConversationIDBySessionTypeReq> = {
  encode(message: GetConversationIDBySessionTypeReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceID !== "") {
      writer.uint32(10).string(message.sourceID);
    }
    if (message.sessionType !== 0) {
      writer.uint32(16).int32(message.sessionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConversationIDBySessionTypeReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationIDBySessionTypeReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sessionType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationIDBySessionTypeReq {
    return {
      sourceID: isSet(object.sourceID) ? globalThis.String(object.sourceID) : "",
      sessionType: isSet(object.sessionType) ? globalThis.Number(object.sessionType) : 0,
    };
  },

  toJSON(message: GetConversationIDBySessionTypeReq): unknown {
    const obj: any = {};
    if (message.sourceID !== "") {
      obj.sourceID = message.sourceID;
    }
    if (message.sessionType !== 0) {
      obj.sessionType = Math.round(message.sessionType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationIDBySessionTypeReq>, I>>(
    base?: I,
  ): GetConversationIDBySessionTypeReq {
    return GetConversationIDBySessionTypeReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationIDBySessionTypeReq>, I>>(
    object: I,
  ): GetConversationIDBySessionTypeReq {
    const message = createBaseGetConversationIDBySessionTypeReq();
    message.sourceID = object.sourceID ?? "";
    message.sessionType = object.sessionType ?? 0;
    return message;
  },
};

function createBaseGetConversationIDBySessionTypeResp(): GetConversationIDBySessionTypeResp {
  return { conversationID: "" };
}

export const GetConversationIDBySessionTypeResp: MessageFns<GetConversationIDBySessionTypeResp> = {
  encode(message: GetConversationIDBySessionTypeResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConversationIDBySessionTypeResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConversationIDBySessionTypeResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConversationIDBySessionTypeResp {
    return { conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "" };
  },

  toJSON(message: GetConversationIDBySessionTypeResp): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConversationIDBySessionTypeResp>, I>>(
    base?: I,
  ): GetConversationIDBySessionTypeResp {
    return GetConversationIDBySessionTypeResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConversationIDBySessionTypeResp>, I>>(
    object: I,
  ): GetConversationIDBySessionTypeResp {
    const message = createBaseGetConversationIDBySessionTypeResp();
    message.conversationID = object.conversationID ?? "";
    return message;
  },
};

function createBaseFindMessageListReq(): FindMessageListReq {
  return { conversationsArgs: [] };
}

export const FindMessageListReq: MessageFns<FindMessageListReq> = {
  encode(message: FindMessageListReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversationsArgs) {
      ConversationArgs.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindMessageListReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindMessageListReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationsArgs.push(ConversationArgs.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindMessageListReq {
    return {
      conversationsArgs: globalThis.Array.isArray(object?.conversationsArgs)
        ? object.conversationsArgs.map((e: any) => ConversationArgs.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FindMessageListReq): unknown {
    const obj: any = {};
    if (message.conversationsArgs?.length) {
      obj.conversationsArgs = message.conversationsArgs.map((e) => ConversationArgs.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindMessageListReq>, I>>(base?: I): FindMessageListReq {
    return FindMessageListReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindMessageListReq>, I>>(object: I): FindMessageListReq {
    const message = createBaseFindMessageListReq();
    message.conversationsArgs = object.conversationsArgs?.map((e) => ConversationArgs.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFindMessageListResp(): FindMessageListResp {
  return { findResultItems: [], totalCount: 0 };
}

export const FindMessageListResp: MessageFns<FindMessageListResp> = {
  encode(message: FindMessageListResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.findResultItems) {
      SearchByConversationResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindMessageListResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindMessageListResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.findResultItems.push(SearchByConversationResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindMessageListResp {
    return {
      findResultItems: globalThis.Array.isArray(object?.findResultItems)
        ? object.findResultItems.map((e: any) => SearchByConversationResult.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: FindMessageListResp): unknown {
    const obj: any = {};
    if (message.findResultItems?.length) {
      obj.findResultItems = message.findResultItems.map((e) => SearchByConversationResult.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindMessageListResp>, I>>(base?: I): FindMessageListResp {
    return FindMessageListResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindMessageListResp>, I>>(object: I): FindMessageListResp {
    const message = createBaseFindMessageListResp();
    message.findResultItems = object.findResultItems?.map((e) => SearchByConversationResult.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseMarkConversationMessageAsReadReq(): MarkConversationMessageAsReadReq {
  return { conversationID: "" };
}

export const MarkConversationMessageAsReadReq: MessageFns<MarkConversationMessageAsReadReq> = {
  encode(message: MarkConversationMessageAsReadReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkConversationMessageAsReadReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkConversationMessageAsReadReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkConversationMessageAsReadReq {
    return { conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "" };
  },

  toJSON(message: MarkConversationMessageAsReadReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkConversationMessageAsReadReq>, I>>(
    base?: I,
  ): MarkConversationMessageAsReadReq {
    return MarkConversationMessageAsReadReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkConversationMessageAsReadReq>, I>>(
    object: I,
  ): MarkConversationMessageAsReadReq {
    const message = createBaseMarkConversationMessageAsReadReq();
    message.conversationID = object.conversationID ?? "";
    return message;
  },
};

function createBaseMarkConversationMessageAsReadResp(): MarkConversationMessageAsReadResp {
  return {};
}

export const MarkConversationMessageAsReadResp: MessageFns<MarkConversationMessageAsReadResp> = {
  encode(_: MarkConversationMessageAsReadResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkConversationMessageAsReadResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkConversationMessageAsReadResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MarkConversationMessageAsReadResp {
    return {};
  },

  toJSON(_: MarkConversationMessageAsReadResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkConversationMessageAsReadResp>, I>>(
    base?: I,
  ): MarkConversationMessageAsReadResp {
    return MarkConversationMessageAsReadResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkConversationMessageAsReadResp>, I>>(
    _: I,
  ): MarkConversationMessageAsReadResp {
    const message = createBaseMarkConversationMessageAsReadResp();
    return message;
  },
};

function createBaseMarkAllConversationMessageAsReadReq(): MarkAllConversationMessageAsReadReq {
  return {};
}

export const MarkAllConversationMessageAsReadReq: MessageFns<MarkAllConversationMessageAsReadReq> = {
  encode(_: MarkAllConversationMessageAsReadReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkAllConversationMessageAsReadReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkAllConversationMessageAsReadReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MarkAllConversationMessageAsReadReq {
    return {};
  },

  toJSON(_: MarkAllConversationMessageAsReadReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkAllConversationMessageAsReadReq>, I>>(
    base?: I,
  ): MarkAllConversationMessageAsReadReq {
    return MarkAllConversationMessageAsReadReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkAllConversationMessageAsReadReq>, I>>(
    _: I,
  ): MarkAllConversationMessageAsReadReq {
    const message = createBaseMarkAllConversationMessageAsReadReq();
    return message;
  },
};

function createBaseMarkAllConversationMessageAsReadResp(): MarkAllConversationMessageAsReadResp {
  return {};
}

export const MarkAllConversationMessageAsReadResp: MessageFns<MarkAllConversationMessageAsReadResp> = {
  encode(_: MarkAllConversationMessageAsReadResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkAllConversationMessageAsReadResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkAllConversationMessageAsReadResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MarkAllConversationMessageAsReadResp {
    return {};
  },

  toJSON(_: MarkAllConversationMessageAsReadResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkAllConversationMessageAsReadResp>, I>>(
    base?: I,
  ): MarkAllConversationMessageAsReadResp {
    return MarkAllConversationMessageAsReadResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkAllConversationMessageAsReadResp>, I>>(
    _: I,
  ): MarkAllConversationMessageAsReadResp {
    const message = createBaseMarkAllConversationMessageAsReadResp();
    return message;
  },
};

function createBaseDeleteMessageFromLocalStorageReq(): DeleteMessageFromLocalStorageReq {
  return { conversationID: "", clientMsgID: "" };
}

export const DeleteMessageFromLocalStorageReq: MessageFns<DeleteMessageFromLocalStorageReq> = {
  encode(message: DeleteMessageFromLocalStorageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.clientMsgID !== "") {
      writer.uint32(18).string(message.clientMsgID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageFromLocalStorageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageFromLocalStorageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientMsgID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMessageFromLocalStorageReq {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      clientMsgID: isSet(object.clientMsgID) ? globalThis.String(object.clientMsgID) : "",
    };
  },

  toJSON(message: DeleteMessageFromLocalStorageReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.clientMsgID !== "") {
      obj.clientMsgID = message.clientMsgID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageFromLocalStorageReq>, I>>(
    base?: I,
  ): DeleteMessageFromLocalStorageReq {
    return DeleteMessageFromLocalStorageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageFromLocalStorageReq>, I>>(
    object: I,
  ): DeleteMessageFromLocalStorageReq {
    const message = createBaseDeleteMessageFromLocalStorageReq();
    message.conversationID = object.conversationID ?? "";
    message.clientMsgID = object.clientMsgID ?? "";
    return message;
  },
};

function createBaseDeleteMessageFromLocalStorageResp(): DeleteMessageFromLocalStorageResp {
  return {};
}

export const DeleteMessageFromLocalStorageResp: MessageFns<DeleteMessageFromLocalStorageResp> = {
  encode(_: DeleteMessageFromLocalStorageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageFromLocalStorageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageFromLocalStorageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteMessageFromLocalStorageResp {
    return {};
  },

  toJSON(_: DeleteMessageFromLocalStorageResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageFromLocalStorageResp>, I>>(
    base?: I,
  ): DeleteMessageFromLocalStorageResp {
    return DeleteMessageFromLocalStorageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageFromLocalStorageResp>, I>>(
    _: I,
  ): DeleteMessageFromLocalStorageResp {
    const message = createBaseDeleteMessageFromLocalStorageResp();
    return message;
  },
};

function createBaseClearConversationAndDeleteAllMsgReq(): ClearConversationAndDeleteAllMsgReq {
  return { conversationID: "" };
}

export const ClearConversationAndDeleteAllMsgReq: MessageFns<ClearConversationAndDeleteAllMsgReq> = {
  encode(message: ClearConversationAndDeleteAllMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearConversationAndDeleteAllMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearConversationAndDeleteAllMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClearConversationAndDeleteAllMsgReq {
    return { conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "" };
  },

  toJSON(message: ClearConversationAndDeleteAllMsgReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearConversationAndDeleteAllMsgReq>, I>>(
    base?: I,
  ): ClearConversationAndDeleteAllMsgReq {
    return ClearConversationAndDeleteAllMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearConversationAndDeleteAllMsgReq>, I>>(
    object: I,
  ): ClearConversationAndDeleteAllMsgReq {
    const message = createBaseClearConversationAndDeleteAllMsgReq();
    message.conversationID = object.conversationID ?? "";
    return message;
  },
};

function createBaseClearConversationAndDeleteAllMsgResp(): ClearConversationAndDeleteAllMsgResp {
  return {};
}

export const ClearConversationAndDeleteAllMsgResp: MessageFns<ClearConversationAndDeleteAllMsgResp> = {
  encode(_: ClearConversationAndDeleteAllMsgResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClearConversationAndDeleteAllMsgResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearConversationAndDeleteAllMsgResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ClearConversationAndDeleteAllMsgResp {
    return {};
  },

  toJSON(_: ClearConversationAndDeleteAllMsgResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearConversationAndDeleteAllMsgResp>, I>>(
    base?: I,
  ): ClearConversationAndDeleteAllMsgResp {
    return ClearConversationAndDeleteAllMsgResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearConversationAndDeleteAllMsgResp>, I>>(
    _: I,
  ): ClearConversationAndDeleteAllMsgResp {
    const message = createBaseClearConversationAndDeleteAllMsgResp();
    return message;
  },
};

function createBaseDeleteConversationAndDeleteAllMsgReq(): DeleteConversationAndDeleteAllMsgReq {
  return { conversationID: "" };
}

export const DeleteConversationAndDeleteAllMsgReq: MessageFns<DeleteConversationAndDeleteAllMsgReq> = {
  encode(message: DeleteConversationAndDeleteAllMsgReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConversationAndDeleteAllMsgReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationAndDeleteAllMsgReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConversationAndDeleteAllMsgReq {
    return { conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "" };
  },

  toJSON(message: DeleteConversationAndDeleteAllMsgReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConversationAndDeleteAllMsgReq>, I>>(
    base?: I,
  ): DeleteConversationAndDeleteAllMsgReq {
    return DeleteConversationAndDeleteAllMsgReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConversationAndDeleteAllMsgReq>, I>>(
    object: I,
  ): DeleteConversationAndDeleteAllMsgReq {
    const message = createBaseDeleteConversationAndDeleteAllMsgReq();
    message.conversationID = object.conversationID ?? "";
    return message;
  },
};

function createBaseDeleteConversationAndDeleteAllMsgResp(): DeleteConversationAndDeleteAllMsgResp {
  return {};
}

export const DeleteConversationAndDeleteAllMsgResp: MessageFns<DeleteConversationAndDeleteAllMsgResp> = {
  encode(_: DeleteConversationAndDeleteAllMsgResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConversationAndDeleteAllMsgResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConversationAndDeleteAllMsgResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteConversationAndDeleteAllMsgResp {
    return {};
  },

  toJSON(_: DeleteConversationAndDeleteAllMsgResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConversationAndDeleteAllMsgResp>, I>>(
    base?: I,
  ): DeleteConversationAndDeleteAllMsgResp {
    return DeleteConversationAndDeleteAllMsgResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConversationAndDeleteAllMsgResp>, I>>(
    _: I,
  ): DeleteConversationAndDeleteAllMsgResp {
    const message = createBaseDeleteConversationAndDeleteAllMsgResp();
    return message;
  },
};

function createBaseSearchLocalMessagesReq(): SearchLocalMessagesReq {
  return { searchParam: undefined };
}

export const SearchLocalMessagesReq: MessageFns<SearchLocalMessagesReq> = {
  encode(message: SearchLocalMessagesReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchParam !== undefined) {
      SearchLocalMessagesParams.encode(message.searchParam, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchLocalMessagesReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchLocalMessagesReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searchParam = SearchLocalMessagesParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchLocalMessagesReq {
    return {
      searchParam: isSet(object.searchParam) ? SearchLocalMessagesParams.fromJSON(object.searchParam) : undefined,
    };
  },

  toJSON(message: SearchLocalMessagesReq): unknown {
    const obj: any = {};
    if (message.searchParam !== undefined) {
      obj.searchParam = SearchLocalMessagesParams.toJSON(message.searchParam);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchLocalMessagesReq>, I>>(base?: I): SearchLocalMessagesReq {
    return SearchLocalMessagesReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchLocalMessagesReq>, I>>(object: I): SearchLocalMessagesReq {
    const message = createBaseSearchLocalMessagesReq();
    message.searchParam = (object.searchParam !== undefined && object.searchParam !== null)
      ? SearchLocalMessagesParams.fromPartial(object.searchParam)
      : undefined;
    return message;
  },
};

function createBaseSearchLocalMessagesResp(): SearchLocalMessagesResp {
  return { searchResult: undefined };
}

export const SearchLocalMessagesResp: MessageFns<SearchLocalMessagesResp> = {
  encode(message: SearchLocalMessagesResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchResult !== undefined) {
      SearchLocalMessagesCallback.encode(message.searchResult, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchLocalMessagesResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchLocalMessagesResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searchResult = SearchLocalMessagesCallback.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchLocalMessagesResp {
    return {
      searchResult: isSet(object.searchResult) ? SearchLocalMessagesCallback.fromJSON(object.searchResult) : undefined,
    };
  },

  toJSON(message: SearchLocalMessagesResp): unknown {
    const obj: any = {};
    if (message.searchResult !== undefined) {
      obj.searchResult = SearchLocalMessagesCallback.toJSON(message.searchResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchLocalMessagesResp>, I>>(base?: I): SearchLocalMessagesResp {
    return SearchLocalMessagesResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchLocalMessagesResp>, I>>(object: I): SearchLocalMessagesResp {
    const message = createBaseSearchLocalMessagesResp();
    message.searchResult = (object.searchResult !== undefined && object.searchResult !== null)
      ? SearchLocalMessagesCallback.fromPartial(object.searchResult)
      : undefined;
    return message;
  },
};

function createBaseSetMessageLocalExReq(): SetMessageLocalExReq {
  return { conversationID: "", clientMsgID: "", localEx: "" };
}

export const SetMessageLocalExReq: MessageFns<SetMessageLocalExReq> = {
  encode(message: SetMessageLocalExReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.clientMsgID !== "") {
      writer.uint32(18).string(message.clientMsgID);
    }
    if (message.localEx !== "") {
      writer.uint32(26).string(message.localEx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetMessageLocalExReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMessageLocalExReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientMsgID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.localEx = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMessageLocalExReq {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      clientMsgID: isSet(object.clientMsgID) ? globalThis.String(object.clientMsgID) : "",
      localEx: isSet(object.localEx) ? globalThis.String(object.localEx) : "",
    };
  },

  toJSON(message: SetMessageLocalExReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.clientMsgID !== "") {
      obj.clientMsgID = message.clientMsgID;
    }
    if (message.localEx !== "") {
      obj.localEx = message.localEx;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetMessageLocalExReq>, I>>(base?: I): SetMessageLocalExReq {
    return SetMessageLocalExReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetMessageLocalExReq>, I>>(object: I): SetMessageLocalExReq {
    const message = createBaseSetMessageLocalExReq();
    message.conversationID = object.conversationID ?? "";
    message.clientMsgID = object.clientMsgID ?? "";
    message.localEx = object.localEx ?? "";
    return message;
  },
};

function createBaseSetMessageLocalExResp(): SetMessageLocalExResp {
  return { success: false };
}

export const SetMessageLocalExResp: MessageFns<SetMessageLocalExResp> = {
  encode(message: SetMessageLocalExResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetMessageLocalExResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMessageLocalExResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMessageLocalExResp {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: SetMessageLocalExResp): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetMessageLocalExResp>, I>>(base?: I): SetMessageLocalExResp {
    return SetMessageLocalExResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetMessageLocalExResp>, I>>(object: I): SetMessageLocalExResp {
    const message = createBaseSetMessageLocalExResp();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseSearchConversationReq(): SearchConversationReq {
  return { searchParam: "" };
}

export const SearchConversationReq: MessageFns<SearchConversationReq> = {
  encode(message: SearchConversationReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchParam !== "") {
      writer.uint32(10).string(message.searchParam);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchConversationReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchConversationReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.searchParam = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchConversationReq {
    return { searchParam: isSet(object.searchParam) ? globalThis.String(object.searchParam) : "" };
  },

  toJSON(message: SearchConversationReq): unknown {
    const obj: any = {};
    if (message.searchParam !== "") {
      obj.searchParam = message.searchParam;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchConversationReq>, I>>(base?: I): SearchConversationReq {
    return SearchConversationReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchConversationReq>, I>>(object: I): SearchConversationReq {
    const message = createBaseSearchConversationReq();
    message.searchParam = object.searchParam ?? "";
    return message;
  },
};

function createBaseSearchConversationResp(): SearchConversationResp {
  return { conversationList: [] };
}

export const SearchConversationResp: MessageFns<SearchConversationResp> = {
  encode(message: SearchConversationResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversationList) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchConversationResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchConversationResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationList.push(Conversation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchConversationResp {
    return {
      conversationList: globalThis.Array.isArray(object?.conversationList)
        ? object.conversationList.map((e: any) => Conversation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchConversationResp): unknown {
    const obj: any = {};
    if (message.conversationList?.length) {
      obj.conversationList = message.conversationList.map((e) => Conversation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchConversationResp>, I>>(base?: I): SearchConversationResp {
    return SearchConversationResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchConversationResp>, I>>(object: I): SearchConversationResp {
    const message = createBaseSearchConversationResp();
    message.conversationList = object.conversationList?.map((e) => Conversation.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
