// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v5.27.1
// source: message.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { OfflinePushInfo } from "./common";
import {
  AtInfo,
  CardElem,
  FileBaseInfo,
  IMMessage,
  MessageEntity,
  PictureBaseInfo,
  SoundBaseInfo,
  VideoBaseInfo,
} from "./shared";

export const protobufPackage = "openim.sdk.message";

export interface GetAdvancedHistoryMessageListParams {
  conversationID: string;
  startClientMsgID: string;
  count: number;
}

export interface GetAdvancedHistoryMessageListCallback {
  messageList: IMMessage[];
  isEnd: boolean;
  errCode: number;
  errMsg: string;
}

/** ------------------------------------------------------------------------------------------------------ */
export interface SendMessageReq {
  message: IMMessage | undefined;
  recvID: string;
  groupID: string;
  offlinePushInfo: OfflinePushInfo | undefined;
  isOnlineOnly: boolean;
}

export interface SendMessageResp {
  message: IMMessage | undefined;
}

export interface GetAdvancedHistoryMessageListReq {
  conversationID: string;
  getAdvancedHistoryMessageListParams: GetAdvancedHistoryMessageListParams | undefined;
}

export interface GetAdvancedHistoryMessageListResp {
  getAdvancedHistoryMessageListCallback: GetAdvancedHistoryMessageListCallback | undefined;
}

export interface GetAdvancedHistoryMessageListReverseReq {
  conversationID: string;
  getAdvancedHistoryMessageListParams: GetAdvancedHistoryMessageListParams | undefined;
}

export interface GetAdvancedHistoryMessageListReverseResp {
  getAdvancedHistoryMessageListCallback: GetAdvancedHistoryMessageListCallback | undefined;
}

export interface RevokeMessageReq {
  conversationID: string;
  clientMsgID: string;
}

export interface RevokeMessageResp {
}

export interface TypingStatusUpdateReq {
  recvID: string;
  msgTip: string;
}

export interface TypingStatusUpdateResp {
}

export interface DeleteMessageReq {
  conversationID: string;
  clientMsgID: string;
}

export interface DeleteMessageResp {
}

export interface DeleteAllMsgFromLocalAndServerReq {
}

export interface DeleteAllMsgFromLocalAndServerResp {
}

export interface DeleteAllMessageFromLocalStorageReq {
}

export interface DeleteAllMessageFromLocalStorageResp {
}

export interface InsertSingleMessageToLocalStorageReq {
  msg: IMMessage | undefined;
  recvID: string;
  sendID: string;
}

export interface InsertSingleMessageToLocalStorageResp {
  msg: IMMessage | undefined;
}

export interface InsertGroupMessageToLocalStorageReq {
  msg: IMMessage | undefined;
  groupID: string;
  sendID: string;
}

export interface InsertGroupMessageToLocalStorageResp {
  msg: IMMessage | undefined;
}

export interface CreateTextMessageReq {
  text: string;
}

export interface CreateTextMessageResp {
  message: IMMessage | undefined;
}

export interface CreateAdvancedTextMessageReq {
  text: string;
  messageEntities: MessageEntity[];
}

export interface CreateAdvancedTextMessageResp {
  message: IMMessage | undefined;
}

export interface CreateTextAtMessageReq {
  text: string;
  userIDList: string[];
  usersInfo: AtInfo[];
  quoteMessage: IMMessage | undefined;
}

export interface CreateTextAtMessageResp {
  message: IMMessage | undefined;
}

export interface CreateLocationMessageReq {
  description: string;
  longitude: number;
  latitude: number;
}

export interface CreateLocationMessageResp {
  message: IMMessage | undefined;
}

export interface CreateCustomMessageReq {
  data: string;
  extension: string;
  description: string;
}

export interface CreateCustomMessageResp {
  message: IMMessage | undefined;
}

export interface CreateQuoteMessageReq {
  text: string;
  quoteMessage: IMMessage | undefined;
}

export interface CreateQuoteMessageResp {
  message: IMMessage | undefined;
}

export interface CreateAdvancedQuoteMessageReq {
  text: string;
  quoteMessage: IMMessage | undefined;
  messageEntities: MessageEntity[];
}

export interface CreateAdvancedQuoteMessageResp {
  message: IMMessage | undefined;
}

export interface CreateCardMessageReq {
  card: CardElem | undefined;
}

export interface CreateCardMessageResp {
  message: IMMessage | undefined;
}

export interface CreateImageMessageReq {
  imageSourcePath: string;
  sourcePicture: PictureBaseInfo | undefined;
  bigPicture: PictureBaseInfo | undefined;
  snapshotPicture: PictureBaseInfo | undefined;
}

export interface CreateImageMessageResp {
  message: IMMessage | undefined;
}

export interface CreateSoundMessageReq {
  soundPath: string;
  duration: number;
  soundElem: SoundBaseInfo | undefined;
}

export interface CreateSoundMessageResp {
  message: IMMessage | undefined;
}

export interface CreateVideoMessageReq {
  videoSourcePath: string;
  videoType: string;
  duration: number;
  snapshotSourcePath: string;
  videoElem: VideoBaseInfo | undefined;
}

export interface CreateVideoMessageResp {
  message: IMMessage | undefined;
}

export interface CreateFileMessageReq {
  fileSourcePath: string;
  fileName: string;
  fileElem: FileBaseInfo | undefined;
}

export interface CreateFileMessageResp {
  message: IMMessage | undefined;
}

export interface CreateMergerMessageReq {
  messages: IMMessage[];
  title: string;
  summaries: string[];
}

export interface CreateMergerMessageResp {
  message: IMMessage | undefined;
}

export interface CreateFaceMessageReq {
  index: number;
  data: string;
}

export interface CreateFaceMessageResp {
  message: IMMessage | undefined;
}

export interface CreateForwardMessageReq {
  message: IMMessage | undefined;
}

export interface CreateForwardMessageResp {
  message: IMMessage | undefined;
}

function createBaseGetAdvancedHistoryMessageListParams(): GetAdvancedHistoryMessageListParams {
  return { conversationID: "", startClientMsgID: "", count: 0 };
}

export const GetAdvancedHistoryMessageListParams: MessageFns<GetAdvancedHistoryMessageListParams> = {
  encode(message: GetAdvancedHistoryMessageListParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.startClientMsgID !== "") {
      writer.uint32(18).string(message.startClientMsgID);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAdvancedHistoryMessageListParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAdvancedHistoryMessageListParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startClientMsgID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAdvancedHistoryMessageListParams {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      startClientMsgID: isSet(object.startClientMsgID) ? globalThis.String(object.startClientMsgID) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: GetAdvancedHistoryMessageListParams): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.startClientMsgID !== "") {
      obj.startClientMsgID = message.startClientMsgID;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListParams>, I>>(
    base?: I,
  ): GetAdvancedHistoryMessageListParams {
    return GetAdvancedHistoryMessageListParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListParams>, I>>(
    object: I,
  ): GetAdvancedHistoryMessageListParams {
    const message = createBaseGetAdvancedHistoryMessageListParams();
    message.conversationID = object.conversationID ?? "";
    message.startClientMsgID = object.startClientMsgID ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseGetAdvancedHistoryMessageListCallback(): GetAdvancedHistoryMessageListCallback {
  return { messageList: [], isEnd: false, errCode: 0, errMsg: "" };
}

export const GetAdvancedHistoryMessageListCallback: MessageFns<GetAdvancedHistoryMessageListCallback> = {
  encode(message: GetAdvancedHistoryMessageListCallback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messageList) {
      IMMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.isEnd !== false) {
      writer.uint32(16).bool(message.isEnd);
    }
    if (message.errCode !== 0) {
      writer.uint32(24).int32(message.errCode);
    }
    if (message.errMsg !== "") {
      writer.uint32(34).string(message.errMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAdvancedHistoryMessageListCallback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAdvancedHistoryMessageListCallback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageList.push(IMMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isEnd = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.errCode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errMsg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAdvancedHistoryMessageListCallback {
    return {
      messageList: globalThis.Array.isArray(object?.messageList)
        ? object.messageList.map((e: any) => IMMessage.fromJSON(e))
        : [],
      isEnd: isSet(object.isEnd) ? globalThis.Boolean(object.isEnd) : false,
      errCode: isSet(object.errCode) ? globalThis.Number(object.errCode) : 0,
      errMsg: isSet(object.errMsg) ? globalThis.String(object.errMsg) : "",
    };
  },

  toJSON(message: GetAdvancedHistoryMessageListCallback): unknown {
    const obj: any = {};
    if (message.messageList?.length) {
      obj.messageList = message.messageList.map((e) => IMMessage.toJSON(e));
    }
    if (message.isEnd !== false) {
      obj.isEnd = message.isEnd;
    }
    if (message.errCode !== 0) {
      obj.errCode = Math.round(message.errCode);
    }
    if (message.errMsg !== "") {
      obj.errMsg = message.errMsg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListCallback>, I>>(
    base?: I,
  ): GetAdvancedHistoryMessageListCallback {
    return GetAdvancedHistoryMessageListCallback.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListCallback>, I>>(
    object: I,
  ): GetAdvancedHistoryMessageListCallback {
    const message = createBaseGetAdvancedHistoryMessageListCallback();
    message.messageList = object.messageList?.map((e) => IMMessage.fromPartial(e)) || [];
    message.isEnd = object.isEnd ?? false;
    message.errCode = object.errCode ?? 0;
    message.errMsg = object.errMsg ?? "";
    return message;
  },
};

function createBaseSendMessageReq(): SendMessageReq {
  return { message: undefined, recvID: "", groupID: "", offlinePushInfo: undefined, isOnlineOnly: false };
}

export const SendMessageReq: MessageFns<SendMessageReq> = {
  encode(message: SendMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    if (message.recvID !== "") {
      writer.uint32(18).string(message.recvID);
    }
    if (message.groupID !== "") {
      writer.uint32(26).string(message.groupID);
    }
    if (message.offlinePushInfo !== undefined) {
      OfflinePushInfo.encode(message.offlinePushInfo, writer.uint32(34).fork()).join();
    }
    if (message.isOnlineOnly !== false) {
      writer.uint32(40).bool(message.isOnlineOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recvID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.offlinePushInfo = OfflinePushInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isOnlineOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageReq {
    return {
      message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined,
      recvID: isSet(object.recvID) ? globalThis.String(object.recvID) : "",
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      offlinePushInfo: isSet(object.offlinePushInfo) ? OfflinePushInfo.fromJSON(object.offlinePushInfo) : undefined,
      isOnlineOnly: isSet(object.isOnlineOnly) ? globalThis.Boolean(object.isOnlineOnly) : false,
    };
  },

  toJSON(message: SendMessageReq): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    if (message.recvID !== "") {
      obj.recvID = message.recvID;
    }
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.offlinePushInfo !== undefined) {
      obj.offlinePushInfo = OfflinePushInfo.toJSON(message.offlinePushInfo);
    }
    if (message.isOnlineOnly !== false) {
      obj.isOnlineOnly = message.isOnlineOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageReq>, I>>(base?: I): SendMessageReq {
    return SendMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageReq>, I>>(object: I): SendMessageReq {
    const message = createBaseSendMessageReq();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    message.recvID = object.recvID ?? "";
    message.groupID = object.groupID ?? "";
    message.offlinePushInfo = (object.offlinePushInfo !== undefined && object.offlinePushInfo !== null)
      ? OfflinePushInfo.fromPartial(object.offlinePushInfo)
      : undefined;
    message.isOnlineOnly = object.isOnlineOnly ?? false;
    return message;
  },
};

function createBaseSendMessageResp(): SendMessageResp {
  return { message: undefined };
}

export const SendMessageResp: MessageFns<SendMessageResp> = {
  encode(message: SendMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: SendMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageResp>, I>>(base?: I): SendMessageResp {
    return SendMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageResp>, I>>(object: I): SendMessageResp {
    const message = createBaseSendMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseGetAdvancedHistoryMessageListReq(): GetAdvancedHistoryMessageListReq {
  return { conversationID: "", getAdvancedHistoryMessageListParams: undefined };
}

export const GetAdvancedHistoryMessageListReq: MessageFns<GetAdvancedHistoryMessageListReq> = {
  encode(message: GetAdvancedHistoryMessageListReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.getAdvancedHistoryMessageListParams !== undefined) {
      GetAdvancedHistoryMessageListParams.encode(message.getAdvancedHistoryMessageListParams, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAdvancedHistoryMessageListReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAdvancedHistoryMessageListReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.getAdvancedHistoryMessageListParams = GetAdvancedHistoryMessageListParams.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAdvancedHistoryMessageListReq {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      getAdvancedHistoryMessageListParams: isSet(object.getAdvancedHistoryMessageListParams)
        ? GetAdvancedHistoryMessageListParams.fromJSON(object.getAdvancedHistoryMessageListParams)
        : undefined,
    };
  },

  toJSON(message: GetAdvancedHistoryMessageListReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.getAdvancedHistoryMessageListParams !== undefined) {
      obj.getAdvancedHistoryMessageListParams = GetAdvancedHistoryMessageListParams.toJSON(
        message.getAdvancedHistoryMessageListParams,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListReq>, I>>(
    base?: I,
  ): GetAdvancedHistoryMessageListReq {
    return GetAdvancedHistoryMessageListReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListReq>, I>>(
    object: I,
  ): GetAdvancedHistoryMessageListReq {
    const message = createBaseGetAdvancedHistoryMessageListReq();
    message.conversationID = object.conversationID ?? "";
    message.getAdvancedHistoryMessageListParams =
      (object.getAdvancedHistoryMessageListParams !== undefined && object.getAdvancedHistoryMessageListParams !== null)
        ? GetAdvancedHistoryMessageListParams.fromPartial(object.getAdvancedHistoryMessageListParams)
        : undefined;
    return message;
  },
};

function createBaseGetAdvancedHistoryMessageListResp(): GetAdvancedHistoryMessageListResp {
  return { getAdvancedHistoryMessageListCallback: undefined };
}

export const GetAdvancedHistoryMessageListResp: MessageFns<GetAdvancedHistoryMessageListResp> = {
  encode(message: GetAdvancedHistoryMessageListResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.getAdvancedHistoryMessageListCallback !== undefined) {
      GetAdvancedHistoryMessageListCallback.encode(
        message.getAdvancedHistoryMessageListCallback,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAdvancedHistoryMessageListResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAdvancedHistoryMessageListResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.getAdvancedHistoryMessageListCallback = GetAdvancedHistoryMessageListCallback.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAdvancedHistoryMessageListResp {
    return {
      getAdvancedHistoryMessageListCallback: isSet(object.getAdvancedHistoryMessageListCallback)
        ? GetAdvancedHistoryMessageListCallback.fromJSON(object.getAdvancedHistoryMessageListCallback)
        : undefined,
    };
  },

  toJSON(message: GetAdvancedHistoryMessageListResp): unknown {
    const obj: any = {};
    if (message.getAdvancedHistoryMessageListCallback !== undefined) {
      obj.getAdvancedHistoryMessageListCallback = GetAdvancedHistoryMessageListCallback.toJSON(
        message.getAdvancedHistoryMessageListCallback,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListResp>, I>>(
    base?: I,
  ): GetAdvancedHistoryMessageListResp {
    return GetAdvancedHistoryMessageListResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListResp>, I>>(
    object: I,
  ): GetAdvancedHistoryMessageListResp {
    const message = createBaseGetAdvancedHistoryMessageListResp();
    message.getAdvancedHistoryMessageListCallback =
      (object.getAdvancedHistoryMessageListCallback !== undefined &&
          object.getAdvancedHistoryMessageListCallback !== null)
        ? GetAdvancedHistoryMessageListCallback.fromPartial(object.getAdvancedHistoryMessageListCallback)
        : undefined;
    return message;
  },
};

function createBaseGetAdvancedHistoryMessageListReverseReq(): GetAdvancedHistoryMessageListReverseReq {
  return { conversationID: "", getAdvancedHistoryMessageListParams: undefined };
}

export const GetAdvancedHistoryMessageListReverseReq: MessageFns<GetAdvancedHistoryMessageListReverseReq> = {
  encode(message: GetAdvancedHistoryMessageListReverseReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.getAdvancedHistoryMessageListParams !== undefined) {
      GetAdvancedHistoryMessageListParams.encode(message.getAdvancedHistoryMessageListParams, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAdvancedHistoryMessageListReverseReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAdvancedHistoryMessageListReverseReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.getAdvancedHistoryMessageListParams = GetAdvancedHistoryMessageListParams.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAdvancedHistoryMessageListReverseReq {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      getAdvancedHistoryMessageListParams: isSet(object.getAdvancedHistoryMessageListParams)
        ? GetAdvancedHistoryMessageListParams.fromJSON(object.getAdvancedHistoryMessageListParams)
        : undefined,
    };
  },

  toJSON(message: GetAdvancedHistoryMessageListReverseReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.getAdvancedHistoryMessageListParams !== undefined) {
      obj.getAdvancedHistoryMessageListParams = GetAdvancedHistoryMessageListParams.toJSON(
        message.getAdvancedHistoryMessageListParams,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListReverseReq>, I>>(
    base?: I,
  ): GetAdvancedHistoryMessageListReverseReq {
    return GetAdvancedHistoryMessageListReverseReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListReverseReq>, I>>(
    object: I,
  ): GetAdvancedHistoryMessageListReverseReq {
    const message = createBaseGetAdvancedHistoryMessageListReverseReq();
    message.conversationID = object.conversationID ?? "";
    message.getAdvancedHistoryMessageListParams =
      (object.getAdvancedHistoryMessageListParams !== undefined && object.getAdvancedHistoryMessageListParams !== null)
        ? GetAdvancedHistoryMessageListParams.fromPartial(object.getAdvancedHistoryMessageListParams)
        : undefined;
    return message;
  },
};

function createBaseGetAdvancedHistoryMessageListReverseResp(): GetAdvancedHistoryMessageListReverseResp {
  return { getAdvancedHistoryMessageListCallback: undefined };
}

export const GetAdvancedHistoryMessageListReverseResp: MessageFns<GetAdvancedHistoryMessageListReverseResp> = {
  encode(message: GetAdvancedHistoryMessageListReverseResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.getAdvancedHistoryMessageListCallback !== undefined) {
      GetAdvancedHistoryMessageListCallback.encode(
        message.getAdvancedHistoryMessageListCallback,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAdvancedHistoryMessageListReverseResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAdvancedHistoryMessageListReverseResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.getAdvancedHistoryMessageListCallback = GetAdvancedHistoryMessageListCallback.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAdvancedHistoryMessageListReverseResp {
    return {
      getAdvancedHistoryMessageListCallback: isSet(object.getAdvancedHistoryMessageListCallback)
        ? GetAdvancedHistoryMessageListCallback.fromJSON(object.getAdvancedHistoryMessageListCallback)
        : undefined,
    };
  },

  toJSON(message: GetAdvancedHistoryMessageListReverseResp): unknown {
    const obj: any = {};
    if (message.getAdvancedHistoryMessageListCallback !== undefined) {
      obj.getAdvancedHistoryMessageListCallback = GetAdvancedHistoryMessageListCallback.toJSON(
        message.getAdvancedHistoryMessageListCallback,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListReverseResp>, I>>(
    base?: I,
  ): GetAdvancedHistoryMessageListReverseResp {
    return GetAdvancedHistoryMessageListReverseResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAdvancedHistoryMessageListReverseResp>, I>>(
    object: I,
  ): GetAdvancedHistoryMessageListReverseResp {
    const message = createBaseGetAdvancedHistoryMessageListReverseResp();
    message.getAdvancedHistoryMessageListCallback =
      (object.getAdvancedHistoryMessageListCallback !== undefined &&
          object.getAdvancedHistoryMessageListCallback !== null)
        ? GetAdvancedHistoryMessageListCallback.fromPartial(object.getAdvancedHistoryMessageListCallback)
        : undefined;
    return message;
  },
};

function createBaseRevokeMessageReq(): RevokeMessageReq {
  return { conversationID: "", clientMsgID: "" };
}

export const RevokeMessageReq: MessageFns<RevokeMessageReq> = {
  encode(message: RevokeMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.clientMsgID !== "") {
      writer.uint32(18).string(message.clientMsgID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientMsgID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeMessageReq {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      clientMsgID: isSet(object.clientMsgID) ? globalThis.String(object.clientMsgID) : "",
    };
  },

  toJSON(message: RevokeMessageReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.clientMsgID !== "") {
      obj.clientMsgID = message.clientMsgID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeMessageReq>, I>>(base?: I): RevokeMessageReq {
    return RevokeMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeMessageReq>, I>>(object: I): RevokeMessageReq {
    const message = createBaseRevokeMessageReq();
    message.conversationID = object.conversationID ?? "";
    message.clientMsgID = object.clientMsgID ?? "";
    return message;
  },
};

function createBaseRevokeMessageResp(): RevokeMessageResp {
  return {};
}

export const RevokeMessageResp: MessageFns<RevokeMessageResp> = {
  encode(_: RevokeMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RevokeMessageResp {
    return {};
  },

  toJSON(_: RevokeMessageResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeMessageResp>, I>>(base?: I): RevokeMessageResp {
    return RevokeMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeMessageResp>, I>>(_: I): RevokeMessageResp {
    const message = createBaseRevokeMessageResp();
    return message;
  },
};

function createBaseTypingStatusUpdateReq(): TypingStatusUpdateReq {
  return { recvID: "", msgTip: "" };
}

export const TypingStatusUpdateReq: MessageFns<TypingStatusUpdateReq> = {
  encode(message: TypingStatusUpdateReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recvID !== "") {
      writer.uint32(10).string(message.recvID);
    }
    if (message.msgTip !== "") {
      writer.uint32(18).string(message.msgTip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypingStatusUpdateReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypingStatusUpdateReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recvID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.msgTip = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypingStatusUpdateReq {
    return {
      recvID: isSet(object.recvID) ? globalThis.String(object.recvID) : "",
      msgTip: isSet(object.msgTip) ? globalThis.String(object.msgTip) : "",
    };
  },

  toJSON(message: TypingStatusUpdateReq): unknown {
    const obj: any = {};
    if (message.recvID !== "") {
      obj.recvID = message.recvID;
    }
    if (message.msgTip !== "") {
      obj.msgTip = message.msgTip;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypingStatusUpdateReq>, I>>(base?: I): TypingStatusUpdateReq {
    return TypingStatusUpdateReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypingStatusUpdateReq>, I>>(object: I): TypingStatusUpdateReq {
    const message = createBaseTypingStatusUpdateReq();
    message.recvID = object.recvID ?? "";
    message.msgTip = object.msgTip ?? "";
    return message;
  },
};

function createBaseTypingStatusUpdateResp(): TypingStatusUpdateResp {
  return {};
}

export const TypingStatusUpdateResp: MessageFns<TypingStatusUpdateResp> = {
  encode(_: TypingStatusUpdateResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypingStatusUpdateResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypingStatusUpdateResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TypingStatusUpdateResp {
    return {};
  },

  toJSON(_: TypingStatusUpdateResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TypingStatusUpdateResp>, I>>(base?: I): TypingStatusUpdateResp {
    return TypingStatusUpdateResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypingStatusUpdateResp>, I>>(_: I): TypingStatusUpdateResp {
    const message = createBaseTypingStatusUpdateResp();
    return message;
  },
};

function createBaseDeleteMessageReq(): DeleteMessageReq {
  return { conversationID: "", clientMsgID: "" };
}

export const DeleteMessageReq: MessageFns<DeleteMessageReq> = {
  encode(message: DeleteMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationID !== "") {
      writer.uint32(10).string(message.conversationID);
    }
    if (message.clientMsgID !== "") {
      writer.uint32(18).string(message.clientMsgID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientMsgID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMessageReq {
    return {
      conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
      clientMsgID: isSet(object.clientMsgID) ? globalThis.String(object.clientMsgID) : "",
    };
  },

  toJSON(message: DeleteMessageReq): unknown {
    const obj: any = {};
    if (message.conversationID !== "") {
      obj.conversationID = message.conversationID;
    }
    if (message.clientMsgID !== "") {
      obj.clientMsgID = message.clientMsgID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageReq>, I>>(base?: I): DeleteMessageReq {
    return DeleteMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageReq>, I>>(object: I): DeleteMessageReq {
    const message = createBaseDeleteMessageReq();
    message.conversationID = object.conversationID ?? "";
    message.clientMsgID = object.clientMsgID ?? "";
    return message;
  },
};

function createBaseDeleteMessageResp(): DeleteMessageResp {
  return {};
}

export const DeleteMessageResp: MessageFns<DeleteMessageResp> = {
  encode(_: DeleteMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteMessageResp {
    return {};
  },

  toJSON(_: DeleteMessageResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteMessageResp>, I>>(base?: I): DeleteMessageResp {
    return DeleteMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteMessageResp>, I>>(_: I): DeleteMessageResp {
    const message = createBaseDeleteMessageResp();
    return message;
  },
};

function createBaseDeleteAllMsgFromLocalAndServerReq(): DeleteAllMsgFromLocalAndServerReq {
  return {};
}

export const DeleteAllMsgFromLocalAndServerReq: MessageFns<DeleteAllMsgFromLocalAndServerReq> = {
  encode(_: DeleteAllMsgFromLocalAndServerReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAllMsgFromLocalAndServerReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAllMsgFromLocalAndServerReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteAllMsgFromLocalAndServerReq {
    return {};
  },

  toJSON(_: DeleteAllMsgFromLocalAndServerReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAllMsgFromLocalAndServerReq>, I>>(
    base?: I,
  ): DeleteAllMsgFromLocalAndServerReq {
    return DeleteAllMsgFromLocalAndServerReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAllMsgFromLocalAndServerReq>, I>>(
    _: I,
  ): DeleteAllMsgFromLocalAndServerReq {
    const message = createBaseDeleteAllMsgFromLocalAndServerReq();
    return message;
  },
};

function createBaseDeleteAllMsgFromLocalAndServerResp(): DeleteAllMsgFromLocalAndServerResp {
  return {};
}

export const DeleteAllMsgFromLocalAndServerResp: MessageFns<DeleteAllMsgFromLocalAndServerResp> = {
  encode(_: DeleteAllMsgFromLocalAndServerResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAllMsgFromLocalAndServerResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAllMsgFromLocalAndServerResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteAllMsgFromLocalAndServerResp {
    return {};
  },

  toJSON(_: DeleteAllMsgFromLocalAndServerResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAllMsgFromLocalAndServerResp>, I>>(
    base?: I,
  ): DeleteAllMsgFromLocalAndServerResp {
    return DeleteAllMsgFromLocalAndServerResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAllMsgFromLocalAndServerResp>, I>>(
    _: I,
  ): DeleteAllMsgFromLocalAndServerResp {
    const message = createBaseDeleteAllMsgFromLocalAndServerResp();
    return message;
  },
};

function createBaseDeleteAllMessageFromLocalStorageReq(): DeleteAllMessageFromLocalStorageReq {
  return {};
}

export const DeleteAllMessageFromLocalStorageReq: MessageFns<DeleteAllMessageFromLocalStorageReq> = {
  encode(_: DeleteAllMessageFromLocalStorageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAllMessageFromLocalStorageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAllMessageFromLocalStorageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteAllMessageFromLocalStorageReq {
    return {};
  },

  toJSON(_: DeleteAllMessageFromLocalStorageReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAllMessageFromLocalStorageReq>, I>>(
    base?: I,
  ): DeleteAllMessageFromLocalStorageReq {
    return DeleteAllMessageFromLocalStorageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAllMessageFromLocalStorageReq>, I>>(
    _: I,
  ): DeleteAllMessageFromLocalStorageReq {
    const message = createBaseDeleteAllMessageFromLocalStorageReq();
    return message;
  },
};

function createBaseDeleteAllMessageFromLocalStorageResp(): DeleteAllMessageFromLocalStorageResp {
  return {};
}

export const DeleteAllMessageFromLocalStorageResp: MessageFns<DeleteAllMessageFromLocalStorageResp> = {
  encode(_: DeleteAllMessageFromLocalStorageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAllMessageFromLocalStorageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAllMessageFromLocalStorageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteAllMessageFromLocalStorageResp {
    return {};
  },

  toJSON(_: DeleteAllMessageFromLocalStorageResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteAllMessageFromLocalStorageResp>, I>>(
    base?: I,
  ): DeleteAllMessageFromLocalStorageResp {
    return DeleteAllMessageFromLocalStorageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteAllMessageFromLocalStorageResp>, I>>(
    _: I,
  ): DeleteAllMessageFromLocalStorageResp {
    const message = createBaseDeleteAllMessageFromLocalStorageResp();
    return message;
  },
};

function createBaseInsertSingleMessageToLocalStorageReq(): InsertSingleMessageToLocalStorageReq {
  return { msg: undefined, recvID: "", sendID: "" };
}

export const InsertSingleMessageToLocalStorageReq: MessageFns<InsertSingleMessageToLocalStorageReq> = {
  encode(message: InsertSingleMessageToLocalStorageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== undefined) {
      IMMessage.encode(message.msg, writer.uint32(10).fork()).join();
    }
    if (message.recvID !== "") {
      writer.uint32(18).string(message.recvID);
    }
    if (message.sendID !== "") {
      writer.uint32(26).string(message.sendID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertSingleMessageToLocalStorageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertSingleMessageToLocalStorageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msg = IMMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recvID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sendID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertSingleMessageToLocalStorageReq {
    return {
      msg: isSet(object.msg) ? IMMessage.fromJSON(object.msg) : undefined,
      recvID: isSet(object.recvID) ? globalThis.String(object.recvID) : "",
      sendID: isSet(object.sendID) ? globalThis.String(object.sendID) : "",
    };
  },

  toJSON(message: InsertSingleMessageToLocalStorageReq): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = IMMessage.toJSON(message.msg);
    }
    if (message.recvID !== "") {
      obj.recvID = message.recvID;
    }
    if (message.sendID !== "") {
      obj.sendID = message.sendID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertSingleMessageToLocalStorageReq>, I>>(
    base?: I,
  ): InsertSingleMessageToLocalStorageReq {
    return InsertSingleMessageToLocalStorageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertSingleMessageToLocalStorageReq>, I>>(
    object: I,
  ): InsertSingleMessageToLocalStorageReq {
    const message = createBaseInsertSingleMessageToLocalStorageReq();
    message.msg = (object.msg !== undefined && object.msg !== null) ? IMMessage.fromPartial(object.msg) : undefined;
    message.recvID = object.recvID ?? "";
    message.sendID = object.sendID ?? "";
    return message;
  },
};

function createBaseInsertSingleMessageToLocalStorageResp(): InsertSingleMessageToLocalStorageResp {
  return { msg: undefined };
}

export const InsertSingleMessageToLocalStorageResp: MessageFns<InsertSingleMessageToLocalStorageResp> = {
  encode(message: InsertSingleMessageToLocalStorageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== undefined) {
      IMMessage.encode(message.msg, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertSingleMessageToLocalStorageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertSingleMessageToLocalStorageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msg = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertSingleMessageToLocalStorageResp {
    return { msg: isSet(object.msg) ? IMMessage.fromJSON(object.msg) : undefined };
  },

  toJSON(message: InsertSingleMessageToLocalStorageResp): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = IMMessage.toJSON(message.msg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertSingleMessageToLocalStorageResp>, I>>(
    base?: I,
  ): InsertSingleMessageToLocalStorageResp {
    return InsertSingleMessageToLocalStorageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertSingleMessageToLocalStorageResp>, I>>(
    object: I,
  ): InsertSingleMessageToLocalStorageResp {
    const message = createBaseInsertSingleMessageToLocalStorageResp();
    message.msg = (object.msg !== undefined && object.msg !== null) ? IMMessage.fromPartial(object.msg) : undefined;
    return message;
  },
};

function createBaseInsertGroupMessageToLocalStorageReq(): InsertGroupMessageToLocalStorageReq {
  return { msg: undefined, groupID: "", sendID: "" };
}

export const InsertGroupMessageToLocalStorageReq: MessageFns<InsertGroupMessageToLocalStorageReq> = {
  encode(message: InsertGroupMessageToLocalStorageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== undefined) {
      IMMessage.encode(message.msg, writer.uint32(10).fork()).join();
    }
    if (message.groupID !== "") {
      writer.uint32(18).string(message.groupID);
    }
    if (message.sendID !== "") {
      writer.uint32(26).string(message.sendID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertGroupMessageToLocalStorageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertGroupMessageToLocalStorageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msg = IMMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sendID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertGroupMessageToLocalStorageReq {
    return {
      msg: isSet(object.msg) ? IMMessage.fromJSON(object.msg) : undefined,
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      sendID: isSet(object.sendID) ? globalThis.String(object.sendID) : "",
    };
  },

  toJSON(message: InsertGroupMessageToLocalStorageReq): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = IMMessage.toJSON(message.msg);
    }
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.sendID !== "") {
      obj.sendID = message.sendID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertGroupMessageToLocalStorageReq>, I>>(
    base?: I,
  ): InsertGroupMessageToLocalStorageReq {
    return InsertGroupMessageToLocalStorageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertGroupMessageToLocalStorageReq>, I>>(
    object: I,
  ): InsertGroupMessageToLocalStorageReq {
    const message = createBaseInsertGroupMessageToLocalStorageReq();
    message.msg = (object.msg !== undefined && object.msg !== null) ? IMMessage.fromPartial(object.msg) : undefined;
    message.groupID = object.groupID ?? "";
    message.sendID = object.sendID ?? "";
    return message;
  },
};

function createBaseInsertGroupMessageToLocalStorageResp(): InsertGroupMessageToLocalStorageResp {
  return { msg: undefined };
}

export const InsertGroupMessageToLocalStorageResp: MessageFns<InsertGroupMessageToLocalStorageResp> = {
  encode(message: InsertGroupMessageToLocalStorageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== undefined) {
      IMMessage.encode(message.msg, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertGroupMessageToLocalStorageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertGroupMessageToLocalStorageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msg = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertGroupMessageToLocalStorageResp {
    return { msg: isSet(object.msg) ? IMMessage.fromJSON(object.msg) : undefined };
  },

  toJSON(message: InsertGroupMessageToLocalStorageResp): unknown {
    const obj: any = {};
    if (message.msg !== undefined) {
      obj.msg = IMMessage.toJSON(message.msg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertGroupMessageToLocalStorageResp>, I>>(
    base?: I,
  ): InsertGroupMessageToLocalStorageResp {
    return InsertGroupMessageToLocalStorageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertGroupMessageToLocalStorageResp>, I>>(
    object: I,
  ): InsertGroupMessageToLocalStorageResp {
    const message = createBaseInsertGroupMessageToLocalStorageResp();
    message.msg = (object.msg !== undefined && object.msg !== null) ? IMMessage.fromPartial(object.msg) : undefined;
    return message;
  },
};

function createBaseCreateTextMessageReq(): CreateTextMessageReq {
  return { text: "" };
}

export const CreateTextMessageReq: MessageFns<CreateTextMessageReq> = {
  encode(message: CreateTextMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTextMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTextMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTextMessageReq {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: CreateTextMessageReq): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTextMessageReq>, I>>(base?: I): CreateTextMessageReq {
    return CreateTextMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTextMessageReq>, I>>(object: I): CreateTextMessageReq {
    const message = createBaseCreateTextMessageReq();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseCreateTextMessageResp(): CreateTextMessageResp {
  return { message: undefined };
}

export const CreateTextMessageResp: MessageFns<CreateTextMessageResp> = {
  encode(message: CreateTextMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTextMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTextMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTextMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateTextMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTextMessageResp>, I>>(base?: I): CreateTextMessageResp {
    return CreateTextMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTextMessageResp>, I>>(object: I): CreateTextMessageResp {
    const message = createBaseCreateTextMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateAdvancedTextMessageReq(): CreateAdvancedTextMessageReq {
  return { text: "", messageEntities: [] };
}

export const CreateAdvancedTextMessageReq: MessageFns<CreateAdvancedTextMessageReq> = {
  encode(message: CreateAdvancedTextMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.messageEntities) {
      MessageEntity.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAdvancedTextMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAdvancedTextMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageEntities.push(MessageEntity.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAdvancedTextMessageReq {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      messageEntities: globalThis.Array.isArray(object?.messageEntities)
        ? object.messageEntities.map((e: any) => MessageEntity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateAdvancedTextMessageReq): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.messageEntities?.length) {
      obj.messageEntities = message.messageEntities.map((e) => MessageEntity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAdvancedTextMessageReq>, I>>(base?: I): CreateAdvancedTextMessageReq {
    return CreateAdvancedTextMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAdvancedTextMessageReq>, I>>(object: I): CreateAdvancedTextMessageReq {
    const message = createBaseCreateAdvancedTextMessageReq();
    message.text = object.text ?? "";
    message.messageEntities = object.messageEntities?.map((e) => MessageEntity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateAdvancedTextMessageResp(): CreateAdvancedTextMessageResp {
  return { message: undefined };
}

export const CreateAdvancedTextMessageResp: MessageFns<CreateAdvancedTextMessageResp> = {
  encode(message: CreateAdvancedTextMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAdvancedTextMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAdvancedTextMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAdvancedTextMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateAdvancedTextMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAdvancedTextMessageResp>, I>>(base?: I): CreateAdvancedTextMessageResp {
    return CreateAdvancedTextMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAdvancedTextMessageResp>, I>>(
    object: I,
  ): CreateAdvancedTextMessageResp {
    const message = createBaseCreateAdvancedTextMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateTextAtMessageReq(): CreateTextAtMessageReq {
  return { text: "", userIDList: [], usersInfo: [], quoteMessage: undefined };
}

export const CreateTextAtMessageReq: MessageFns<CreateTextAtMessageReq> = {
  encode(message: CreateTextAtMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.userIDList) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.usersInfo) {
      AtInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.quoteMessage !== undefined) {
      IMMessage.encode(message.quoteMessage, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTextAtMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTextAtMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userIDList.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.usersInfo.push(AtInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.quoteMessage = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTextAtMessageReq {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      userIDList: globalThis.Array.isArray(object?.userIDList)
        ? object.userIDList.map((e: any) => globalThis.String(e))
        : [],
      usersInfo: globalThis.Array.isArray(object?.usersInfo)
        ? object.usersInfo.map((e: any) => AtInfo.fromJSON(e))
        : [],
      quoteMessage: isSet(object.quoteMessage) ? IMMessage.fromJSON(object.quoteMessage) : undefined,
    };
  },

  toJSON(message: CreateTextAtMessageReq): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.userIDList?.length) {
      obj.userIDList = message.userIDList;
    }
    if (message.usersInfo?.length) {
      obj.usersInfo = message.usersInfo.map((e) => AtInfo.toJSON(e));
    }
    if (message.quoteMessage !== undefined) {
      obj.quoteMessage = IMMessage.toJSON(message.quoteMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTextAtMessageReq>, I>>(base?: I): CreateTextAtMessageReq {
    return CreateTextAtMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTextAtMessageReq>, I>>(object: I): CreateTextAtMessageReq {
    const message = createBaseCreateTextAtMessageReq();
    message.text = object.text ?? "";
    message.userIDList = object.userIDList?.map((e) => e) || [];
    message.usersInfo = object.usersInfo?.map((e) => AtInfo.fromPartial(e)) || [];
    message.quoteMessage = (object.quoteMessage !== undefined && object.quoteMessage !== null)
      ? IMMessage.fromPartial(object.quoteMessage)
      : undefined;
    return message;
  },
};

function createBaseCreateTextAtMessageResp(): CreateTextAtMessageResp {
  return { message: undefined };
}

export const CreateTextAtMessageResp: MessageFns<CreateTextAtMessageResp> = {
  encode(message: CreateTextAtMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTextAtMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTextAtMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTextAtMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateTextAtMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTextAtMessageResp>, I>>(base?: I): CreateTextAtMessageResp {
    return CreateTextAtMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTextAtMessageResp>, I>>(object: I): CreateTextAtMessageResp {
    const message = createBaseCreateTextAtMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateLocationMessageReq(): CreateLocationMessageReq {
  return { description: "", longitude: 0, latitude: 0 };
}

export const CreateLocationMessageReq: MessageFns<CreateLocationMessageReq> = {
  encode(message: CreateLocationMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    if (message.latitude !== 0) {
      writer.uint32(25).double(message.latitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateLocationMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLocationMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.latitude = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateLocationMessageReq {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
    };
  },

  toJSON(message: CreateLocationMessageReq): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateLocationMessageReq>, I>>(base?: I): CreateLocationMessageReq {
    return CreateLocationMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateLocationMessageReq>, I>>(object: I): CreateLocationMessageReq {
    const message = createBaseCreateLocationMessageReq();
    message.description = object.description ?? "";
    message.longitude = object.longitude ?? 0;
    message.latitude = object.latitude ?? 0;
    return message;
  },
};

function createBaseCreateLocationMessageResp(): CreateLocationMessageResp {
  return { message: undefined };
}

export const CreateLocationMessageResp: MessageFns<CreateLocationMessageResp> = {
  encode(message: CreateLocationMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateLocationMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLocationMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateLocationMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateLocationMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateLocationMessageResp>, I>>(base?: I): CreateLocationMessageResp {
    return CreateLocationMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateLocationMessageResp>, I>>(object: I): CreateLocationMessageResp {
    const message = createBaseCreateLocationMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateCustomMessageReq(): CreateCustomMessageReq {
  return { data: "", extension: "", description: "" };
}

export const CreateCustomMessageReq: MessageFns<CreateCustomMessageReq> = {
  encode(message: CreateCustomMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    if (message.extension !== "") {
      writer.uint32(18).string(message.extension);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCustomMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.extension = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomMessageReq {
    return {
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      extension: isSet(object.extension) ? globalThis.String(object.extension) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: CreateCustomMessageReq): unknown {
    const obj: any = {};
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.extension !== "") {
      obj.extension = message.extension;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustomMessageReq>, I>>(base?: I): CreateCustomMessageReq {
    return CreateCustomMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustomMessageReq>, I>>(object: I): CreateCustomMessageReq {
    const message = createBaseCreateCustomMessageReq();
    message.data = object.data ?? "";
    message.extension = object.extension ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCreateCustomMessageResp(): CreateCustomMessageResp {
  return { message: undefined };
}

export const CreateCustomMessageResp: MessageFns<CreateCustomMessageResp> = {
  encode(message: CreateCustomMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCustomMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateCustomMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustomMessageResp>, I>>(base?: I): CreateCustomMessageResp {
    return CreateCustomMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustomMessageResp>, I>>(object: I): CreateCustomMessageResp {
    const message = createBaseCreateCustomMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateQuoteMessageReq(): CreateQuoteMessageReq {
  return { text: "", quoteMessage: undefined };
}

export const CreateQuoteMessageReq: MessageFns<CreateQuoteMessageReq> = {
  encode(message: CreateQuoteMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.quoteMessage !== undefined) {
      IMMessage.encode(message.quoteMessage, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateQuoteMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateQuoteMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quoteMessage = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateQuoteMessageReq {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      quoteMessage: isSet(object.quoteMessage) ? IMMessage.fromJSON(object.quoteMessage) : undefined,
    };
  },

  toJSON(message: CreateQuoteMessageReq): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.quoteMessage !== undefined) {
      obj.quoteMessage = IMMessage.toJSON(message.quoteMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateQuoteMessageReq>, I>>(base?: I): CreateQuoteMessageReq {
    return CreateQuoteMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateQuoteMessageReq>, I>>(object: I): CreateQuoteMessageReq {
    const message = createBaseCreateQuoteMessageReq();
    message.text = object.text ?? "";
    message.quoteMessage = (object.quoteMessage !== undefined && object.quoteMessage !== null)
      ? IMMessage.fromPartial(object.quoteMessage)
      : undefined;
    return message;
  },
};

function createBaseCreateQuoteMessageResp(): CreateQuoteMessageResp {
  return { message: undefined };
}

export const CreateQuoteMessageResp: MessageFns<CreateQuoteMessageResp> = {
  encode(message: CreateQuoteMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateQuoteMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateQuoteMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateQuoteMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateQuoteMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateQuoteMessageResp>, I>>(base?: I): CreateQuoteMessageResp {
    return CreateQuoteMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateQuoteMessageResp>, I>>(object: I): CreateQuoteMessageResp {
    const message = createBaseCreateQuoteMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateAdvancedQuoteMessageReq(): CreateAdvancedQuoteMessageReq {
  return { text: "", quoteMessage: undefined, messageEntities: [] };
}

export const CreateAdvancedQuoteMessageReq: MessageFns<CreateAdvancedQuoteMessageReq> = {
  encode(message: CreateAdvancedQuoteMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.quoteMessage !== undefined) {
      IMMessage.encode(message.quoteMessage, writer.uint32(18).fork()).join();
    }
    for (const v of message.messageEntities) {
      MessageEntity.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAdvancedQuoteMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAdvancedQuoteMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.quoteMessage = IMMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.messageEntities.push(MessageEntity.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAdvancedQuoteMessageReq {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      quoteMessage: isSet(object.quoteMessage) ? IMMessage.fromJSON(object.quoteMessage) : undefined,
      messageEntities: globalThis.Array.isArray(object?.messageEntities)
        ? object.messageEntities.map((e: any) => MessageEntity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateAdvancedQuoteMessageReq): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.quoteMessage !== undefined) {
      obj.quoteMessage = IMMessage.toJSON(message.quoteMessage);
    }
    if (message.messageEntities?.length) {
      obj.messageEntities = message.messageEntities.map((e) => MessageEntity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAdvancedQuoteMessageReq>, I>>(base?: I): CreateAdvancedQuoteMessageReq {
    return CreateAdvancedQuoteMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAdvancedQuoteMessageReq>, I>>(
    object: I,
  ): CreateAdvancedQuoteMessageReq {
    const message = createBaseCreateAdvancedQuoteMessageReq();
    message.text = object.text ?? "";
    message.quoteMessage = (object.quoteMessage !== undefined && object.quoteMessage !== null)
      ? IMMessage.fromPartial(object.quoteMessage)
      : undefined;
    message.messageEntities = object.messageEntities?.map((e) => MessageEntity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateAdvancedQuoteMessageResp(): CreateAdvancedQuoteMessageResp {
  return { message: undefined };
}

export const CreateAdvancedQuoteMessageResp: MessageFns<CreateAdvancedQuoteMessageResp> = {
  encode(message: CreateAdvancedQuoteMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAdvancedQuoteMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAdvancedQuoteMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAdvancedQuoteMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateAdvancedQuoteMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAdvancedQuoteMessageResp>, I>>(base?: I): CreateAdvancedQuoteMessageResp {
    return CreateAdvancedQuoteMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAdvancedQuoteMessageResp>, I>>(
    object: I,
  ): CreateAdvancedQuoteMessageResp {
    const message = createBaseCreateAdvancedQuoteMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateCardMessageReq(): CreateCardMessageReq {
  return { card: undefined };
}

export const CreateCardMessageReq: MessageFns<CreateCardMessageReq> = {
  encode(message: CreateCardMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.card !== undefined) {
      CardElem.encode(message.card, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCardMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCardMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.card = CardElem.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCardMessageReq {
    return { card: isSet(object.card) ? CardElem.fromJSON(object.card) : undefined };
  },

  toJSON(message: CreateCardMessageReq): unknown {
    const obj: any = {};
    if (message.card !== undefined) {
      obj.card = CardElem.toJSON(message.card);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCardMessageReq>, I>>(base?: I): CreateCardMessageReq {
    return CreateCardMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCardMessageReq>, I>>(object: I): CreateCardMessageReq {
    const message = createBaseCreateCardMessageReq();
    message.card = (object.card !== undefined && object.card !== null) ? CardElem.fromPartial(object.card) : undefined;
    return message;
  },
};

function createBaseCreateCardMessageResp(): CreateCardMessageResp {
  return { message: undefined };
}

export const CreateCardMessageResp: MessageFns<CreateCardMessageResp> = {
  encode(message: CreateCardMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCardMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCardMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCardMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateCardMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCardMessageResp>, I>>(base?: I): CreateCardMessageResp {
    return CreateCardMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCardMessageResp>, I>>(object: I): CreateCardMessageResp {
    const message = createBaseCreateCardMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateImageMessageReq(): CreateImageMessageReq {
  return { imageSourcePath: "", sourcePicture: undefined, bigPicture: undefined, snapshotPicture: undefined };
}

export const CreateImageMessageReq: MessageFns<CreateImageMessageReq> = {
  encode(message: CreateImageMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageSourcePath !== "") {
      writer.uint32(10).string(message.imageSourcePath);
    }
    if (message.sourcePicture !== undefined) {
      PictureBaseInfo.encode(message.sourcePicture, writer.uint32(18).fork()).join();
    }
    if (message.bigPicture !== undefined) {
      PictureBaseInfo.encode(message.bigPicture, writer.uint32(26).fork()).join();
    }
    if (message.snapshotPicture !== undefined) {
      PictureBaseInfo.encode(message.snapshotPicture, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateImageMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateImageMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageSourcePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourcePicture = PictureBaseInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bigPicture = PictureBaseInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.snapshotPicture = PictureBaseInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateImageMessageReq {
    return {
      imageSourcePath: isSet(object.imageSourcePath) ? globalThis.String(object.imageSourcePath) : "",
      sourcePicture: isSet(object.sourcePicture) ? PictureBaseInfo.fromJSON(object.sourcePicture) : undefined,
      bigPicture: isSet(object.bigPicture) ? PictureBaseInfo.fromJSON(object.bigPicture) : undefined,
      snapshotPicture: isSet(object.snapshotPicture) ? PictureBaseInfo.fromJSON(object.snapshotPicture) : undefined,
    };
  },

  toJSON(message: CreateImageMessageReq): unknown {
    const obj: any = {};
    if (message.imageSourcePath !== "") {
      obj.imageSourcePath = message.imageSourcePath;
    }
    if (message.sourcePicture !== undefined) {
      obj.sourcePicture = PictureBaseInfo.toJSON(message.sourcePicture);
    }
    if (message.bigPicture !== undefined) {
      obj.bigPicture = PictureBaseInfo.toJSON(message.bigPicture);
    }
    if (message.snapshotPicture !== undefined) {
      obj.snapshotPicture = PictureBaseInfo.toJSON(message.snapshotPicture);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateImageMessageReq>, I>>(base?: I): CreateImageMessageReq {
    return CreateImageMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateImageMessageReq>, I>>(object: I): CreateImageMessageReq {
    const message = createBaseCreateImageMessageReq();
    message.imageSourcePath = object.imageSourcePath ?? "";
    message.sourcePicture = (object.sourcePicture !== undefined && object.sourcePicture !== null)
      ? PictureBaseInfo.fromPartial(object.sourcePicture)
      : undefined;
    message.bigPicture = (object.bigPicture !== undefined && object.bigPicture !== null)
      ? PictureBaseInfo.fromPartial(object.bigPicture)
      : undefined;
    message.snapshotPicture = (object.snapshotPicture !== undefined && object.snapshotPicture !== null)
      ? PictureBaseInfo.fromPartial(object.snapshotPicture)
      : undefined;
    return message;
  },
};

function createBaseCreateImageMessageResp(): CreateImageMessageResp {
  return { message: undefined };
}

export const CreateImageMessageResp: MessageFns<CreateImageMessageResp> = {
  encode(message: CreateImageMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateImageMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateImageMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateImageMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateImageMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateImageMessageResp>, I>>(base?: I): CreateImageMessageResp {
    return CreateImageMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateImageMessageResp>, I>>(object: I): CreateImageMessageResp {
    const message = createBaseCreateImageMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateSoundMessageReq(): CreateSoundMessageReq {
  return { soundPath: "", duration: 0, soundElem: undefined };
}

export const CreateSoundMessageReq: MessageFns<CreateSoundMessageReq> = {
  encode(message: CreateSoundMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.soundPath !== "") {
      writer.uint32(10).string(message.soundPath);
    }
    if (message.duration !== 0) {
      writer.uint32(16).int64(message.duration);
    }
    if (message.soundElem !== undefined) {
      SoundBaseInfo.encode(message.soundElem, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSoundMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSoundMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.soundPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.soundElem = SoundBaseInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSoundMessageReq {
    return {
      soundPath: isSet(object.soundPath) ? globalThis.String(object.soundPath) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      soundElem: isSet(object.soundElem) ? SoundBaseInfo.fromJSON(object.soundElem) : undefined,
    };
  },

  toJSON(message: CreateSoundMessageReq): unknown {
    const obj: any = {};
    if (message.soundPath !== "") {
      obj.soundPath = message.soundPath;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.soundElem !== undefined) {
      obj.soundElem = SoundBaseInfo.toJSON(message.soundElem);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSoundMessageReq>, I>>(base?: I): CreateSoundMessageReq {
    return CreateSoundMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSoundMessageReq>, I>>(object: I): CreateSoundMessageReq {
    const message = createBaseCreateSoundMessageReq();
    message.soundPath = object.soundPath ?? "";
    message.duration = object.duration ?? 0;
    message.soundElem = (object.soundElem !== undefined && object.soundElem !== null)
      ? SoundBaseInfo.fromPartial(object.soundElem)
      : undefined;
    return message;
  },
};

function createBaseCreateSoundMessageResp(): CreateSoundMessageResp {
  return { message: undefined };
}

export const CreateSoundMessageResp: MessageFns<CreateSoundMessageResp> = {
  encode(message: CreateSoundMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSoundMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSoundMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSoundMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateSoundMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSoundMessageResp>, I>>(base?: I): CreateSoundMessageResp {
    return CreateSoundMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSoundMessageResp>, I>>(object: I): CreateSoundMessageResp {
    const message = createBaseCreateSoundMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateVideoMessageReq(): CreateVideoMessageReq {
  return { videoSourcePath: "", videoType: "", duration: 0, snapshotSourcePath: "", videoElem: undefined };
}

export const CreateVideoMessageReq: MessageFns<CreateVideoMessageReq> = {
  encode(message: CreateVideoMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoSourcePath !== "") {
      writer.uint32(10).string(message.videoSourcePath);
    }
    if (message.videoType !== "") {
      writer.uint32(18).string(message.videoType);
    }
    if (message.duration !== 0) {
      writer.uint32(24).int64(message.duration);
    }
    if (message.snapshotSourcePath !== "") {
      writer.uint32(34).string(message.snapshotSourcePath);
    }
    if (message.videoElem !== undefined) {
      VideoBaseInfo.encode(message.videoElem, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVideoMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVideoMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.videoSourcePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.videoType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.snapshotSourcePath = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.videoElem = VideoBaseInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVideoMessageReq {
    return {
      videoSourcePath: isSet(object.videoSourcePath) ? globalThis.String(object.videoSourcePath) : "",
      videoType: isSet(object.videoType) ? globalThis.String(object.videoType) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      snapshotSourcePath: isSet(object.snapshotSourcePath) ? globalThis.String(object.snapshotSourcePath) : "",
      videoElem: isSet(object.videoElem) ? VideoBaseInfo.fromJSON(object.videoElem) : undefined,
    };
  },

  toJSON(message: CreateVideoMessageReq): unknown {
    const obj: any = {};
    if (message.videoSourcePath !== "") {
      obj.videoSourcePath = message.videoSourcePath;
    }
    if (message.videoType !== "") {
      obj.videoType = message.videoType;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.snapshotSourcePath !== "") {
      obj.snapshotSourcePath = message.snapshotSourcePath;
    }
    if (message.videoElem !== undefined) {
      obj.videoElem = VideoBaseInfo.toJSON(message.videoElem);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateVideoMessageReq>, I>>(base?: I): CreateVideoMessageReq {
    return CreateVideoMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateVideoMessageReq>, I>>(object: I): CreateVideoMessageReq {
    const message = createBaseCreateVideoMessageReq();
    message.videoSourcePath = object.videoSourcePath ?? "";
    message.videoType = object.videoType ?? "";
    message.duration = object.duration ?? 0;
    message.snapshotSourcePath = object.snapshotSourcePath ?? "";
    message.videoElem = (object.videoElem !== undefined && object.videoElem !== null)
      ? VideoBaseInfo.fromPartial(object.videoElem)
      : undefined;
    return message;
  },
};

function createBaseCreateVideoMessageResp(): CreateVideoMessageResp {
  return { message: undefined };
}

export const CreateVideoMessageResp: MessageFns<CreateVideoMessageResp> = {
  encode(message: CreateVideoMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVideoMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVideoMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVideoMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateVideoMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateVideoMessageResp>, I>>(base?: I): CreateVideoMessageResp {
    return CreateVideoMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateVideoMessageResp>, I>>(object: I): CreateVideoMessageResp {
    const message = createBaseCreateVideoMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateFileMessageReq(): CreateFileMessageReq {
  return { fileSourcePath: "", fileName: "", fileElem: undefined };
}

export const CreateFileMessageReq: MessageFns<CreateFileMessageReq> = {
  encode(message: CreateFileMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileSourcePath !== "") {
      writer.uint32(10).string(message.fileSourcePath);
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    if (message.fileElem !== undefined) {
      FileBaseInfo.encode(message.fileElem, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFileMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFileMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileSourcePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileElem = FileBaseInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFileMessageReq {
    return {
      fileSourcePath: isSet(object.fileSourcePath) ? globalThis.String(object.fileSourcePath) : "",
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      fileElem: isSet(object.fileElem) ? FileBaseInfo.fromJSON(object.fileElem) : undefined,
    };
  },

  toJSON(message: CreateFileMessageReq): unknown {
    const obj: any = {};
    if (message.fileSourcePath !== "") {
      obj.fileSourcePath = message.fileSourcePath;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileElem !== undefined) {
      obj.fileElem = FileBaseInfo.toJSON(message.fileElem);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFileMessageReq>, I>>(base?: I): CreateFileMessageReq {
    return CreateFileMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFileMessageReq>, I>>(object: I): CreateFileMessageReq {
    const message = createBaseCreateFileMessageReq();
    message.fileSourcePath = object.fileSourcePath ?? "";
    message.fileName = object.fileName ?? "";
    message.fileElem = (object.fileElem !== undefined && object.fileElem !== null)
      ? FileBaseInfo.fromPartial(object.fileElem)
      : undefined;
    return message;
  },
};

function createBaseCreateFileMessageResp(): CreateFileMessageResp {
  return { message: undefined };
}

export const CreateFileMessageResp: MessageFns<CreateFileMessageResp> = {
  encode(message: CreateFileMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFileMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFileMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFileMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateFileMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFileMessageResp>, I>>(base?: I): CreateFileMessageResp {
    return CreateFileMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFileMessageResp>, I>>(object: I): CreateFileMessageResp {
    const message = createBaseCreateFileMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateMergerMessageReq(): CreateMergerMessageReq {
  return { messages: [], title: "", summaries: [] };
}

export const CreateMergerMessageReq: MessageFns<CreateMergerMessageReq> = {
  encode(message: CreateMergerMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      IMMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    for (const v of message.summaries) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMergerMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMergerMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(IMMessage.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.summaries.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMergerMessageReq {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => IMMessage.fromJSON(e))
        : [],
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      summaries: globalThis.Array.isArray(object?.summaries)
        ? object.summaries.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CreateMergerMessageReq): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => IMMessage.toJSON(e));
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.summaries?.length) {
      obj.summaries = message.summaries;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateMergerMessageReq>, I>>(base?: I): CreateMergerMessageReq {
    return CreateMergerMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateMergerMessageReq>, I>>(object: I): CreateMergerMessageReq {
    const message = createBaseCreateMergerMessageReq();
    message.messages = object.messages?.map((e) => IMMessage.fromPartial(e)) || [];
    message.title = object.title ?? "";
    message.summaries = object.summaries?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateMergerMessageResp(): CreateMergerMessageResp {
  return { message: undefined };
}

export const CreateMergerMessageResp: MessageFns<CreateMergerMessageResp> = {
  encode(message: CreateMergerMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMergerMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMergerMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMergerMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateMergerMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateMergerMessageResp>, I>>(base?: I): CreateMergerMessageResp {
    return CreateMergerMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateMergerMessageResp>, I>>(object: I): CreateMergerMessageResp {
    const message = createBaseCreateMergerMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateFaceMessageReq(): CreateFaceMessageReq {
  return { index: 0, data: "" };
}

export const CreateFaceMessageReq: MessageFns<CreateFaceMessageReq> = {
  encode(message: CreateFaceMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.data !== "") {
      writer.uint32(18).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFaceMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFaceMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFaceMessageReq {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      data: isSet(object.data) ? globalThis.String(object.data) : "",
    };
  },

  toJSON(message: CreateFaceMessageReq): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFaceMessageReq>, I>>(base?: I): CreateFaceMessageReq {
    return CreateFaceMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFaceMessageReq>, I>>(object: I): CreateFaceMessageReq {
    const message = createBaseCreateFaceMessageReq();
    message.index = object.index ?? 0;
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseCreateFaceMessageResp(): CreateFaceMessageResp {
  return { message: undefined };
}

export const CreateFaceMessageResp: MessageFns<CreateFaceMessageResp> = {
  encode(message: CreateFaceMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFaceMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFaceMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFaceMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateFaceMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateFaceMessageResp>, I>>(base?: I): CreateFaceMessageResp {
    return CreateFaceMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateFaceMessageResp>, I>>(object: I): CreateFaceMessageResp {
    const message = createBaseCreateFaceMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateForwardMessageReq(): CreateForwardMessageReq {
  return { message: undefined };
}

export const CreateForwardMessageReq: MessageFns<CreateForwardMessageReq> = {
  encode(message: CreateForwardMessageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateForwardMessageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateForwardMessageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateForwardMessageReq {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateForwardMessageReq): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateForwardMessageReq>, I>>(base?: I): CreateForwardMessageReq {
    return CreateForwardMessageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateForwardMessageReq>, I>>(object: I): CreateForwardMessageReq {
    const message = createBaseCreateForwardMessageReq();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseCreateForwardMessageResp(): CreateForwardMessageResp {
  return { message: undefined };
}

export const CreateForwardMessageResp: MessageFns<CreateForwardMessageResp> = {
  encode(message: CreateForwardMessageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateForwardMessageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateForwardMessageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateForwardMessageResp {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: CreateForwardMessageResp): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateForwardMessageResp>, I>>(base?: I): CreateForwardMessageResp {
    return CreateForwardMessageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateForwardMessageResp>, I>>(object: I): CreateForwardMessageResp {
    const message = createBaseCreateForwardMessageResp();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
