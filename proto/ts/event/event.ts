// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v5.27.1
// source: event.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  BlackInfo,
  CommandInfo,
  Conversation,
  FriendInfo,
  FriendRequestInfo,
  GroupInfo,
  GroupMemberInfo,
  GroupRequestInfo,
  IMMessage,
  UserInfo,
} from "./shared";

export const protobufPackage = "openim.event";

export enum FuncRequestEventName {
  None = 0,
  GetAllConversationList = 1,
  GetConversationList = 2,
  GetConversation = 3,
  InitSDK = 4,
  Login = 5,
  SendMessage = 6,
  UploadLogs = 7,
  UploadFile = 8,
  Log = 9,
  UpdateFcmToken = 10,
  SetAppBadge = 11,
  EventOnSendMsgProgress = 12,
  EventOnUploadFileProgress = 13,
  EventOnUploadLogsProgress = 14,
  EventOnConnecting = 15,
  EventOnConnectSuccess = 16,
  EventOnConnectFailed = 17,
  EventOnKickedOffline = 18,
  EventOnUserTokenExpired = 19,
  EventOnUserTokenInvalid = 20,
  EventOnSyncServerStart = 21,
  EventOnSyncServerFinish = 22,
  EventOnSyncServerFailed = 23,
  EventOnSyncServerProgress = 24,
  EventOnNewConversation = 25,
  EventOnConversationChanged = 26,
  EventOnTotalUnreadMessageCountChanged = 27,
  EventOnConversationUserInputStatusChanged = 28,
  EventOnRecvNewMessage = 29,
  EventOnRecvC2CReadReceipt = 30,
  EventOnNewRecvMessageRevoked = 31,
  EventOnRecvOfflineNewMessage = 32,
  EventOnMsgDeleted = 33,
  EventOnRecvOnlineOnlyMessage = 34,
  EventOnMsgEdited = 35,
  /** EventOnFriendApplicationAdded - FriendCallback Events */
  EventOnFriendApplicationAdded = 36,
  EventOnFriendApplicationDeleted = 37,
  EventOnFriendApplicationAccepted = 38,
  EventOnFriendApplicationRejected = 39,
  EventOnFriendAdded = 40,
  EventOnFriendDeleted = 41,
  EventOnFriendInfoChanged = 42,
  EventOnBlackAdded = 43,
  EventOnBlackDeleted = 44,
  /** EventOnJoinedGroupAdded - GroupCallback Events */
  EventOnJoinedGroupAdded = 45,
  EventOnJoinedGroupDeleted = 46,
  EventOnGroupMemberAdded = 47,
  EventOnGroupMemberDeleted = 48,
  EventOnGroupApplicationAdded = 49,
  EventOnGroupApplicationDeleted = 50,
  EventOnGroupInfoChanged = 51,
  EventOnGroupDismissed = 52,
  EventOnGroupMemberInfoChanged = 53,
  EventOnGroupApplicationAccepted = 54,
  EventOnGroupApplicationRejected = 55,
  /** EventOnRecvCustomBusinessMessage - CustomBusinessCallback Events */
  EventOnRecvCustomBusinessMessage = 56,
  /** EventOnSelfInfoUpdated - UserCallback Events */
  EventOnSelfInfoUpdated = 57,
  EventOnUserStatusChanged = 58,
  EventOnUserCommandAdd = 59,
  EventOnUserCommandDelete = 60,
  EventOnUserCommandUpdate = 61,
  CreateGroup = 1000,
  JoinGroup = 1001,
  QuitGroup = 1002,
  DismissGroup = 1003,
  ChangeGroupMute = 1004,
  ChangeGroupMemberMute = 1005,
  TransferGroupOwner = 1006,
  KickGroupMember = 1007,
  SetGroupInfo = 1008,
  SetGroupMemberInfo = 1009,
  GetJoinedGroups = 1010,
  GetJoinedGroupsPage = 1011,
  GetSpecifiedGroupsInfo = 1012,
  SearchGroups = 1013,
  GetGroupMemberOwnerAndAdmin = 1014,
  GetGroupMembersByJoinTimeFilter = 1015,
  GetSpecifiedGroupMembersInfo = 1016,
  GetGroupMembers = 1017,
  GetGroupRequest = 1018,
  SearchGroupMembers = 1019,
  IsJoinGroup = 1020,
  GetUsersInGroup = 1021,
  InviteUserToGroup = 1022,
  HandlerGroupRequest = 1023,
  GetSpecifiedFriends = 1100,
  AddFriend = 1101,
  GetFriendRequests = 1102,
  HandlerFriendRequest = 1103,
  CheckFriend = 1104,
  DeleteFriend = 1105,
  GetFriends = 1106,
  GetFriendsPage = 1107,
  SearchFriends = 1108,
  AddBlack = 1109,
  DeleteBlack = 1110,
  GetBlacks = 1111,
  UpdateFriends = 1112,
  /** GetConversationListSplit - conversation_msg */
  GetConversationListSplit = 2000,
  HideConversation = 2001,
  GetAtAllTag = 2002,
  GetOneConversation = 2003,
  GetMultipleConversation = 2004,
  HideAllConversations = 2005,
  SetConversationDraft = 2006,
  SetConversation = 2007,
  GetTotalUnreadMsgCount = 2008,
  GetConversationIDBySessionType = 2009,
  FindMessageList = 2010,
  GetAdvancedHistoryMessageList = 2011,
  GetAdvancedHistoryMessageListReverse = 2012,
  RevokeMessage = 2013,
  TypingStatusUpdate = 2014,
  MarkConversationMessageAsRead = 2015,
  MarkAllConversationMessageAsRead = 2016,
  DeleteMessageFromLocalStorage = 2017,
  DeleteMessage = 2018,
  DeleteAllMsgFromLocalAndServer = 2019,
  DeleteAllMessageFromLocalStorage = 2020,
  ClearConversationAndDeleteAllMsg = 2021,
  DeleteConversationAndDeleteAllMsg = 2022,
  InsertSingleMessageToLocalStorage = 2023,
  InsertGroupMessageToLocalStorage = 2024,
  SearchLocalMessages = 2025,
  SetMessageLocalEx = 2026,
  SearchConversation = 2027,
  CreateTextMessage = 2028,
  CreateAdvancedTextMessage = 2029,
  CreateTextAtMessage = 2030,
  CreateLocationMessage = 2031,
  CreateCustomMessage = 2032,
  CreateQuoteMessage = 2033,
  CreateAdvancedQuoteMessage = 2034,
  CreateCardMessage = 2035,
  CreateImageMessage = 2036,
  CreateSoundMessage = 2037,
  CreateVideoMessage = 2038,
  CreateFileMessage = 2039,
  CreateMergerMessage = 2040,
  CreateFaceMessage = 2041,
  CreateForwardMessage = 2042,
  ProcessUserCommandGetAll = 2100,
  GetSelfUserInfo = 2101,
  SetSelfInfo = 2102,
  ProcessUserCommandAdd = 2103,
  ProcessUserCommandDelete = 2104,
  ProcessUserCommandUpdate = 2105,
  GetUsersInfo = 2106,
  GetUsersInfoFromServer = 2107,
  UNRECOGNIZED = -1,
}

export function funcRequestEventNameFromJSON(object: any): FuncRequestEventName {
  switch (object) {
    case 0:
    case "None":
      return FuncRequestEventName.None;
    case 1:
    case "GetAllConversationList":
      return FuncRequestEventName.GetAllConversationList;
    case 2:
    case "GetConversationList":
      return FuncRequestEventName.GetConversationList;
    case 3:
    case "GetConversation":
      return FuncRequestEventName.GetConversation;
    case 4:
    case "InitSDK":
      return FuncRequestEventName.InitSDK;
    case 5:
    case "Login":
      return FuncRequestEventName.Login;
    case 6:
    case "SendMessage":
      return FuncRequestEventName.SendMessage;
    case 7:
    case "UploadLogs":
      return FuncRequestEventName.UploadLogs;
    case 8:
    case "UploadFile":
      return FuncRequestEventName.UploadFile;
    case 9:
    case "Log":
      return FuncRequestEventName.Log;
    case 10:
    case "UpdateFcmToken":
      return FuncRequestEventName.UpdateFcmToken;
    case 11:
    case "SetAppBadge":
      return FuncRequestEventName.SetAppBadge;
    case 12:
    case "EventOnSendMsgProgress":
      return FuncRequestEventName.EventOnSendMsgProgress;
    case 13:
    case "EventOnUploadFileProgress":
      return FuncRequestEventName.EventOnUploadFileProgress;
    case 14:
    case "EventOnUploadLogsProgress":
      return FuncRequestEventName.EventOnUploadLogsProgress;
    case 15:
    case "EventOnConnecting":
      return FuncRequestEventName.EventOnConnecting;
    case 16:
    case "EventOnConnectSuccess":
      return FuncRequestEventName.EventOnConnectSuccess;
    case 17:
    case "EventOnConnectFailed":
      return FuncRequestEventName.EventOnConnectFailed;
    case 18:
    case "EventOnKickedOffline":
      return FuncRequestEventName.EventOnKickedOffline;
    case 19:
    case "EventOnUserTokenExpired":
      return FuncRequestEventName.EventOnUserTokenExpired;
    case 20:
    case "EventOnUserTokenInvalid":
      return FuncRequestEventName.EventOnUserTokenInvalid;
    case 21:
    case "EventOnSyncServerStart":
      return FuncRequestEventName.EventOnSyncServerStart;
    case 22:
    case "EventOnSyncServerFinish":
      return FuncRequestEventName.EventOnSyncServerFinish;
    case 23:
    case "EventOnSyncServerFailed":
      return FuncRequestEventName.EventOnSyncServerFailed;
    case 24:
    case "EventOnSyncServerProgress":
      return FuncRequestEventName.EventOnSyncServerProgress;
    case 25:
    case "EventOnNewConversation":
      return FuncRequestEventName.EventOnNewConversation;
    case 26:
    case "EventOnConversationChanged":
      return FuncRequestEventName.EventOnConversationChanged;
    case 27:
    case "EventOnTotalUnreadMessageCountChanged":
      return FuncRequestEventName.EventOnTotalUnreadMessageCountChanged;
    case 28:
    case "EventOnConversationUserInputStatusChanged":
      return FuncRequestEventName.EventOnConversationUserInputStatusChanged;
    case 29:
    case "EventOnRecvNewMessage":
      return FuncRequestEventName.EventOnRecvNewMessage;
    case 30:
    case "EventOnRecvC2CReadReceipt":
      return FuncRequestEventName.EventOnRecvC2CReadReceipt;
    case 31:
    case "EventOnNewRecvMessageRevoked":
      return FuncRequestEventName.EventOnNewRecvMessageRevoked;
    case 32:
    case "EventOnRecvOfflineNewMessage":
      return FuncRequestEventName.EventOnRecvOfflineNewMessage;
    case 33:
    case "EventOnMsgDeleted":
      return FuncRequestEventName.EventOnMsgDeleted;
    case 34:
    case "EventOnRecvOnlineOnlyMessage":
      return FuncRequestEventName.EventOnRecvOnlineOnlyMessage;
    case 35:
    case "EventOnMsgEdited":
      return FuncRequestEventName.EventOnMsgEdited;
    case 36:
    case "EventOnFriendApplicationAdded":
      return FuncRequestEventName.EventOnFriendApplicationAdded;
    case 37:
    case "EventOnFriendApplicationDeleted":
      return FuncRequestEventName.EventOnFriendApplicationDeleted;
    case 38:
    case "EventOnFriendApplicationAccepted":
      return FuncRequestEventName.EventOnFriendApplicationAccepted;
    case 39:
    case "EventOnFriendApplicationRejected":
      return FuncRequestEventName.EventOnFriendApplicationRejected;
    case 40:
    case "EventOnFriendAdded":
      return FuncRequestEventName.EventOnFriendAdded;
    case 41:
    case "EventOnFriendDeleted":
      return FuncRequestEventName.EventOnFriendDeleted;
    case 42:
    case "EventOnFriendInfoChanged":
      return FuncRequestEventName.EventOnFriendInfoChanged;
    case 43:
    case "EventOnBlackAdded":
      return FuncRequestEventName.EventOnBlackAdded;
    case 44:
    case "EventOnBlackDeleted":
      return FuncRequestEventName.EventOnBlackDeleted;
    case 45:
    case "EventOnJoinedGroupAdded":
      return FuncRequestEventName.EventOnJoinedGroupAdded;
    case 46:
    case "EventOnJoinedGroupDeleted":
      return FuncRequestEventName.EventOnJoinedGroupDeleted;
    case 47:
    case "EventOnGroupMemberAdded":
      return FuncRequestEventName.EventOnGroupMemberAdded;
    case 48:
    case "EventOnGroupMemberDeleted":
      return FuncRequestEventName.EventOnGroupMemberDeleted;
    case 49:
    case "EventOnGroupApplicationAdded":
      return FuncRequestEventName.EventOnGroupApplicationAdded;
    case 50:
    case "EventOnGroupApplicationDeleted":
      return FuncRequestEventName.EventOnGroupApplicationDeleted;
    case 51:
    case "EventOnGroupInfoChanged":
      return FuncRequestEventName.EventOnGroupInfoChanged;
    case 52:
    case "EventOnGroupDismissed":
      return FuncRequestEventName.EventOnGroupDismissed;
    case 53:
    case "EventOnGroupMemberInfoChanged":
      return FuncRequestEventName.EventOnGroupMemberInfoChanged;
    case 54:
    case "EventOnGroupApplicationAccepted":
      return FuncRequestEventName.EventOnGroupApplicationAccepted;
    case 55:
    case "EventOnGroupApplicationRejected":
      return FuncRequestEventName.EventOnGroupApplicationRejected;
    case 56:
    case "EventOnRecvCustomBusinessMessage":
      return FuncRequestEventName.EventOnRecvCustomBusinessMessage;
    case 57:
    case "EventOnSelfInfoUpdated":
      return FuncRequestEventName.EventOnSelfInfoUpdated;
    case 58:
    case "EventOnUserStatusChanged":
      return FuncRequestEventName.EventOnUserStatusChanged;
    case 59:
    case "EventOnUserCommandAdd":
      return FuncRequestEventName.EventOnUserCommandAdd;
    case 60:
    case "EventOnUserCommandDelete":
      return FuncRequestEventName.EventOnUserCommandDelete;
    case 61:
    case "EventOnUserCommandUpdate":
      return FuncRequestEventName.EventOnUserCommandUpdate;
    case 1000:
    case "CreateGroup":
      return FuncRequestEventName.CreateGroup;
    case 1001:
    case "JoinGroup":
      return FuncRequestEventName.JoinGroup;
    case 1002:
    case "QuitGroup":
      return FuncRequestEventName.QuitGroup;
    case 1003:
    case "DismissGroup":
      return FuncRequestEventName.DismissGroup;
    case 1004:
    case "ChangeGroupMute":
      return FuncRequestEventName.ChangeGroupMute;
    case 1005:
    case "ChangeGroupMemberMute":
      return FuncRequestEventName.ChangeGroupMemberMute;
    case 1006:
    case "TransferGroupOwner":
      return FuncRequestEventName.TransferGroupOwner;
    case 1007:
    case "KickGroupMember":
      return FuncRequestEventName.KickGroupMember;
    case 1008:
    case "SetGroupInfo":
      return FuncRequestEventName.SetGroupInfo;
    case 1009:
    case "SetGroupMemberInfo":
      return FuncRequestEventName.SetGroupMemberInfo;
    case 1010:
    case "GetJoinedGroups":
      return FuncRequestEventName.GetJoinedGroups;
    case 1011:
    case "GetJoinedGroupsPage":
      return FuncRequestEventName.GetJoinedGroupsPage;
    case 1012:
    case "GetSpecifiedGroupsInfo":
      return FuncRequestEventName.GetSpecifiedGroupsInfo;
    case 1013:
    case "SearchGroups":
      return FuncRequestEventName.SearchGroups;
    case 1014:
    case "GetGroupMemberOwnerAndAdmin":
      return FuncRequestEventName.GetGroupMemberOwnerAndAdmin;
    case 1015:
    case "GetGroupMembersByJoinTimeFilter":
      return FuncRequestEventName.GetGroupMembersByJoinTimeFilter;
    case 1016:
    case "GetSpecifiedGroupMembersInfo":
      return FuncRequestEventName.GetSpecifiedGroupMembersInfo;
    case 1017:
    case "GetGroupMembers":
      return FuncRequestEventName.GetGroupMembers;
    case 1018:
    case "GetGroupRequest":
      return FuncRequestEventName.GetGroupRequest;
    case 1019:
    case "SearchGroupMembers":
      return FuncRequestEventName.SearchGroupMembers;
    case 1020:
    case "IsJoinGroup":
      return FuncRequestEventName.IsJoinGroup;
    case 1021:
    case "GetUsersInGroup":
      return FuncRequestEventName.GetUsersInGroup;
    case 1022:
    case "InviteUserToGroup":
      return FuncRequestEventName.InviteUserToGroup;
    case 1023:
    case "HandlerGroupRequest":
      return FuncRequestEventName.HandlerGroupRequest;
    case 1100:
    case "GetSpecifiedFriends":
      return FuncRequestEventName.GetSpecifiedFriends;
    case 1101:
    case "AddFriend":
      return FuncRequestEventName.AddFriend;
    case 1102:
    case "GetFriendRequests":
      return FuncRequestEventName.GetFriendRequests;
    case 1103:
    case "HandlerFriendRequest":
      return FuncRequestEventName.HandlerFriendRequest;
    case 1104:
    case "CheckFriend":
      return FuncRequestEventName.CheckFriend;
    case 1105:
    case "DeleteFriend":
      return FuncRequestEventName.DeleteFriend;
    case 1106:
    case "GetFriends":
      return FuncRequestEventName.GetFriends;
    case 1107:
    case "GetFriendsPage":
      return FuncRequestEventName.GetFriendsPage;
    case 1108:
    case "SearchFriends":
      return FuncRequestEventName.SearchFriends;
    case 1109:
    case "AddBlack":
      return FuncRequestEventName.AddBlack;
    case 1110:
    case "DeleteBlack":
      return FuncRequestEventName.DeleteBlack;
    case 1111:
    case "GetBlacks":
      return FuncRequestEventName.GetBlacks;
    case 1112:
    case "UpdateFriends":
      return FuncRequestEventName.UpdateFriends;
    case 2000:
    case "GetConversationListSplit":
      return FuncRequestEventName.GetConversationListSplit;
    case 2001:
    case "HideConversation":
      return FuncRequestEventName.HideConversation;
    case 2002:
    case "GetAtAllTag":
      return FuncRequestEventName.GetAtAllTag;
    case 2003:
    case "GetOneConversation":
      return FuncRequestEventName.GetOneConversation;
    case 2004:
    case "GetMultipleConversation":
      return FuncRequestEventName.GetMultipleConversation;
    case 2005:
    case "HideAllConversations":
      return FuncRequestEventName.HideAllConversations;
    case 2006:
    case "SetConversationDraft":
      return FuncRequestEventName.SetConversationDraft;
    case 2007:
    case "SetConversation":
      return FuncRequestEventName.SetConversation;
    case 2008:
    case "GetTotalUnreadMsgCount":
      return FuncRequestEventName.GetTotalUnreadMsgCount;
    case 2009:
    case "GetConversationIDBySessionType":
      return FuncRequestEventName.GetConversationIDBySessionType;
    case 2010:
    case "FindMessageList":
      return FuncRequestEventName.FindMessageList;
    case 2011:
    case "GetAdvancedHistoryMessageList":
      return FuncRequestEventName.GetAdvancedHistoryMessageList;
    case 2012:
    case "GetAdvancedHistoryMessageListReverse":
      return FuncRequestEventName.GetAdvancedHistoryMessageListReverse;
    case 2013:
    case "RevokeMessage":
      return FuncRequestEventName.RevokeMessage;
    case 2014:
    case "TypingStatusUpdate":
      return FuncRequestEventName.TypingStatusUpdate;
    case 2015:
    case "MarkConversationMessageAsRead":
      return FuncRequestEventName.MarkConversationMessageAsRead;
    case 2016:
    case "MarkAllConversationMessageAsRead":
      return FuncRequestEventName.MarkAllConversationMessageAsRead;
    case 2017:
    case "DeleteMessageFromLocalStorage":
      return FuncRequestEventName.DeleteMessageFromLocalStorage;
    case 2018:
    case "DeleteMessage":
      return FuncRequestEventName.DeleteMessage;
    case 2019:
    case "DeleteAllMsgFromLocalAndServer":
      return FuncRequestEventName.DeleteAllMsgFromLocalAndServer;
    case 2020:
    case "DeleteAllMessageFromLocalStorage":
      return FuncRequestEventName.DeleteAllMessageFromLocalStorage;
    case 2021:
    case "ClearConversationAndDeleteAllMsg":
      return FuncRequestEventName.ClearConversationAndDeleteAllMsg;
    case 2022:
    case "DeleteConversationAndDeleteAllMsg":
      return FuncRequestEventName.DeleteConversationAndDeleteAllMsg;
    case 2023:
    case "InsertSingleMessageToLocalStorage":
      return FuncRequestEventName.InsertSingleMessageToLocalStorage;
    case 2024:
    case "InsertGroupMessageToLocalStorage":
      return FuncRequestEventName.InsertGroupMessageToLocalStorage;
    case 2025:
    case "SearchLocalMessages":
      return FuncRequestEventName.SearchLocalMessages;
    case 2026:
    case "SetMessageLocalEx":
      return FuncRequestEventName.SetMessageLocalEx;
    case 2027:
    case "SearchConversation":
      return FuncRequestEventName.SearchConversation;
    case 2028:
    case "CreateTextMessage":
      return FuncRequestEventName.CreateTextMessage;
    case 2029:
    case "CreateAdvancedTextMessage":
      return FuncRequestEventName.CreateAdvancedTextMessage;
    case 2030:
    case "CreateTextAtMessage":
      return FuncRequestEventName.CreateTextAtMessage;
    case 2031:
    case "CreateLocationMessage":
      return FuncRequestEventName.CreateLocationMessage;
    case 2032:
    case "CreateCustomMessage":
      return FuncRequestEventName.CreateCustomMessage;
    case 2033:
    case "CreateQuoteMessage":
      return FuncRequestEventName.CreateQuoteMessage;
    case 2034:
    case "CreateAdvancedQuoteMessage":
      return FuncRequestEventName.CreateAdvancedQuoteMessage;
    case 2035:
    case "CreateCardMessage":
      return FuncRequestEventName.CreateCardMessage;
    case 2036:
    case "CreateImageMessage":
      return FuncRequestEventName.CreateImageMessage;
    case 2037:
    case "CreateSoundMessage":
      return FuncRequestEventName.CreateSoundMessage;
    case 2038:
    case "CreateVideoMessage":
      return FuncRequestEventName.CreateVideoMessage;
    case 2039:
    case "CreateFileMessage":
      return FuncRequestEventName.CreateFileMessage;
    case 2040:
    case "CreateMergerMessage":
      return FuncRequestEventName.CreateMergerMessage;
    case 2041:
    case "CreateFaceMessage":
      return FuncRequestEventName.CreateFaceMessage;
    case 2042:
    case "CreateForwardMessage":
      return FuncRequestEventName.CreateForwardMessage;
    case 2100:
    case "ProcessUserCommandGetAll":
      return FuncRequestEventName.ProcessUserCommandGetAll;
    case 2101:
    case "GetSelfUserInfo":
      return FuncRequestEventName.GetSelfUserInfo;
    case 2102:
    case "SetSelfInfo":
      return FuncRequestEventName.SetSelfInfo;
    case 2103:
    case "ProcessUserCommandAdd":
      return FuncRequestEventName.ProcessUserCommandAdd;
    case 2104:
    case "ProcessUserCommandDelete":
      return FuncRequestEventName.ProcessUserCommandDelete;
    case 2105:
    case "ProcessUserCommandUpdate":
      return FuncRequestEventName.ProcessUserCommandUpdate;
    case 2106:
    case "GetUsersInfo":
      return FuncRequestEventName.GetUsersInfo;
    case 2107:
    case "GetUsersInfoFromServer":
      return FuncRequestEventName.GetUsersInfoFromServer;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FuncRequestEventName.UNRECOGNIZED;
  }
}

export function funcRequestEventNameToJSON(object: FuncRequestEventName): string {
  switch (object) {
    case FuncRequestEventName.None:
      return "None";
    case FuncRequestEventName.GetAllConversationList:
      return "GetAllConversationList";
    case FuncRequestEventName.GetConversationList:
      return "GetConversationList";
    case FuncRequestEventName.GetConversation:
      return "GetConversation";
    case FuncRequestEventName.InitSDK:
      return "InitSDK";
    case FuncRequestEventName.Login:
      return "Login";
    case FuncRequestEventName.SendMessage:
      return "SendMessage";
    case FuncRequestEventName.UploadLogs:
      return "UploadLogs";
    case FuncRequestEventName.UploadFile:
      return "UploadFile";
    case FuncRequestEventName.Log:
      return "Log";
    case FuncRequestEventName.UpdateFcmToken:
      return "UpdateFcmToken";
    case FuncRequestEventName.SetAppBadge:
      return "SetAppBadge";
    case FuncRequestEventName.EventOnSendMsgProgress:
      return "EventOnSendMsgProgress";
    case FuncRequestEventName.EventOnUploadFileProgress:
      return "EventOnUploadFileProgress";
    case FuncRequestEventName.EventOnUploadLogsProgress:
      return "EventOnUploadLogsProgress";
    case FuncRequestEventName.EventOnConnecting:
      return "EventOnConnecting";
    case FuncRequestEventName.EventOnConnectSuccess:
      return "EventOnConnectSuccess";
    case FuncRequestEventName.EventOnConnectFailed:
      return "EventOnConnectFailed";
    case FuncRequestEventName.EventOnKickedOffline:
      return "EventOnKickedOffline";
    case FuncRequestEventName.EventOnUserTokenExpired:
      return "EventOnUserTokenExpired";
    case FuncRequestEventName.EventOnUserTokenInvalid:
      return "EventOnUserTokenInvalid";
    case FuncRequestEventName.EventOnSyncServerStart:
      return "EventOnSyncServerStart";
    case FuncRequestEventName.EventOnSyncServerFinish:
      return "EventOnSyncServerFinish";
    case FuncRequestEventName.EventOnSyncServerFailed:
      return "EventOnSyncServerFailed";
    case FuncRequestEventName.EventOnSyncServerProgress:
      return "EventOnSyncServerProgress";
    case FuncRequestEventName.EventOnNewConversation:
      return "EventOnNewConversation";
    case FuncRequestEventName.EventOnConversationChanged:
      return "EventOnConversationChanged";
    case FuncRequestEventName.EventOnTotalUnreadMessageCountChanged:
      return "EventOnTotalUnreadMessageCountChanged";
    case FuncRequestEventName.EventOnConversationUserInputStatusChanged:
      return "EventOnConversationUserInputStatusChanged";
    case FuncRequestEventName.EventOnRecvNewMessage:
      return "EventOnRecvNewMessage";
    case FuncRequestEventName.EventOnRecvC2CReadReceipt:
      return "EventOnRecvC2CReadReceipt";
    case FuncRequestEventName.EventOnNewRecvMessageRevoked:
      return "EventOnNewRecvMessageRevoked";
    case FuncRequestEventName.EventOnRecvOfflineNewMessage:
      return "EventOnRecvOfflineNewMessage";
    case FuncRequestEventName.EventOnMsgDeleted:
      return "EventOnMsgDeleted";
    case FuncRequestEventName.EventOnRecvOnlineOnlyMessage:
      return "EventOnRecvOnlineOnlyMessage";
    case FuncRequestEventName.EventOnMsgEdited:
      return "EventOnMsgEdited";
    case FuncRequestEventName.EventOnFriendApplicationAdded:
      return "EventOnFriendApplicationAdded";
    case FuncRequestEventName.EventOnFriendApplicationDeleted:
      return "EventOnFriendApplicationDeleted";
    case FuncRequestEventName.EventOnFriendApplicationAccepted:
      return "EventOnFriendApplicationAccepted";
    case FuncRequestEventName.EventOnFriendApplicationRejected:
      return "EventOnFriendApplicationRejected";
    case FuncRequestEventName.EventOnFriendAdded:
      return "EventOnFriendAdded";
    case FuncRequestEventName.EventOnFriendDeleted:
      return "EventOnFriendDeleted";
    case FuncRequestEventName.EventOnFriendInfoChanged:
      return "EventOnFriendInfoChanged";
    case FuncRequestEventName.EventOnBlackAdded:
      return "EventOnBlackAdded";
    case FuncRequestEventName.EventOnBlackDeleted:
      return "EventOnBlackDeleted";
    case FuncRequestEventName.EventOnJoinedGroupAdded:
      return "EventOnJoinedGroupAdded";
    case FuncRequestEventName.EventOnJoinedGroupDeleted:
      return "EventOnJoinedGroupDeleted";
    case FuncRequestEventName.EventOnGroupMemberAdded:
      return "EventOnGroupMemberAdded";
    case FuncRequestEventName.EventOnGroupMemberDeleted:
      return "EventOnGroupMemberDeleted";
    case FuncRequestEventName.EventOnGroupApplicationAdded:
      return "EventOnGroupApplicationAdded";
    case FuncRequestEventName.EventOnGroupApplicationDeleted:
      return "EventOnGroupApplicationDeleted";
    case FuncRequestEventName.EventOnGroupInfoChanged:
      return "EventOnGroupInfoChanged";
    case FuncRequestEventName.EventOnGroupDismissed:
      return "EventOnGroupDismissed";
    case FuncRequestEventName.EventOnGroupMemberInfoChanged:
      return "EventOnGroupMemberInfoChanged";
    case FuncRequestEventName.EventOnGroupApplicationAccepted:
      return "EventOnGroupApplicationAccepted";
    case FuncRequestEventName.EventOnGroupApplicationRejected:
      return "EventOnGroupApplicationRejected";
    case FuncRequestEventName.EventOnRecvCustomBusinessMessage:
      return "EventOnRecvCustomBusinessMessage";
    case FuncRequestEventName.EventOnSelfInfoUpdated:
      return "EventOnSelfInfoUpdated";
    case FuncRequestEventName.EventOnUserStatusChanged:
      return "EventOnUserStatusChanged";
    case FuncRequestEventName.EventOnUserCommandAdd:
      return "EventOnUserCommandAdd";
    case FuncRequestEventName.EventOnUserCommandDelete:
      return "EventOnUserCommandDelete";
    case FuncRequestEventName.EventOnUserCommandUpdate:
      return "EventOnUserCommandUpdate";
    case FuncRequestEventName.CreateGroup:
      return "CreateGroup";
    case FuncRequestEventName.JoinGroup:
      return "JoinGroup";
    case FuncRequestEventName.QuitGroup:
      return "QuitGroup";
    case FuncRequestEventName.DismissGroup:
      return "DismissGroup";
    case FuncRequestEventName.ChangeGroupMute:
      return "ChangeGroupMute";
    case FuncRequestEventName.ChangeGroupMemberMute:
      return "ChangeGroupMemberMute";
    case FuncRequestEventName.TransferGroupOwner:
      return "TransferGroupOwner";
    case FuncRequestEventName.KickGroupMember:
      return "KickGroupMember";
    case FuncRequestEventName.SetGroupInfo:
      return "SetGroupInfo";
    case FuncRequestEventName.SetGroupMemberInfo:
      return "SetGroupMemberInfo";
    case FuncRequestEventName.GetJoinedGroups:
      return "GetJoinedGroups";
    case FuncRequestEventName.GetJoinedGroupsPage:
      return "GetJoinedGroupsPage";
    case FuncRequestEventName.GetSpecifiedGroupsInfo:
      return "GetSpecifiedGroupsInfo";
    case FuncRequestEventName.SearchGroups:
      return "SearchGroups";
    case FuncRequestEventName.GetGroupMemberOwnerAndAdmin:
      return "GetGroupMemberOwnerAndAdmin";
    case FuncRequestEventName.GetGroupMembersByJoinTimeFilter:
      return "GetGroupMembersByJoinTimeFilter";
    case FuncRequestEventName.GetSpecifiedGroupMembersInfo:
      return "GetSpecifiedGroupMembersInfo";
    case FuncRequestEventName.GetGroupMembers:
      return "GetGroupMembers";
    case FuncRequestEventName.GetGroupRequest:
      return "GetGroupRequest";
    case FuncRequestEventName.SearchGroupMembers:
      return "SearchGroupMembers";
    case FuncRequestEventName.IsJoinGroup:
      return "IsJoinGroup";
    case FuncRequestEventName.GetUsersInGroup:
      return "GetUsersInGroup";
    case FuncRequestEventName.InviteUserToGroup:
      return "InviteUserToGroup";
    case FuncRequestEventName.HandlerGroupRequest:
      return "HandlerGroupRequest";
    case FuncRequestEventName.GetSpecifiedFriends:
      return "GetSpecifiedFriends";
    case FuncRequestEventName.AddFriend:
      return "AddFriend";
    case FuncRequestEventName.GetFriendRequests:
      return "GetFriendRequests";
    case FuncRequestEventName.HandlerFriendRequest:
      return "HandlerFriendRequest";
    case FuncRequestEventName.CheckFriend:
      return "CheckFriend";
    case FuncRequestEventName.DeleteFriend:
      return "DeleteFriend";
    case FuncRequestEventName.GetFriends:
      return "GetFriends";
    case FuncRequestEventName.GetFriendsPage:
      return "GetFriendsPage";
    case FuncRequestEventName.SearchFriends:
      return "SearchFriends";
    case FuncRequestEventName.AddBlack:
      return "AddBlack";
    case FuncRequestEventName.DeleteBlack:
      return "DeleteBlack";
    case FuncRequestEventName.GetBlacks:
      return "GetBlacks";
    case FuncRequestEventName.UpdateFriends:
      return "UpdateFriends";
    case FuncRequestEventName.GetConversationListSplit:
      return "GetConversationListSplit";
    case FuncRequestEventName.HideConversation:
      return "HideConversation";
    case FuncRequestEventName.GetAtAllTag:
      return "GetAtAllTag";
    case FuncRequestEventName.GetOneConversation:
      return "GetOneConversation";
    case FuncRequestEventName.GetMultipleConversation:
      return "GetMultipleConversation";
    case FuncRequestEventName.HideAllConversations:
      return "HideAllConversations";
    case FuncRequestEventName.SetConversationDraft:
      return "SetConversationDraft";
    case FuncRequestEventName.SetConversation:
      return "SetConversation";
    case FuncRequestEventName.GetTotalUnreadMsgCount:
      return "GetTotalUnreadMsgCount";
    case FuncRequestEventName.GetConversationIDBySessionType:
      return "GetConversationIDBySessionType";
    case FuncRequestEventName.FindMessageList:
      return "FindMessageList";
    case FuncRequestEventName.GetAdvancedHistoryMessageList:
      return "GetAdvancedHistoryMessageList";
    case FuncRequestEventName.GetAdvancedHistoryMessageListReverse:
      return "GetAdvancedHistoryMessageListReverse";
    case FuncRequestEventName.RevokeMessage:
      return "RevokeMessage";
    case FuncRequestEventName.TypingStatusUpdate:
      return "TypingStatusUpdate";
    case FuncRequestEventName.MarkConversationMessageAsRead:
      return "MarkConversationMessageAsRead";
    case FuncRequestEventName.MarkAllConversationMessageAsRead:
      return "MarkAllConversationMessageAsRead";
    case FuncRequestEventName.DeleteMessageFromLocalStorage:
      return "DeleteMessageFromLocalStorage";
    case FuncRequestEventName.DeleteMessage:
      return "DeleteMessage";
    case FuncRequestEventName.DeleteAllMsgFromLocalAndServer:
      return "DeleteAllMsgFromLocalAndServer";
    case FuncRequestEventName.DeleteAllMessageFromLocalStorage:
      return "DeleteAllMessageFromLocalStorage";
    case FuncRequestEventName.ClearConversationAndDeleteAllMsg:
      return "ClearConversationAndDeleteAllMsg";
    case FuncRequestEventName.DeleteConversationAndDeleteAllMsg:
      return "DeleteConversationAndDeleteAllMsg";
    case FuncRequestEventName.InsertSingleMessageToLocalStorage:
      return "InsertSingleMessageToLocalStorage";
    case FuncRequestEventName.InsertGroupMessageToLocalStorage:
      return "InsertGroupMessageToLocalStorage";
    case FuncRequestEventName.SearchLocalMessages:
      return "SearchLocalMessages";
    case FuncRequestEventName.SetMessageLocalEx:
      return "SetMessageLocalEx";
    case FuncRequestEventName.SearchConversation:
      return "SearchConversation";
    case FuncRequestEventName.CreateTextMessage:
      return "CreateTextMessage";
    case FuncRequestEventName.CreateAdvancedTextMessage:
      return "CreateAdvancedTextMessage";
    case FuncRequestEventName.CreateTextAtMessage:
      return "CreateTextAtMessage";
    case FuncRequestEventName.CreateLocationMessage:
      return "CreateLocationMessage";
    case FuncRequestEventName.CreateCustomMessage:
      return "CreateCustomMessage";
    case FuncRequestEventName.CreateQuoteMessage:
      return "CreateQuoteMessage";
    case FuncRequestEventName.CreateAdvancedQuoteMessage:
      return "CreateAdvancedQuoteMessage";
    case FuncRequestEventName.CreateCardMessage:
      return "CreateCardMessage";
    case FuncRequestEventName.CreateImageMessage:
      return "CreateImageMessage";
    case FuncRequestEventName.CreateSoundMessage:
      return "CreateSoundMessage";
    case FuncRequestEventName.CreateVideoMessage:
      return "CreateVideoMessage";
    case FuncRequestEventName.CreateFileMessage:
      return "CreateFileMessage";
    case FuncRequestEventName.CreateMergerMessage:
      return "CreateMergerMessage";
    case FuncRequestEventName.CreateFaceMessage:
      return "CreateFaceMessage";
    case FuncRequestEventName.CreateForwardMessage:
      return "CreateForwardMessage";
    case FuncRequestEventName.ProcessUserCommandGetAll:
      return "ProcessUserCommandGetAll";
    case FuncRequestEventName.GetSelfUserInfo:
      return "GetSelfUserInfo";
    case FuncRequestEventName.SetSelfInfo:
      return "SetSelfInfo";
    case FuncRequestEventName.ProcessUserCommandAdd:
      return "ProcessUserCommandAdd";
    case FuncRequestEventName.ProcessUserCommandDelete:
      return "ProcessUserCommandDelete";
    case FuncRequestEventName.ProcessUserCommandUpdate:
      return "ProcessUserCommandUpdate";
    case FuncRequestEventName.GetUsersInfo:
      return "GetUsersInfo";
    case FuncRequestEventName.GetUsersInfoFromServer:
      return "GetUsersInfoFromServer";
    case FuncRequestEventName.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EventOnSendMsgProgressData {
  progress: number;
}

export interface EventOnUploadFileProgressData {
  progress: number;
}

export interface EventOnUploadLogsProgressData {
  progress: number;
  total: number;
}

export interface EventOnConnectingData {
}

export interface EventOnConnectSuccessData {
}

export interface EventOnConnectFailedData {
  errCode: number;
  errMsg: string;
}

export interface EventOnKickedOfflineData {
}

export interface EventOnUserTokenExpiredData {
}

export interface EventOnUserTokenInvalidData {
  errMsg: string;
}

export interface EventOnSyncServerStartData {
  reinstalled: boolean;
}

export interface EventOnSyncServerFinishData {
  reinstalled: boolean;
}

export interface EventOnSyncServerFailedData {
  reinstalled: boolean;
}

export interface EventOnSyncServerProgressData {
  progress: number;
}

export interface EventOnNewConversationData {
  conversationList: Conversation[];
}

export interface EventOnConversationChangedData {
  conversationList: Conversation[];
}

export interface EventOnTotalUnreadMessageCountChangedData {
  totalUnreadCount: number;
}

export interface EventOnConversationUserInputStatusChangedData {
  conversationID: string;
  userID: string;
  platformIDs: number[];
}

export interface EventOnRecvNewMessageData {
  message: IMMessage | undefined;
}

export interface MessageReceipt {
  groupID: string;
  userID: string;
  msgIDList: string[];
  readTime: number;
  msgFrom: number;
  contentType: number;
  sessionType: number;
}

export interface EventOnRecvC2CReadReceiptData {
  msgReceiptList: MessageReceipt[];
}

export interface MessageRevoked {
  revokerID: string;
  revokerRole: number;
  clientMsgID: string;
  revokerNickname: string;
  revokeTime: number;
  sourceMessageSendTime: number;
  sourceMessageSendID: string;
  sourceMessageSenderNickname: string;
  sessionType: number;
  seq: number;
  ex: string;
  isAdminRevoke: boolean;
}

export interface EventOnNewRecvMessageRevokedData {
  messageRevoked: MessageRevoked | undefined;
}

export interface EventOnRecvOfflineNewMessageData {
  message: IMMessage | undefined;
}

export interface EventOnMsgDeletedData {
  message: IMMessage | undefined;
}

export interface EventOnRecvOnlineOnlyMessageData {
  message: IMMessage | undefined;
}

export interface EventOnMsgEditedData {
  message: IMMessage | undefined;
}

/** FriendCallback Data Types */
export interface EventOnFriendApplicationAddedData {
  request: FriendRequestInfo | undefined;
}

export interface EventOnFriendApplicationDeletedData {
  request: FriendRequestInfo | undefined;
}

export interface EventOnFriendApplicationAcceptedData {
  request: FriendRequestInfo | undefined;
}

export interface EventOnFriendApplicationRejectedData {
  request: FriendRequestInfo | undefined;
}

export interface EventOnFriendAddedData {
  friend: FriendInfo | undefined;
}

export interface EventOnFriendDeletedData {
  friend: FriendInfo | undefined;
}

export interface EventOnFriendInfoChangedData {
  friend: FriendInfo | undefined;
}

export interface EventOnBlackAddedData {
  black: BlackInfo | undefined;
}

export interface EventOnBlackDeletedData {
  black: BlackInfo | undefined;
}

/** GroupCallback Data Types */
export interface EventOnJoinedGroupAddedData {
  group: GroupInfo | undefined;
}

export interface EventOnJoinedGroupDeletedData {
  group: GroupInfo | undefined;
}

export interface EventOnGroupMemberAddedData {
  member: GroupMemberInfo | undefined;
}

export interface EventOnGroupMemberDeletedData {
  member: GroupMemberInfo | undefined;
}

export interface EventOnGroupApplicationAddedData {
  request: GroupRequestInfo | undefined;
}

export interface EventOnGroupApplicationDeletedData {
  request: GroupRequestInfo | undefined;
}

export interface EventOnGroupInfoChangedData {
  group: GroupInfo | undefined;
}

export interface EventOnGroupDismissedData {
  group: GroupInfo | undefined;
}

export interface EventOnGroupMemberInfoChangedData {
  member: GroupMemberInfo | undefined;
}

export interface EventOnGroupApplicationAcceptedData {
  request: GroupRequestInfo | undefined;
}

export interface EventOnGroupApplicationRejectedData {
  request: GroupRequestInfo | undefined;
}

/** CustomBusinessCallback Data Type */
export interface EventOnRecvCustomBusinessMessageData {
  businessMessage: string;
}

/** UserCallback Data Types */
export interface EventOnSelfInfoUpdatedData {
  user: UserInfo | undefined;
}

export interface EventOnUserStatusChangedData {
  userID: string;
  platformIDs: number[];
}

export interface EventOnUserCommandAddData {
  command: CommandInfo | undefined;
}

export interface EventOnUserCommandDeleteData {
  command: CommandInfo | undefined;
}

export interface EventOnUserCommandUpdateData {
  command: CommandInfo | undefined;
}

function createBaseEventOnSendMsgProgressData(): EventOnSendMsgProgressData {
  return { progress: 0 };
}

export const EventOnSendMsgProgressData: MessageFns<EventOnSendMsgProgressData> = {
  encode(message: EventOnSendMsgProgressData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progress !== 0) {
      writer.uint32(8).int32(message.progress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnSendMsgProgressData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnSendMsgProgressData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.progress = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnSendMsgProgressData {
    return { progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0 };
  },

  toJSON(message: EventOnSendMsgProgressData): unknown {
    const obj: any = {};
    if (message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnSendMsgProgressData>, I>>(base?: I): EventOnSendMsgProgressData {
    return EventOnSendMsgProgressData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnSendMsgProgressData>, I>>(object: I): EventOnSendMsgProgressData {
    const message = createBaseEventOnSendMsgProgressData();
    message.progress = object.progress ?? 0;
    return message;
  },
};

function createBaseEventOnUploadFileProgressData(): EventOnUploadFileProgressData {
  return { progress: 0 };
}

export const EventOnUploadFileProgressData: MessageFns<EventOnUploadFileProgressData> = {
  encode(message: EventOnUploadFileProgressData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progress !== 0) {
      writer.uint32(8).int32(message.progress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnUploadFileProgressData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnUploadFileProgressData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.progress = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnUploadFileProgressData {
    return { progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0 };
  },

  toJSON(message: EventOnUploadFileProgressData): unknown {
    const obj: any = {};
    if (message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnUploadFileProgressData>, I>>(base?: I): EventOnUploadFileProgressData {
    return EventOnUploadFileProgressData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnUploadFileProgressData>, I>>(
    object: I,
  ): EventOnUploadFileProgressData {
    const message = createBaseEventOnUploadFileProgressData();
    message.progress = object.progress ?? 0;
    return message;
  },
};

function createBaseEventOnUploadLogsProgressData(): EventOnUploadLogsProgressData {
  return { progress: 0, total: 0 };
}

export const EventOnUploadLogsProgressData: MessageFns<EventOnUploadLogsProgressData> = {
  encode(message: EventOnUploadLogsProgressData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progress !== 0) {
      writer.uint32(8).int64(message.progress);
    }
    if (message.total !== 0) {
      writer.uint32(16).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnUploadLogsProgressData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnUploadLogsProgressData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.progress = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnUploadLogsProgressData {
    return {
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: EventOnUploadLogsProgressData): unknown {
    const obj: any = {};
    if (message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnUploadLogsProgressData>, I>>(base?: I): EventOnUploadLogsProgressData {
    return EventOnUploadLogsProgressData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnUploadLogsProgressData>, I>>(
    object: I,
  ): EventOnUploadLogsProgressData {
    const message = createBaseEventOnUploadLogsProgressData();
    message.progress = object.progress ?? 0;
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseEventOnConnectingData(): EventOnConnectingData {
  return {};
}

export const EventOnConnectingData: MessageFns<EventOnConnectingData> = {
  encode(_: EventOnConnectingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnConnectingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnConnectingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EventOnConnectingData {
    return {};
  },

  toJSON(_: EventOnConnectingData): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnConnectingData>, I>>(base?: I): EventOnConnectingData {
    return EventOnConnectingData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnConnectingData>, I>>(_: I): EventOnConnectingData {
    const message = createBaseEventOnConnectingData();
    return message;
  },
};

function createBaseEventOnConnectSuccessData(): EventOnConnectSuccessData {
  return {};
}

export const EventOnConnectSuccessData: MessageFns<EventOnConnectSuccessData> = {
  encode(_: EventOnConnectSuccessData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnConnectSuccessData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnConnectSuccessData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EventOnConnectSuccessData {
    return {};
  },

  toJSON(_: EventOnConnectSuccessData): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnConnectSuccessData>, I>>(base?: I): EventOnConnectSuccessData {
    return EventOnConnectSuccessData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnConnectSuccessData>, I>>(_: I): EventOnConnectSuccessData {
    const message = createBaseEventOnConnectSuccessData();
    return message;
  },
};

function createBaseEventOnConnectFailedData(): EventOnConnectFailedData {
  return { errCode: 0, errMsg: "" };
}

export const EventOnConnectFailedData: MessageFns<EventOnConnectFailedData> = {
  encode(message: EventOnConnectFailedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errCode !== 0) {
      writer.uint32(8).int32(message.errCode);
    }
    if (message.errMsg !== "") {
      writer.uint32(18).string(message.errMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnConnectFailedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnConnectFailedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errCode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errMsg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnConnectFailedData {
    return {
      errCode: isSet(object.errCode) ? globalThis.Number(object.errCode) : 0,
      errMsg: isSet(object.errMsg) ? globalThis.String(object.errMsg) : "",
    };
  },

  toJSON(message: EventOnConnectFailedData): unknown {
    const obj: any = {};
    if (message.errCode !== 0) {
      obj.errCode = Math.round(message.errCode);
    }
    if (message.errMsg !== "") {
      obj.errMsg = message.errMsg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnConnectFailedData>, I>>(base?: I): EventOnConnectFailedData {
    return EventOnConnectFailedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnConnectFailedData>, I>>(object: I): EventOnConnectFailedData {
    const message = createBaseEventOnConnectFailedData();
    message.errCode = object.errCode ?? 0;
    message.errMsg = object.errMsg ?? "";
    return message;
  },
};

function createBaseEventOnKickedOfflineData(): EventOnKickedOfflineData {
  return {};
}

export const EventOnKickedOfflineData: MessageFns<EventOnKickedOfflineData> = {
  encode(_: EventOnKickedOfflineData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnKickedOfflineData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnKickedOfflineData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EventOnKickedOfflineData {
    return {};
  },

  toJSON(_: EventOnKickedOfflineData): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnKickedOfflineData>, I>>(base?: I): EventOnKickedOfflineData {
    return EventOnKickedOfflineData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnKickedOfflineData>, I>>(_: I): EventOnKickedOfflineData {
    const message = createBaseEventOnKickedOfflineData();
    return message;
  },
};

function createBaseEventOnUserTokenExpiredData(): EventOnUserTokenExpiredData {
  return {};
}

export const EventOnUserTokenExpiredData: MessageFns<EventOnUserTokenExpiredData> = {
  encode(_: EventOnUserTokenExpiredData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnUserTokenExpiredData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnUserTokenExpiredData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EventOnUserTokenExpiredData {
    return {};
  },

  toJSON(_: EventOnUserTokenExpiredData): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnUserTokenExpiredData>, I>>(base?: I): EventOnUserTokenExpiredData {
    return EventOnUserTokenExpiredData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnUserTokenExpiredData>, I>>(_: I): EventOnUserTokenExpiredData {
    const message = createBaseEventOnUserTokenExpiredData();
    return message;
  },
};

function createBaseEventOnUserTokenInvalidData(): EventOnUserTokenInvalidData {
  return { errMsg: "" };
}

export const EventOnUserTokenInvalidData: MessageFns<EventOnUserTokenInvalidData> = {
  encode(message: EventOnUserTokenInvalidData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errMsg !== "") {
      writer.uint32(10).string(message.errMsg);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnUserTokenInvalidData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnUserTokenInvalidData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errMsg = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnUserTokenInvalidData {
    return { errMsg: isSet(object.errMsg) ? globalThis.String(object.errMsg) : "" };
  },

  toJSON(message: EventOnUserTokenInvalidData): unknown {
    const obj: any = {};
    if (message.errMsg !== "") {
      obj.errMsg = message.errMsg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnUserTokenInvalidData>, I>>(base?: I): EventOnUserTokenInvalidData {
    return EventOnUserTokenInvalidData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnUserTokenInvalidData>, I>>(object: I): EventOnUserTokenInvalidData {
    const message = createBaseEventOnUserTokenInvalidData();
    message.errMsg = object.errMsg ?? "";
    return message;
  },
};

function createBaseEventOnSyncServerStartData(): EventOnSyncServerStartData {
  return { reinstalled: false };
}

export const EventOnSyncServerStartData: MessageFns<EventOnSyncServerStartData> = {
  encode(message: EventOnSyncServerStartData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reinstalled !== false) {
      writer.uint32(8).bool(message.reinstalled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnSyncServerStartData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnSyncServerStartData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reinstalled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnSyncServerStartData {
    return { reinstalled: isSet(object.reinstalled) ? globalThis.Boolean(object.reinstalled) : false };
  },

  toJSON(message: EventOnSyncServerStartData): unknown {
    const obj: any = {};
    if (message.reinstalled !== false) {
      obj.reinstalled = message.reinstalled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnSyncServerStartData>, I>>(base?: I): EventOnSyncServerStartData {
    return EventOnSyncServerStartData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnSyncServerStartData>, I>>(object: I): EventOnSyncServerStartData {
    const message = createBaseEventOnSyncServerStartData();
    message.reinstalled = object.reinstalled ?? false;
    return message;
  },
};

function createBaseEventOnSyncServerFinishData(): EventOnSyncServerFinishData {
  return { reinstalled: false };
}

export const EventOnSyncServerFinishData: MessageFns<EventOnSyncServerFinishData> = {
  encode(message: EventOnSyncServerFinishData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reinstalled !== false) {
      writer.uint32(8).bool(message.reinstalled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnSyncServerFinishData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnSyncServerFinishData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reinstalled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnSyncServerFinishData {
    return { reinstalled: isSet(object.reinstalled) ? globalThis.Boolean(object.reinstalled) : false };
  },

  toJSON(message: EventOnSyncServerFinishData): unknown {
    const obj: any = {};
    if (message.reinstalled !== false) {
      obj.reinstalled = message.reinstalled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnSyncServerFinishData>, I>>(base?: I): EventOnSyncServerFinishData {
    return EventOnSyncServerFinishData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnSyncServerFinishData>, I>>(object: I): EventOnSyncServerFinishData {
    const message = createBaseEventOnSyncServerFinishData();
    message.reinstalled = object.reinstalled ?? false;
    return message;
  },
};

function createBaseEventOnSyncServerFailedData(): EventOnSyncServerFailedData {
  return { reinstalled: false };
}

export const EventOnSyncServerFailedData: MessageFns<EventOnSyncServerFailedData> = {
  encode(message: EventOnSyncServerFailedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reinstalled !== false) {
      writer.uint32(8).bool(message.reinstalled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnSyncServerFailedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnSyncServerFailedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reinstalled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnSyncServerFailedData {
    return { reinstalled: isSet(object.reinstalled) ? globalThis.Boolean(object.reinstalled) : false };
  },

  toJSON(message: EventOnSyncServerFailedData): unknown {
    const obj: any = {};
    if (message.reinstalled !== false) {
      obj.reinstalled = message.reinstalled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnSyncServerFailedData>, I>>(base?: I): EventOnSyncServerFailedData {
    return EventOnSyncServerFailedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnSyncServerFailedData>, I>>(object: I): EventOnSyncServerFailedData {
    const message = createBaseEventOnSyncServerFailedData();
    message.reinstalled = object.reinstalled ?? false;
    return message;
  },
};

function createBaseEventOnSyncServerProgressData(): EventOnSyncServerProgressData {
  return { progress: 0 };
}

export const EventOnSyncServerProgressData: MessageFns<EventOnSyncServerProgressData> = {
  encode(message: EventOnSyncServerProgressData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progress !== 0) {
      writer.uint32(8).int32(message.progress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnSyncServerProgressData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnSyncServerProgressData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.progress = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnSyncServerProgressData {
    return { progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0 };
  },

  toJSON(message: EventOnSyncServerProgressData): unknown {
    const obj: any = {};
    if (message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnSyncServerProgressData>, I>>(base?: I): EventOnSyncServerProgressData {
    return EventOnSyncServerProgressData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnSyncServerProgressData>, I>>(
    object: I,
  ): EventOnSyncServerProgressData {
    const message = createBaseEventOnSyncServerProgressData();
    message.progress = object.progress ?? 0;
    return message;
  },
};

function createBaseEventOnNewConversationData(): EventOnNewConversationData {
  return { conversationList: [] };
}

export const EventOnNewConversationData: MessageFns<EventOnNewConversationData> = {
  encode(message: EventOnNewConversationData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversationList) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnNewConversationData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnNewConversationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationList.push(Conversation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnNewConversationData {
    return {
      conversationList: globalThis.Array.isArray(object?.conversationList)
        ? object.conversationList.map((e: any) => Conversation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventOnNewConversationData): unknown {
    const obj: any = {};
    if (message.conversationList?.length) {
      obj.conversationList = message.conversationList.map((e) => Conversation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnNewConversationData>, I>>(base?: I): EventOnNewConversationData {
    return EventOnNewConversationData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnNewConversationData>, I>>(object: I): EventOnNewConversationData {
    const message = createBaseEventOnNewConversationData();
    message.conversationList = object.conversationList?.map((e) => Conversation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventOnConversationChangedData(): EventOnConversationChangedData {
  return { conversationList: [] };
}

export const EventOnConversationChangedData: MessageFns<EventOnConversationChangedData> = {
  encode(message: EventOnConversationChangedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversationList) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnConversationChangedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnConversationChangedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversationList.push(Conversation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnConversationChangedData {
    return {
      conversationList: globalThis.Array.isArray(object?.conversationList)
        ? object.conversationList.map((e: any) => Conversation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventOnConversationChangedData): unknown {
    const obj: any = {};
    if (message.conversationList?.length) {
      obj.conversationList = message.conversationList.map((e) => Conversation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnConversationChangedData>, I>>(base?: I): EventOnConversationChangedData {
    return EventOnConversationChangedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnConversationChangedData>, I>>(
    object: I,
  ): EventOnConversationChangedData {
    const message = createBaseEventOnConversationChangedData();
    message.conversationList = object.conversationList?.map((e) => Conversation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventOnTotalUnreadMessageCountChangedData(): EventOnTotalUnreadMessageCountChangedData {
  return { totalUnreadCount: 0 };
}

export const EventOnTotalUnreadMessageCountChangedData: MessageFns<EventOnTotalUnreadMessageCountChangedData> = {
  encode(message: EventOnTotalUnreadMessageCountChangedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalUnreadCount !== 0) {
      writer.uint32(8).int32(message.totalUnreadCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnTotalUnreadMessageCountChangedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnTotalUnreadMessageCountChangedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalUnreadCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnTotalUnreadMessageCountChangedData {
    return { totalUnreadCount: isSet(object.totalUnreadCount) ? globalThis.Number(object.totalUnreadCount) : 0 };
  },

  toJSON(message: EventOnTotalUnreadMessageCountChangedData): unknown {
    const obj: any = {};
    if (message.totalUnreadCount !== 0) {
      obj.totalUnreadCount = Math.round(message.totalUnreadCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnTotalUnreadMessageCountChangedData>, I>>(
    base?: I,
  ): EventOnTotalUnreadMessageCountChangedData {
    return EventOnTotalUnreadMessageCountChangedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnTotalUnreadMessageCountChangedData>, I>>(
    object: I,
  ): EventOnTotalUnreadMessageCountChangedData {
    const message = createBaseEventOnTotalUnreadMessageCountChangedData();
    message.totalUnreadCount = object.totalUnreadCount ?? 0;
    return message;
  },
};

function createBaseEventOnConversationUserInputStatusChangedData(): EventOnConversationUserInputStatusChangedData {
  return { conversationID: "", userID: "", platformIDs: [] };
}

export const EventOnConversationUserInputStatusChangedData: MessageFns<EventOnConversationUserInputStatusChangedData> =
  {
    encode(
      message: EventOnConversationUserInputStatusChangedData,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.conversationID !== "") {
        writer.uint32(10).string(message.conversationID);
      }
      if (message.userID !== "") {
        writer.uint32(18).string(message.userID);
      }
      writer.uint32(26).fork();
      for (const v of message.platformIDs) {
        writer.int32(v);
      }
      writer.join();
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventOnConversationUserInputStatusChangedData {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventOnConversationUserInputStatusChangedData();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.conversationID = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.userID = reader.string();
            continue;
          }
          case 3: {
            if (tag === 24) {
              message.platformIDs.push(reader.int32());

              continue;
            }

            if (tag === 26) {
              const end2 = reader.uint32() + reader.pos;
              while (reader.pos < end2) {
                message.platformIDs.push(reader.int32());
              }

              continue;
            }

            break;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventOnConversationUserInputStatusChangedData {
      return {
        conversationID: isSet(object.conversationID) ? globalThis.String(object.conversationID) : "",
        userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
        platformIDs: globalThis.Array.isArray(object?.platformIDs)
          ? object.platformIDs.map((e: any) => globalThis.Number(e))
          : [],
      };
    },

    toJSON(message: EventOnConversationUserInputStatusChangedData): unknown {
      const obj: any = {};
      if (message.conversationID !== "") {
        obj.conversationID = message.conversationID;
      }
      if (message.userID !== "") {
        obj.userID = message.userID;
      }
      if (message.platformIDs?.length) {
        obj.platformIDs = message.platformIDs.map((e) => Math.round(e));
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<EventOnConversationUserInputStatusChangedData>, I>>(
      base?: I,
    ): EventOnConversationUserInputStatusChangedData {
      return EventOnConversationUserInputStatusChangedData.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventOnConversationUserInputStatusChangedData>, I>>(
      object: I,
    ): EventOnConversationUserInputStatusChangedData {
      const message = createBaseEventOnConversationUserInputStatusChangedData();
      message.conversationID = object.conversationID ?? "";
      message.userID = object.userID ?? "";
      message.platformIDs = object.platformIDs?.map((e) => e) || [];
      return message;
    },
  };

function createBaseEventOnRecvNewMessageData(): EventOnRecvNewMessageData {
  return { message: undefined };
}

export const EventOnRecvNewMessageData: MessageFns<EventOnRecvNewMessageData> = {
  encode(message: EventOnRecvNewMessageData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnRecvNewMessageData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnRecvNewMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnRecvNewMessageData {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: EventOnRecvNewMessageData): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnRecvNewMessageData>, I>>(base?: I): EventOnRecvNewMessageData {
    return EventOnRecvNewMessageData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnRecvNewMessageData>, I>>(object: I): EventOnRecvNewMessageData {
    const message = createBaseEventOnRecvNewMessageData();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseMessageReceipt(): MessageReceipt {
  return { groupID: "", userID: "", msgIDList: [], readTime: 0, msgFrom: 0, contentType: 0, sessionType: 0 };
}

export const MessageReceipt: MessageFns<MessageReceipt> = {
  encode(message: MessageReceipt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.userID !== "") {
      writer.uint32(18).string(message.userID);
    }
    for (const v of message.msgIDList) {
      writer.uint32(26).string(v!);
    }
    if (message.readTime !== 0) {
      writer.uint32(32).int64(message.readTime);
    }
    if (message.msgFrom !== 0) {
      writer.uint32(40).int32(message.msgFrom);
    }
    if (message.contentType !== 0) {
      writer.uint32(48).int32(message.contentType);
    }
    if (message.sessionType !== 0) {
      writer.uint32(56).int32(message.sessionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageReceipt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.msgIDList.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.readTime = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.msgFrom = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.contentType = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.sessionType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReceipt {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      msgIDList: globalThis.Array.isArray(object?.msgIDList)
        ? object.msgIDList.map((e: any) => globalThis.String(e))
        : [],
      readTime: isSet(object.readTime) ? globalThis.Number(object.readTime) : 0,
      msgFrom: isSet(object.msgFrom) ? globalThis.Number(object.msgFrom) : 0,
      contentType: isSet(object.contentType) ? globalThis.Number(object.contentType) : 0,
      sessionType: isSet(object.sessionType) ? globalThis.Number(object.sessionType) : 0,
    };
  },

  toJSON(message: MessageReceipt): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.msgIDList?.length) {
      obj.msgIDList = message.msgIDList;
    }
    if (message.readTime !== 0) {
      obj.readTime = Math.round(message.readTime);
    }
    if (message.msgFrom !== 0) {
      obj.msgFrom = Math.round(message.msgFrom);
    }
    if (message.contentType !== 0) {
      obj.contentType = Math.round(message.contentType);
    }
    if (message.sessionType !== 0) {
      obj.sessionType = Math.round(message.sessionType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageReceipt>, I>>(base?: I): MessageReceipt {
    return MessageReceipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageReceipt>, I>>(object: I): MessageReceipt {
    const message = createBaseMessageReceipt();
    message.groupID = object.groupID ?? "";
    message.userID = object.userID ?? "";
    message.msgIDList = object.msgIDList?.map((e) => e) || [];
    message.readTime = object.readTime ?? 0;
    message.msgFrom = object.msgFrom ?? 0;
    message.contentType = object.contentType ?? 0;
    message.sessionType = object.sessionType ?? 0;
    return message;
  },
};

function createBaseEventOnRecvC2CReadReceiptData(): EventOnRecvC2CReadReceiptData {
  return { msgReceiptList: [] };
}

export const EventOnRecvC2CReadReceiptData: MessageFns<EventOnRecvC2CReadReceiptData> = {
  encode(message: EventOnRecvC2CReadReceiptData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.msgReceiptList) {
      MessageReceipt.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnRecvC2CReadReceiptData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnRecvC2CReadReceiptData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.msgReceiptList.push(MessageReceipt.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnRecvC2CReadReceiptData {
    return {
      msgReceiptList: globalThis.Array.isArray(object?.msgReceiptList)
        ? object.msgReceiptList.map((e: any) => MessageReceipt.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventOnRecvC2CReadReceiptData): unknown {
    const obj: any = {};
    if (message.msgReceiptList?.length) {
      obj.msgReceiptList = message.msgReceiptList.map((e) => MessageReceipt.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnRecvC2CReadReceiptData>, I>>(base?: I): EventOnRecvC2CReadReceiptData {
    return EventOnRecvC2CReadReceiptData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnRecvC2CReadReceiptData>, I>>(
    object: I,
  ): EventOnRecvC2CReadReceiptData {
    const message = createBaseEventOnRecvC2CReadReceiptData();
    message.msgReceiptList = object.msgReceiptList?.map((e) => MessageReceipt.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageRevoked(): MessageRevoked {
  return {
    revokerID: "",
    revokerRole: 0,
    clientMsgID: "",
    revokerNickname: "",
    revokeTime: 0,
    sourceMessageSendTime: 0,
    sourceMessageSendID: "",
    sourceMessageSenderNickname: "",
    sessionType: 0,
    seq: 0,
    ex: "",
    isAdminRevoke: false,
  };
}

export const MessageRevoked: MessageFns<MessageRevoked> = {
  encode(message: MessageRevoked, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revokerID !== "") {
      writer.uint32(10).string(message.revokerID);
    }
    if (message.revokerRole !== 0) {
      writer.uint32(16).int32(message.revokerRole);
    }
    if (message.clientMsgID !== "") {
      writer.uint32(26).string(message.clientMsgID);
    }
    if (message.revokerNickname !== "") {
      writer.uint32(34).string(message.revokerNickname);
    }
    if (message.revokeTime !== 0) {
      writer.uint32(40).int64(message.revokeTime);
    }
    if (message.sourceMessageSendTime !== 0) {
      writer.uint32(48).int64(message.sourceMessageSendTime);
    }
    if (message.sourceMessageSendID !== "") {
      writer.uint32(58).string(message.sourceMessageSendID);
    }
    if (message.sourceMessageSenderNickname !== "") {
      writer.uint32(66).string(message.sourceMessageSenderNickname);
    }
    if (message.sessionType !== 0) {
      writer.uint32(72).int32(message.sessionType);
    }
    if (message.seq !== 0) {
      writer.uint32(80).int64(message.seq);
    }
    if (message.ex !== "") {
      writer.uint32(90).string(message.ex);
    }
    if (message.isAdminRevoke !== false) {
      writer.uint32(96).bool(message.isAdminRevoke);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageRevoked {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageRevoked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.revokerID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.revokerRole = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientMsgID = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.revokerNickname = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.revokeTime = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sourceMessageSendTime = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sourceMessageSendID = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sourceMessageSenderNickname = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sessionType = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.seq = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.isAdminRevoke = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageRevoked {
    return {
      revokerID: isSet(object.revokerID) ? globalThis.String(object.revokerID) : "",
      revokerRole: isSet(object.revokerRole) ? globalThis.Number(object.revokerRole) : 0,
      clientMsgID: isSet(object.clientMsgID) ? globalThis.String(object.clientMsgID) : "",
      revokerNickname: isSet(object.revokerNickname) ? globalThis.String(object.revokerNickname) : "",
      revokeTime: isSet(object.revokeTime) ? globalThis.Number(object.revokeTime) : 0,
      sourceMessageSendTime: isSet(object.sourceMessageSendTime) ? globalThis.Number(object.sourceMessageSendTime) : 0,
      sourceMessageSendID: isSet(object.sourceMessageSendID) ? globalThis.String(object.sourceMessageSendID) : "",
      sourceMessageSenderNickname: isSet(object.sourceMessageSenderNickname)
        ? globalThis.String(object.sourceMessageSenderNickname)
        : "",
      sessionType: isSet(object.sessionType) ? globalThis.Number(object.sessionType) : 0,
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
      isAdminRevoke: isSet(object.isAdminRevoke) ? globalThis.Boolean(object.isAdminRevoke) : false,
    };
  },

  toJSON(message: MessageRevoked): unknown {
    const obj: any = {};
    if (message.revokerID !== "") {
      obj.revokerID = message.revokerID;
    }
    if (message.revokerRole !== 0) {
      obj.revokerRole = Math.round(message.revokerRole);
    }
    if (message.clientMsgID !== "") {
      obj.clientMsgID = message.clientMsgID;
    }
    if (message.revokerNickname !== "") {
      obj.revokerNickname = message.revokerNickname;
    }
    if (message.revokeTime !== 0) {
      obj.revokeTime = Math.round(message.revokeTime);
    }
    if (message.sourceMessageSendTime !== 0) {
      obj.sourceMessageSendTime = Math.round(message.sourceMessageSendTime);
    }
    if (message.sourceMessageSendID !== "") {
      obj.sourceMessageSendID = message.sourceMessageSendID;
    }
    if (message.sourceMessageSenderNickname !== "") {
      obj.sourceMessageSenderNickname = message.sourceMessageSenderNickname;
    }
    if (message.sessionType !== 0) {
      obj.sessionType = Math.round(message.sessionType);
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    if (message.isAdminRevoke !== false) {
      obj.isAdminRevoke = message.isAdminRevoke;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageRevoked>, I>>(base?: I): MessageRevoked {
    return MessageRevoked.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageRevoked>, I>>(object: I): MessageRevoked {
    const message = createBaseMessageRevoked();
    message.revokerID = object.revokerID ?? "";
    message.revokerRole = object.revokerRole ?? 0;
    message.clientMsgID = object.clientMsgID ?? "";
    message.revokerNickname = object.revokerNickname ?? "";
    message.revokeTime = object.revokeTime ?? 0;
    message.sourceMessageSendTime = object.sourceMessageSendTime ?? 0;
    message.sourceMessageSendID = object.sourceMessageSendID ?? "";
    message.sourceMessageSenderNickname = object.sourceMessageSenderNickname ?? "";
    message.sessionType = object.sessionType ?? 0;
    message.seq = object.seq ?? 0;
    message.ex = object.ex ?? "";
    message.isAdminRevoke = object.isAdminRevoke ?? false;
    return message;
  },
};

function createBaseEventOnNewRecvMessageRevokedData(): EventOnNewRecvMessageRevokedData {
  return { messageRevoked: undefined };
}

export const EventOnNewRecvMessageRevokedData: MessageFns<EventOnNewRecvMessageRevokedData> = {
  encode(message: EventOnNewRecvMessageRevokedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageRevoked !== undefined) {
      MessageRevoked.encode(message.messageRevoked, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnNewRecvMessageRevokedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnNewRecvMessageRevokedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageRevoked = MessageRevoked.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnNewRecvMessageRevokedData {
    return {
      messageRevoked: isSet(object.messageRevoked) ? MessageRevoked.fromJSON(object.messageRevoked) : undefined,
    };
  },

  toJSON(message: EventOnNewRecvMessageRevokedData): unknown {
    const obj: any = {};
    if (message.messageRevoked !== undefined) {
      obj.messageRevoked = MessageRevoked.toJSON(message.messageRevoked);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnNewRecvMessageRevokedData>, I>>(
    base?: I,
  ): EventOnNewRecvMessageRevokedData {
    return EventOnNewRecvMessageRevokedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnNewRecvMessageRevokedData>, I>>(
    object: I,
  ): EventOnNewRecvMessageRevokedData {
    const message = createBaseEventOnNewRecvMessageRevokedData();
    message.messageRevoked = (object.messageRevoked !== undefined && object.messageRevoked !== null)
      ? MessageRevoked.fromPartial(object.messageRevoked)
      : undefined;
    return message;
  },
};

function createBaseEventOnRecvOfflineNewMessageData(): EventOnRecvOfflineNewMessageData {
  return { message: undefined };
}

export const EventOnRecvOfflineNewMessageData: MessageFns<EventOnRecvOfflineNewMessageData> = {
  encode(message: EventOnRecvOfflineNewMessageData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnRecvOfflineNewMessageData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnRecvOfflineNewMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnRecvOfflineNewMessageData {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: EventOnRecvOfflineNewMessageData): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnRecvOfflineNewMessageData>, I>>(
    base?: I,
  ): EventOnRecvOfflineNewMessageData {
    return EventOnRecvOfflineNewMessageData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnRecvOfflineNewMessageData>, I>>(
    object: I,
  ): EventOnRecvOfflineNewMessageData {
    const message = createBaseEventOnRecvOfflineNewMessageData();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseEventOnMsgDeletedData(): EventOnMsgDeletedData {
  return { message: undefined };
}

export const EventOnMsgDeletedData: MessageFns<EventOnMsgDeletedData> = {
  encode(message: EventOnMsgDeletedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnMsgDeletedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnMsgDeletedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnMsgDeletedData {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: EventOnMsgDeletedData): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnMsgDeletedData>, I>>(base?: I): EventOnMsgDeletedData {
    return EventOnMsgDeletedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnMsgDeletedData>, I>>(object: I): EventOnMsgDeletedData {
    const message = createBaseEventOnMsgDeletedData();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseEventOnRecvOnlineOnlyMessageData(): EventOnRecvOnlineOnlyMessageData {
  return { message: undefined };
}

export const EventOnRecvOnlineOnlyMessageData: MessageFns<EventOnRecvOnlineOnlyMessageData> = {
  encode(message: EventOnRecvOnlineOnlyMessageData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnRecvOnlineOnlyMessageData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnRecvOnlineOnlyMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnRecvOnlineOnlyMessageData {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: EventOnRecvOnlineOnlyMessageData): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnRecvOnlineOnlyMessageData>, I>>(
    base?: I,
  ): EventOnRecvOnlineOnlyMessageData {
    return EventOnRecvOnlineOnlyMessageData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnRecvOnlineOnlyMessageData>, I>>(
    object: I,
  ): EventOnRecvOnlineOnlyMessageData {
    const message = createBaseEventOnRecvOnlineOnlyMessageData();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseEventOnMsgEditedData(): EventOnMsgEditedData {
  return { message: undefined };
}

export const EventOnMsgEditedData: MessageFns<EventOnMsgEditedData> = {
  encode(message: EventOnMsgEditedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      IMMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnMsgEditedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnMsgEditedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = IMMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnMsgEditedData {
    return { message: isSet(object.message) ? IMMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: EventOnMsgEditedData): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = IMMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnMsgEditedData>, I>>(base?: I): EventOnMsgEditedData {
    return EventOnMsgEditedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnMsgEditedData>, I>>(object: I): EventOnMsgEditedData {
    const message = createBaseEventOnMsgEditedData();
    message.message = (object.message !== undefined && object.message !== null)
      ? IMMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseEventOnFriendApplicationAddedData(): EventOnFriendApplicationAddedData {
  return { request: undefined };
}

export const EventOnFriendApplicationAddedData: MessageFns<EventOnFriendApplicationAddedData> = {
  encode(message: EventOnFriendApplicationAddedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      FriendRequestInfo.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnFriendApplicationAddedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnFriendApplicationAddedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = FriendRequestInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnFriendApplicationAddedData {
    return { request: isSet(object.request) ? FriendRequestInfo.fromJSON(object.request) : undefined };
  },

  toJSON(message: EventOnFriendApplicationAddedData): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = FriendRequestInfo.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnFriendApplicationAddedData>, I>>(
    base?: I,
  ): EventOnFriendApplicationAddedData {
    return EventOnFriendApplicationAddedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnFriendApplicationAddedData>, I>>(
    object: I,
  ): EventOnFriendApplicationAddedData {
    const message = createBaseEventOnFriendApplicationAddedData();
    message.request = (object.request !== undefined && object.request !== null)
      ? FriendRequestInfo.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseEventOnFriendApplicationDeletedData(): EventOnFriendApplicationDeletedData {
  return { request: undefined };
}

export const EventOnFriendApplicationDeletedData: MessageFns<EventOnFriendApplicationDeletedData> = {
  encode(message: EventOnFriendApplicationDeletedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      FriendRequestInfo.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnFriendApplicationDeletedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnFriendApplicationDeletedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = FriendRequestInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnFriendApplicationDeletedData {
    return { request: isSet(object.request) ? FriendRequestInfo.fromJSON(object.request) : undefined };
  },

  toJSON(message: EventOnFriendApplicationDeletedData): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = FriendRequestInfo.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnFriendApplicationDeletedData>, I>>(
    base?: I,
  ): EventOnFriendApplicationDeletedData {
    return EventOnFriendApplicationDeletedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnFriendApplicationDeletedData>, I>>(
    object: I,
  ): EventOnFriendApplicationDeletedData {
    const message = createBaseEventOnFriendApplicationDeletedData();
    message.request = (object.request !== undefined && object.request !== null)
      ? FriendRequestInfo.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseEventOnFriendApplicationAcceptedData(): EventOnFriendApplicationAcceptedData {
  return { request: undefined };
}

export const EventOnFriendApplicationAcceptedData: MessageFns<EventOnFriendApplicationAcceptedData> = {
  encode(message: EventOnFriendApplicationAcceptedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      FriendRequestInfo.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnFriendApplicationAcceptedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnFriendApplicationAcceptedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = FriendRequestInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnFriendApplicationAcceptedData {
    return { request: isSet(object.request) ? FriendRequestInfo.fromJSON(object.request) : undefined };
  },

  toJSON(message: EventOnFriendApplicationAcceptedData): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = FriendRequestInfo.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnFriendApplicationAcceptedData>, I>>(
    base?: I,
  ): EventOnFriendApplicationAcceptedData {
    return EventOnFriendApplicationAcceptedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnFriendApplicationAcceptedData>, I>>(
    object: I,
  ): EventOnFriendApplicationAcceptedData {
    const message = createBaseEventOnFriendApplicationAcceptedData();
    message.request = (object.request !== undefined && object.request !== null)
      ? FriendRequestInfo.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseEventOnFriendApplicationRejectedData(): EventOnFriendApplicationRejectedData {
  return { request: undefined };
}

export const EventOnFriendApplicationRejectedData: MessageFns<EventOnFriendApplicationRejectedData> = {
  encode(message: EventOnFriendApplicationRejectedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      FriendRequestInfo.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnFriendApplicationRejectedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnFriendApplicationRejectedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = FriendRequestInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnFriendApplicationRejectedData {
    return { request: isSet(object.request) ? FriendRequestInfo.fromJSON(object.request) : undefined };
  },

  toJSON(message: EventOnFriendApplicationRejectedData): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = FriendRequestInfo.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnFriendApplicationRejectedData>, I>>(
    base?: I,
  ): EventOnFriendApplicationRejectedData {
    return EventOnFriendApplicationRejectedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnFriendApplicationRejectedData>, I>>(
    object: I,
  ): EventOnFriendApplicationRejectedData {
    const message = createBaseEventOnFriendApplicationRejectedData();
    message.request = (object.request !== undefined && object.request !== null)
      ? FriendRequestInfo.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseEventOnFriendAddedData(): EventOnFriendAddedData {
  return { friend: undefined };
}

export const EventOnFriendAddedData: MessageFns<EventOnFriendAddedData> = {
  encode(message: EventOnFriendAddedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.friend !== undefined) {
      FriendInfo.encode(message.friend, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnFriendAddedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnFriendAddedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.friend = FriendInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnFriendAddedData {
    return { friend: isSet(object.friend) ? FriendInfo.fromJSON(object.friend) : undefined };
  },

  toJSON(message: EventOnFriendAddedData): unknown {
    const obj: any = {};
    if (message.friend !== undefined) {
      obj.friend = FriendInfo.toJSON(message.friend);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnFriendAddedData>, I>>(base?: I): EventOnFriendAddedData {
    return EventOnFriendAddedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnFriendAddedData>, I>>(object: I): EventOnFriendAddedData {
    const message = createBaseEventOnFriendAddedData();
    message.friend = (object.friend !== undefined && object.friend !== null)
      ? FriendInfo.fromPartial(object.friend)
      : undefined;
    return message;
  },
};

function createBaseEventOnFriendDeletedData(): EventOnFriendDeletedData {
  return { friend: undefined };
}

export const EventOnFriendDeletedData: MessageFns<EventOnFriendDeletedData> = {
  encode(message: EventOnFriendDeletedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.friend !== undefined) {
      FriendInfo.encode(message.friend, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnFriendDeletedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnFriendDeletedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.friend = FriendInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnFriendDeletedData {
    return { friend: isSet(object.friend) ? FriendInfo.fromJSON(object.friend) : undefined };
  },

  toJSON(message: EventOnFriendDeletedData): unknown {
    const obj: any = {};
    if (message.friend !== undefined) {
      obj.friend = FriendInfo.toJSON(message.friend);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnFriendDeletedData>, I>>(base?: I): EventOnFriendDeletedData {
    return EventOnFriendDeletedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnFriendDeletedData>, I>>(object: I): EventOnFriendDeletedData {
    const message = createBaseEventOnFriendDeletedData();
    message.friend = (object.friend !== undefined && object.friend !== null)
      ? FriendInfo.fromPartial(object.friend)
      : undefined;
    return message;
  },
};

function createBaseEventOnFriendInfoChangedData(): EventOnFriendInfoChangedData {
  return { friend: undefined };
}

export const EventOnFriendInfoChangedData: MessageFns<EventOnFriendInfoChangedData> = {
  encode(message: EventOnFriendInfoChangedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.friend !== undefined) {
      FriendInfo.encode(message.friend, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnFriendInfoChangedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnFriendInfoChangedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.friend = FriendInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnFriendInfoChangedData {
    return { friend: isSet(object.friend) ? FriendInfo.fromJSON(object.friend) : undefined };
  },

  toJSON(message: EventOnFriendInfoChangedData): unknown {
    const obj: any = {};
    if (message.friend !== undefined) {
      obj.friend = FriendInfo.toJSON(message.friend);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnFriendInfoChangedData>, I>>(base?: I): EventOnFriendInfoChangedData {
    return EventOnFriendInfoChangedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnFriendInfoChangedData>, I>>(object: I): EventOnFriendInfoChangedData {
    const message = createBaseEventOnFriendInfoChangedData();
    message.friend = (object.friend !== undefined && object.friend !== null)
      ? FriendInfo.fromPartial(object.friend)
      : undefined;
    return message;
  },
};

function createBaseEventOnBlackAddedData(): EventOnBlackAddedData {
  return { black: undefined };
}

export const EventOnBlackAddedData: MessageFns<EventOnBlackAddedData> = {
  encode(message: EventOnBlackAddedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.black !== undefined) {
      BlackInfo.encode(message.black, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnBlackAddedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnBlackAddedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.black = BlackInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnBlackAddedData {
    return { black: isSet(object.black) ? BlackInfo.fromJSON(object.black) : undefined };
  },

  toJSON(message: EventOnBlackAddedData): unknown {
    const obj: any = {};
    if (message.black !== undefined) {
      obj.black = BlackInfo.toJSON(message.black);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnBlackAddedData>, I>>(base?: I): EventOnBlackAddedData {
    return EventOnBlackAddedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnBlackAddedData>, I>>(object: I): EventOnBlackAddedData {
    const message = createBaseEventOnBlackAddedData();
    message.black = (object.black !== undefined && object.black !== null)
      ? BlackInfo.fromPartial(object.black)
      : undefined;
    return message;
  },
};

function createBaseEventOnBlackDeletedData(): EventOnBlackDeletedData {
  return { black: undefined };
}

export const EventOnBlackDeletedData: MessageFns<EventOnBlackDeletedData> = {
  encode(message: EventOnBlackDeletedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.black !== undefined) {
      BlackInfo.encode(message.black, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnBlackDeletedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnBlackDeletedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.black = BlackInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnBlackDeletedData {
    return { black: isSet(object.black) ? BlackInfo.fromJSON(object.black) : undefined };
  },

  toJSON(message: EventOnBlackDeletedData): unknown {
    const obj: any = {};
    if (message.black !== undefined) {
      obj.black = BlackInfo.toJSON(message.black);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnBlackDeletedData>, I>>(base?: I): EventOnBlackDeletedData {
    return EventOnBlackDeletedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnBlackDeletedData>, I>>(object: I): EventOnBlackDeletedData {
    const message = createBaseEventOnBlackDeletedData();
    message.black = (object.black !== undefined && object.black !== null)
      ? BlackInfo.fromPartial(object.black)
      : undefined;
    return message;
  },
};

function createBaseEventOnJoinedGroupAddedData(): EventOnJoinedGroupAddedData {
  return { group: undefined };
}

export const EventOnJoinedGroupAddedData: MessageFns<EventOnJoinedGroupAddedData> = {
  encode(message: EventOnJoinedGroupAddedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnJoinedGroupAddedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnJoinedGroupAddedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnJoinedGroupAddedData {
    return { group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined };
  },

  toJSON(message: EventOnJoinedGroupAddedData): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnJoinedGroupAddedData>, I>>(base?: I): EventOnJoinedGroupAddedData {
    return EventOnJoinedGroupAddedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnJoinedGroupAddedData>, I>>(object: I): EventOnJoinedGroupAddedData {
    const message = createBaseEventOnJoinedGroupAddedData();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    return message;
  },
};

function createBaseEventOnJoinedGroupDeletedData(): EventOnJoinedGroupDeletedData {
  return { group: undefined };
}

export const EventOnJoinedGroupDeletedData: MessageFns<EventOnJoinedGroupDeletedData> = {
  encode(message: EventOnJoinedGroupDeletedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnJoinedGroupDeletedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnJoinedGroupDeletedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnJoinedGroupDeletedData {
    return { group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined };
  },

  toJSON(message: EventOnJoinedGroupDeletedData): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnJoinedGroupDeletedData>, I>>(base?: I): EventOnJoinedGroupDeletedData {
    return EventOnJoinedGroupDeletedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnJoinedGroupDeletedData>, I>>(
    object: I,
  ): EventOnJoinedGroupDeletedData {
    const message = createBaseEventOnJoinedGroupDeletedData();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    return message;
  },
};

function createBaseEventOnGroupMemberAddedData(): EventOnGroupMemberAddedData {
  return { member: undefined };
}

export const EventOnGroupMemberAddedData: MessageFns<EventOnGroupMemberAddedData> = {
  encode(message: EventOnGroupMemberAddedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.member !== undefined) {
      GroupMemberInfo.encode(message.member, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnGroupMemberAddedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnGroupMemberAddedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.member = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnGroupMemberAddedData {
    return { member: isSet(object.member) ? GroupMemberInfo.fromJSON(object.member) : undefined };
  },

  toJSON(message: EventOnGroupMemberAddedData): unknown {
    const obj: any = {};
    if (message.member !== undefined) {
      obj.member = GroupMemberInfo.toJSON(message.member);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnGroupMemberAddedData>, I>>(base?: I): EventOnGroupMemberAddedData {
    return EventOnGroupMemberAddedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnGroupMemberAddedData>, I>>(object: I): EventOnGroupMemberAddedData {
    const message = createBaseEventOnGroupMemberAddedData();
    message.member = (object.member !== undefined && object.member !== null)
      ? GroupMemberInfo.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseEventOnGroupMemberDeletedData(): EventOnGroupMemberDeletedData {
  return { member: undefined };
}

export const EventOnGroupMemberDeletedData: MessageFns<EventOnGroupMemberDeletedData> = {
  encode(message: EventOnGroupMemberDeletedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.member !== undefined) {
      GroupMemberInfo.encode(message.member, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnGroupMemberDeletedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnGroupMemberDeletedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.member = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnGroupMemberDeletedData {
    return { member: isSet(object.member) ? GroupMemberInfo.fromJSON(object.member) : undefined };
  },

  toJSON(message: EventOnGroupMemberDeletedData): unknown {
    const obj: any = {};
    if (message.member !== undefined) {
      obj.member = GroupMemberInfo.toJSON(message.member);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnGroupMemberDeletedData>, I>>(base?: I): EventOnGroupMemberDeletedData {
    return EventOnGroupMemberDeletedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnGroupMemberDeletedData>, I>>(
    object: I,
  ): EventOnGroupMemberDeletedData {
    const message = createBaseEventOnGroupMemberDeletedData();
    message.member = (object.member !== undefined && object.member !== null)
      ? GroupMemberInfo.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseEventOnGroupApplicationAddedData(): EventOnGroupApplicationAddedData {
  return { request: undefined };
}

export const EventOnGroupApplicationAddedData: MessageFns<EventOnGroupApplicationAddedData> = {
  encode(message: EventOnGroupApplicationAddedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      GroupRequestInfo.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnGroupApplicationAddedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnGroupApplicationAddedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = GroupRequestInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnGroupApplicationAddedData {
    return { request: isSet(object.request) ? GroupRequestInfo.fromJSON(object.request) : undefined };
  },

  toJSON(message: EventOnGroupApplicationAddedData): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = GroupRequestInfo.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnGroupApplicationAddedData>, I>>(
    base?: I,
  ): EventOnGroupApplicationAddedData {
    return EventOnGroupApplicationAddedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnGroupApplicationAddedData>, I>>(
    object: I,
  ): EventOnGroupApplicationAddedData {
    const message = createBaseEventOnGroupApplicationAddedData();
    message.request = (object.request !== undefined && object.request !== null)
      ? GroupRequestInfo.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseEventOnGroupApplicationDeletedData(): EventOnGroupApplicationDeletedData {
  return { request: undefined };
}

export const EventOnGroupApplicationDeletedData: MessageFns<EventOnGroupApplicationDeletedData> = {
  encode(message: EventOnGroupApplicationDeletedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      GroupRequestInfo.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnGroupApplicationDeletedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnGroupApplicationDeletedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = GroupRequestInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnGroupApplicationDeletedData {
    return { request: isSet(object.request) ? GroupRequestInfo.fromJSON(object.request) : undefined };
  },

  toJSON(message: EventOnGroupApplicationDeletedData): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = GroupRequestInfo.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnGroupApplicationDeletedData>, I>>(
    base?: I,
  ): EventOnGroupApplicationDeletedData {
    return EventOnGroupApplicationDeletedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnGroupApplicationDeletedData>, I>>(
    object: I,
  ): EventOnGroupApplicationDeletedData {
    const message = createBaseEventOnGroupApplicationDeletedData();
    message.request = (object.request !== undefined && object.request !== null)
      ? GroupRequestInfo.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseEventOnGroupInfoChangedData(): EventOnGroupInfoChangedData {
  return { group: undefined };
}

export const EventOnGroupInfoChangedData: MessageFns<EventOnGroupInfoChangedData> = {
  encode(message: EventOnGroupInfoChangedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnGroupInfoChangedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnGroupInfoChangedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnGroupInfoChangedData {
    return { group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined };
  },

  toJSON(message: EventOnGroupInfoChangedData): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnGroupInfoChangedData>, I>>(base?: I): EventOnGroupInfoChangedData {
    return EventOnGroupInfoChangedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnGroupInfoChangedData>, I>>(object: I): EventOnGroupInfoChangedData {
    const message = createBaseEventOnGroupInfoChangedData();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    return message;
  },
};

function createBaseEventOnGroupDismissedData(): EventOnGroupDismissedData {
  return { group: undefined };
}

export const EventOnGroupDismissedData: MessageFns<EventOnGroupDismissedData> = {
  encode(message: EventOnGroupDismissedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      GroupInfo.encode(message.group, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnGroupDismissedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnGroupDismissedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.group = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnGroupDismissedData {
    return { group: isSet(object.group) ? GroupInfo.fromJSON(object.group) : undefined };
  },

  toJSON(message: EventOnGroupDismissedData): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = GroupInfo.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnGroupDismissedData>, I>>(base?: I): EventOnGroupDismissedData {
    return EventOnGroupDismissedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnGroupDismissedData>, I>>(object: I): EventOnGroupDismissedData {
    const message = createBaseEventOnGroupDismissedData();
    message.group = (object.group !== undefined && object.group !== null)
      ? GroupInfo.fromPartial(object.group)
      : undefined;
    return message;
  },
};

function createBaseEventOnGroupMemberInfoChangedData(): EventOnGroupMemberInfoChangedData {
  return { member: undefined };
}

export const EventOnGroupMemberInfoChangedData: MessageFns<EventOnGroupMemberInfoChangedData> = {
  encode(message: EventOnGroupMemberInfoChangedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.member !== undefined) {
      GroupMemberInfo.encode(message.member, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnGroupMemberInfoChangedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnGroupMemberInfoChangedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.member = GroupMemberInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnGroupMemberInfoChangedData {
    return { member: isSet(object.member) ? GroupMemberInfo.fromJSON(object.member) : undefined };
  },

  toJSON(message: EventOnGroupMemberInfoChangedData): unknown {
    const obj: any = {};
    if (message.member !== undefined) {
      obj.member = GroupMemberInfo.toJSON(message.member);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnGroupMemberInfoChangedData>, I>>(
    base?: I,
  ): EventOnGroupMemberInfoChangedData {
    return EventOnGroupMemberInfoChangedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnGroupMemberInfoChangedData>, I>>(
    object: I,
  ): EventOnGroupMemberInfoChangedData {
    const message = createBaseEventOnGroupMemberInfoChangedData();
    message.member = (object.member !== undefined && object.member !== null)
      ? GroupMemberInfo.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseEventOnGroupApplicationAcceptedData(): EventOnGroupApplicationAcceptedData {
  return { request: undefined };
}

export const EventOnGroupApplicationAcceptedData: MessageFns<EventOnGroupApplicationAcceptedData> = {
  encode(message: EventOnGroupApplicationAcceptedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      GroupRequestInfo.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnGroupApplicationAcceptedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnGroupApplicationAcceptedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = GroupRequestInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnGroupApplicationAcceptedData {
    return { request: isSet(object.request) ? GroupRequestInfo.fromJSON(object.request) : undefined };
  },

  toJSON(message: EventOnGroupApplicationAcceptedData): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = GroupRequestInfo.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnGroupApplicationAcceptedData>, I>>(
    base?: I,
  ): EventOnGroupApplicationAcceptedData {
    return EventOnGroupApplicationAcceptedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnGroupApplicationAcceptedData>, I>>(
    object: I,
  ): EventOnGroupApplicationAcceptedData {
    const message = createBaseEventOnGroupApplicationAcceptedData();
    message.request = (object.request !== undefined && object.request !== null)
      ? GroupRequestInfo.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseEventOnGroupApplicationRejectedData(): EventOnGroupApplicationRejectedData {
  return { request: undefined };
}

export const EventOnGroupApplicationRejectedData: MessageFns<EventOnGroupApplicationRejectedData> = {
  encode(message: EventOnGroupApplicationRejectedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      GroupRequestInfo.encode(message.request, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnGroupApplicationRejectedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnGroupApplicationRejectedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.request = GroupRequestInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnGroupApplicationRejectedData {
    return { request: isSet(object.request) ? GroupRequestInfo.fromJSON(object.request) : undefined };
  },

  toJSON(message: EventOnGroupApplicationRejectedData): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = GroupRequestInfo.toJSON(message.request);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnGroupApplicationRejectedData>, I>>(
    base?: I,
  ): EventOnGroupApplicationRejectedData {
    return EventOnGroupApplicationRejectedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnGroupApplicationRejectedData>, I>>(
    object: I,
  ): EventOnGroupApplicationRejectedData {
    const message = createBaseEventOnGroupApplicationRejectedData();
    message.request = (object.request !== undefined && object.request !== null)
      ? GroupRequestInfo.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseEventOnRecvCustomBusinessMessageData(): EventOnRecvCustomBusinessMessageData {
  return { businessMessage: "" };
}

export const EventOnRecvCustomBusinessMessageData: MessageFns<EventOnRecvCustomBusinessMessageData> = {
  encode(message: EventOnRecvCustomBusinessMessageData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.businessMessage !== "") {
      writer.uint32(10).string(message.businessMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnRecvCustomBusinessMessageData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnRecvCustomBusinessMessageData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.businessMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnRecvCustomBusinessMessageData {
    return { businessMessage: isSet(object.businessMessage) ? globalThis.String(object.businessMessage) : "" };
  },

  toJSON(message: EventOnRecvCustomBusinessMessageData): unknown {
    const obj: any = {};
    if (message.businessMessage !== "") {
      obj.businessMessage = message.businessMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnRecvCustomBusinessMessageData>, I>>(
    base?: I,
  ): EventOnRecvCustomBusinessMessageData {
    return EventOnRecvCustomBusinessMessageData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnRecvCustomBusinessMessageData>, I>>(
    object: I,
  ): EventOnRecvCustomBusinessMessageData {
    const message = createBaseEventOnRecvCustomBusinessMessageData();
    message.businessMessage = object.businessMessage ?? "";
    return message;
  },
};

function createBaseEventOnSelfInfoUpdatedData(): EventOnSelfInfoUpdatedData {
  return { user: undefined };
}

export const EventOnSelfInfoUpdatedData: MessageFns<EventOnSelfInfoUpdatedData> = {
  encode(message: EventOnSelfInfoUpdatedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnSelfInfoUpdatedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnSelfInfoUpdatedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnSelfInfoUpdatedData {
    return { user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined };
  },

  toJSON(message: EventOnSelfInfoUpdatedData): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnSelfInfoUpdatedData>, I>>(base?: I): EventOnSelfInfoUpdatedData {
    return EventOnSelfInfoUpdatedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnSelfInfoUpdatedData>, I>>(object: I): EventOnSelfInfoUpdatedData {
    const message = createBaseEventOnSelfInfoUpdatedData();
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseEventOnUserStatusChangedData(): EventOnUserStatusChangedData {
  return { userID: "", platformIDs: [] };
}

export const EventOnUserStatusChangedData: MessageFns<EventOnUserStatusChangedData> = {
  encode(message: EventOnUserStatusChangedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    writer.uint32(18).fork();
    for (const v of message.platformIDs) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnUserStatusChangedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnUserStatusChangedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.platformIDs.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.platformIDs.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnUserStatusChangedData {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      platformIDs: globalThis.Array.isArray(object?.platformIDs)
        ? object.platformIDs.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: EventOnUserStatusChangedData): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.platformIDs?.length) {
      obj.platformIDs = message.platformIDs.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnUserStatusChangedData>, I>>(base?: I): EventOnUserStatusChangedData {
    return EventOnUserStatusChangedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnUserStatusChangedData>, I>>(object: I): EventOnUserStatusChangedData {
    const message = createBaseEventOnUserStatusChangedData();
    message.userID = object.userID ?? "";
    message.platformIDs = object.platformIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseEventOnUserCommandAddData(): EventOnUserCommandAddData {
  return { command: undefined };
}

export const EventOnUserCommandAddData: MessageFns<EventOnUserCommandAddData> = {
  encode(message: EventOnUserCommandAddData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== undefined) {
      CommandInfo.encode(message.command, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnUserCommandAddData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnUserCommandAddData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = CommandInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnUserCommandAddData {
    return { command: isSet(object.command) ? CommandInfo.fromJSON(object.command) : undefined };
  },

  toJSON(message: EventOnUserCommandAddData): unknown {
    const obj: any = {};
    if (message.command !== undefined) {
      obj.command = CommandInfo.toJSON(message.command);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnUserCommandAddData>, I>>(base?: I): EventOnUserCommandAddData {
    return EventOnUserCommandAddData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnUserCommandAddData>, I>>(object: I): EventOnUserCommandAddData {
    const message = createBaseEventOnUserCommandAddData();
    message.command = (object.command !== undefined && object.command !== null)
      ? CommandInfo.fromPartial(object.command)
      : undefined;
    return message;
  },
};

function createBaseEventOnUserCommandDeleteData(): EventOnUserCommandDeleteData {
  return { command: undefined };
}

export const EventOnUserCommandDeleteData: MessageFns<EventOnUserCommandDeleteData> = {
  encode(message: EventOnUserCommandDeleteData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== undefined) {
      CommandInfo.encode(message.command, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnUserCommandDeleteData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnUserCommandDeleteData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = CommandInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnUserCommandDeleteData {
    return { command: isSet(object.command) ? CommandInfo.fromJSON(object.command) : undefined };
  },

  toJSON(message: EventOnUserCommandDeleteData): unknown {
    const obj: any = {};
    if (message.command !== undefined) {
      obj.command = CommandInfo.toJSON(message.command);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnUserCommandDeleteData>, I>>(base?: I): EventOnUserCommandDeleteData {
    return EventOnUserCommandDeleteData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnUserCommandDeleteData>, I>>(object: I): EventOnUserCommandDeleteData {
    const message = createBaseEventOnUserCommandDeleteData();
    message.command = (object.command !== undefined && object.command !== null)
      ? CommandInfo.fromPartial(object.command)
      : undefined;
    return message;
  },
};

function createBaseEventOnUserCommandUpdateData(): EventOnUserCommandUpdateData {
  return { command: undefined };
}

export const EventOnUserCommandUpdateData: MessageFns<EventOnUserCommandUpdateData> = {
  encode(message: EventOnUserCommandUpdateData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== undefined) {
      CommandInfo.encode(message.command, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOnUserCommandUpdateData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOnUserCommandUpdateData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = CommandInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOnUserCommandUpdateData {
    return { command: isSet(object.command) ? CommandInfo.fromJSON(object.command) : undefined };
  },

  toJSON(message: EventOnUserCommandUpdateData): unknown {
    const obj: any = {};
    if (message.command !== undefined) {
      obj.command = CommandInfo.toJSON(message.command);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOnUserCommandUpdateData>, I>>(base?: I): EventOnUserCommandUpdateData {
    return EventOnUserCommandUpdateData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOnUserCommandUpdateData>, I>>(object: I): EventOnUserCommandUpdateData {
    const message = createBaseEventOnUserCommandUpdateData();
    message.command = (object.command !== undefined && object.command !== null)
      ? CommandInfo.fromPartial(object.command)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
