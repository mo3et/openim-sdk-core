// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v5.27.1
// source: group.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ApprovalStatus, approvalStatusFromJSON, approvalStatusToJSON, RequestPagination } from "./common";
import {
  GroupFilter,
  groupFilterFromJSON,
  groupFilterToJSON,
  GroupInfo,
  GroupMemberInfo,
  GroupRequestInfo,
} from "./shared";

export const protobufPackage = "openim.sdk.group";

export interface CreateGroupReq {
  memberUserIDs: string[];
  adminUserIDs: string[];
  groupInfo: GroupInfo | undefined;
}

export interface CreateGroupResp {
  groupInfo: GroupInfo | undefined;
}

export interface JoinGroupReq {
  groupID: string;
  reqMessage: string;
  joinSource: number;
  ex: string;
}

export interface JoinGroupResp {
}

export interface QuitGroupReq {
  groupID: string;
}

export interface QuitGroupResp {
}

export interface DismissGroupReq {
  groupID: string;
}

export interface DismissGroupResp {
}

export interface ChangeGroupMuteReq {
  groupID: string;
  mute: boolean;
}

export interface ChangeGroupMuteResp {
}

export interface ChangeGroupMemberMuteReq {
  groupID: string;
  userID: string;
  mutedSeconds: number;
}

export interface ChangeGroupMemberMuteResp {
}

export interface TransferGroupOwnerReq {
  groupID: string;
  ownerUserID: string;
}

export interface TransferGroupOwnerResp {
}

export interface KickGroupMemberReq {
  groupID: string;
  kickedUserIDs: string[];
  reason: string;
}

export interface KickGroupMemberResp {
}

export interface SetGroupInfoReq {
  groupID: string;
  groupName?: string | undefined;
  notification?: string | undefined;
  introduction?: string | undefined;
  faceURL?: string | undefined;
  ex?: string | undefined;
  needVerification?: number | undefined;
  lookMemberInfo?: number | undefined;
  applyMemberFriend?: number | undefined;
}

export interface SetGroupInfoResp {
}

export interface SetGroupMemberInfoReq {
  groupID: string;
  userID: string;
  nickname?: string | undefined;
  faceURL?: string | undefined;
  roleLevel?: number | undefined;
  ex?: string | undefined;
}

export interface SetGroupMemberInfoResp {
}

export interface GetJoinedGroupsReq {
}

export interface GetJoinedGroupsResp {
  groups: GroupInfo[];
}

export interface GetJoinedGroupsPageReq {
  pagination: RequestPagination | undefined;
}

export interface GetJoinedGroupsPageResp {
  groups: GroupInfo[];
}

export interface GetSpecifiedGroupsInfoReq {
  groupIDs: string[];
}

export interface GetSpecifiedGroupsInfoResp {
  groups: GroupInfo[];
}

export interface SearchGroupsReq {
  keyword: string;
  searchGroupID: boolean;
  searchGroupName: boolean;
}

export interface SearchGroupsResp {
  groups: GroupInfo[];
}

export interface GetGroupMemberOwnerAndAdminReq {
  groupID: string;
}

export interface GetGroupMemberOwnerAndAdminResp {
  members: GroupMemberInfo[];
}

export interface GetGroupMembersByJoinTimeFilterReq {
  groupID: string;
  joinTimeBegin: number;
  joinTimeEnd: number;
  pagination: RequestPagination | undefined;
}

export interface GetGroupMembersByJoinTimeFilterResp {
  members: GroupMemberInfo[];
}

export interface GetSpecifiedGroupMembersInfoReq {
  groupID: string;
  userIDs: string[];
}

export interface GetSpecifiedGroupMembersInfoResp {
  members: GroupMemberInfo[];
}

export interface GetGroupMembersReq {
  groupID: string;
  filter: GroupFilter;
  pagination: RequestPagination | undefined;
}

export interface GetGroupMembersResp {
  members: GroupMemberInfo[];
}

export interface GetGroupRequestReq {
  send: boolean;
}

export interface GetGroupRequestResp {
  requests: GroupRequestInfo[];
}

export interface SearchGroupMembersReq {
  groupID: string;
  Keyword: string;
  searchUserID: boolean;
  searchMemberNickname: boolean;
  pagination: RequestPagination | undefined;
}

export interface SearchGroupMembersResp {
  members: GroupMemberInfo[];
}

export interface IsJoinGroupReq {
  groupID: string;
  userID: string;
}

export interface IsJoinGroupResp {
  joined: boolean;
}

export interface GetUsersInGroupReq {
  groupID: string;
  userIDs: string[];
}

export interface GetUsersInGroupResp {
  userIDs: string[];
}

export interface InviteUserToGroupReq {
  groupID: string;
  userIDs: string[];
  reason: string;
}

export interface InviteUserToGroupResp {
}

export interface HandlerGroupRequestReq {
  groupID: string;
  fromUserID: string;
  handledMsg: string;
  status: ApprovalStatus;
}

export interface HandlerGroupRequestResp {
}

function createBaseCreateGroupReq(): CreateGroupReq {
  return { memberUserIDs: [], adminUserIDs: [], groupInfo: undefined };
}

export const CreateGroupReq: MessageFns<CreateGroupReq> = {
  encode(message: CreateGroupReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.memberUserIDs) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.adminUserIDs) {
      writer.uint32(18).string(v!);
    }
    if (message.groupInfo !== undefined) {
      GroupInfo.encode(message.groupInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGroupReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGroupReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.memberUserIDs.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.adminUserIDs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groupInfo = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGroupReq {
    return {
      memberUserIDs: globalThis.Array.isArray(object?.memberUserIDs)
        ? object.memberUserIDs.map((e: any) => globalThis.String(e))
        : [],
      adminUserIDs: globalThis.Array.isArray(object?.adminUserIDs)
        ? object.adminUserIDs.map((e: any) => globalThis.String(e))
        : [],
      groupInfo: isSet(object.groupInfo) ? GroupInfo.fromJSON(object.groupInfo) : undefined,
    };
  },

  toJSON(message: CreateGroupReq): unknown {
    const obj: any = {};
    if (message.memberUserIDs?.length) {
      obj.memberUserIDs = message.memberUserIDs;
    }
    if (message.adminUserIDs?.length) {
      obj.adminUserIDs = message.adminUserIDs;
    }
    if (message.groupInfo !== undefined) {
      obj.groupInfo = GroupInfo.toJSON(message.groupInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGroupReq>, I>>(base?: I): CreateGroupReq {
    return CreateGroupReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGroupReq>, I>>(object: I): CreateGroupReq {
    const message = createBaseCreateGroupReq();
    message.memberUserIDs = object.memberUserIDs?.map((e) => e) || [];
    message.adminUserIDs = object.adminUserIDs?.map((e) => e) || [];
    message.groupInfo = (object.groupInfo !== undefined && object.groupInfo !== null)
      ? GroupInfo.fromPartial(object.groupInfo)
      : undefined;
    return message;
  },
};

function createBaseCreateGroupResp(): CreateGroupResp {
  return { groupInfo: undefined };
}

export const CreateGroupResp: MessageFns<CreateGroupResp> = {
  encode(message: CreateGroupResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupInfo !== undefined) {
      GroupInfo.encode(message.groupInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGroupResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGroupResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupInfo = GroupInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGroupResp {
    return { groupInfo: isSet(object.groupInfo) ? GroupInfo.fromJSON(object.groupInfo) : undefined };
  },

  toJSON(message: CreateGroupResp): unknown {
    const obj: any = {};
    if (message.groupInfo !== undefined) {
      obj.groupInfo = GroupInfo.toJSON(message.groupInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateGroupResp>, I>>(base?: I): CreateGroupResp {
    return CreateGroupResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateGroupResp>, I>>(object: I): CreateGroupResp {
    const message = createBaseCreateGroupResp();
    message.groupInfo = (object.groupInfo !== undefined && object.groupInfo !== null)
      ? GroupInfo.fromPartial(object.groupInfo)
      : undefined;
    return message;
  },
};

function createBaseJoinGroupReq(): JoinGroupReq {
  return { groupID: "", reqMessage: "", joinSource: 0, ex: "" };
}

export const JoinGroupReq: MessageFns<JoinGroupReq> = {
  encode(message: JoinGroupReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.reqMessage !== "") {
      writer.uint32(18).string(message.reqMessage);
    }
    if (message.joinSource !== 0) {
      writer.uint32(24).int32(message.joinSource);
    }
    if (message.ex !== "") {
      writer.uint32(34).string(message.ex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinGroupReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinGroupReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reqMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.joinSource = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinGroupReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      reqMessage: isSet(object.reqMessage) ? globalThis.String(object.reqMessage) : "",
      joinSource: isSet(object.joinSource) ? globalThis.Number(object.joinSource) : 0,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : "",
    };
  },

  toJSON(message: JoinGroupReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.reqMessage !== "") {
      obj.reqMessage = message.reqMessage;
    }
    if (message.joinSource !== 0) {
      obj.joinSource = Math.round(message.joinSource);
    }
    if (message.ex !== "") {
      obj.ex = message.ex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinGroupReq>, I>>(base?: I): JoinGroupReq {
    return JoinGroupReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinGroupReq>, I>>(object: I): JoinGroupReq {
    const message = createBaseJoinGroupReq();
    message.groupID = object.groupID ?? "";
    message.reqMessage = object.reqMessage ?? "";
    message.joinSource = object.joinSource ?? 0;
    message.ex = object.ex ?? "";
    return message;
  },
};

function createBaseJoinGroupResp(): JoinGroupResp {
  return {};
}

export const JoinGroupResp: MessageFns<JoinGroupResp> = {
  encode(_: JoinGroupResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinGroupResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinGroupResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): JoinGroupResp {
    return {};
  },

  toJSON(_: JoinGroupResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinGroupResp>, I>>(base?: I): JoinGroupResp {
    return JoinGroupResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinGroupResp>, I>>(_: I): JoinGroupResp {
    const message = createBaseJoinGroupResp();
    return message;
  },
};

function createBaseQuitGroupReq(): QuitGroupReq {
  return { groupID: "" };
}

export const QuitGroupReq: MessageFns<QuitGroupReq> = {
  encode(message: QuitGroupReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuitGroupReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuitGroupReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuitGroupReq {
    return { groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "" };
  },

  toJSON(message: QuitGroupReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuitGroupReq>, I>>(base?: I): QuitGroupReq {
    return QuitGroupReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuitGroupReq>, I>>(object: I): QuitGroupReq {
    const message = createBaseQuitGroupReq();
    message.groupID = object.groupID ?? "";
    return message;
  },
};

function createBaseQuitGroupResp(): QuitGroupResp {
  return {};
}

export const QuitGroupResp: MessageFns<QuitGroupResp> = {
  encode(_: QuitGroupResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuitGroupResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuitGroupResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QuitGroupResp {
    return {};
  },

  toJSON(_: QuitGroupResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QuitGroupResp>, I>>(base?: I): QuitGroupResp {
    return QuitGroupResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuitGroupResp>, I>>(_: I): QuitGroupResp {
    const message = createBaseQuitGroupResp();
    return message;
  },
};

function createBaseDismissGroupReq(): DismissGroupReq {
  return { groupID: "" };
}

export const DismissGroupReq: MessageFns<DismissGroupReq> = {
  encode(message: DismissGroupReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DismissGroupReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDismissGroupReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DismissGroupReq {
    return { groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "" };
  },

  toJSON(message: DismissGroupReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DismissGroupReq>, I>>(base?: I): DismissGroupReq {
    return DismissGroupReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DismissGroupReq>, I>>(object: I): DismissGroupReq {
    const message = createBaseDismissGroupReq();
    message.groupID = object.groupID ?? "";
    return message;
  },
};

function createBaseDismissGroupResp(): DismissGroupResp {
  return {};
}

export const DismissGroupResp: MessageFns<DismissGroupResp> = {
  encode(_: DismissGroupResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DismissGroupResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDismissGroupResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DismissGroupResp {
    return {};
  },

  toJSON(_: DismissGroupResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DismissGroupResp>, I>>(base?: I): DismissGroupResp {
    return DismissGroupResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DismissGroupResp>, I>>(_: I): DismissGroupResp {
    const message = createBaseDismissGroupResp();
    return message;
  },
};

function createBaseChangeGroupMuteReq(): ChangeGroupMuteReq {
  return { groupID: "", mute: false };
}

export const ChangeGroupMuteReq: MessageFns<ChangeGroupMuteReq> = {
  encode(message: ChangeGroupMuteReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.mute !== false) {
      writer.uint32(16).bool(message.mute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeGroupMuteReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeGroupMuteReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.mute = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeGroupMuteReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      mute: isSet(object.mute) ? globalThis.Boolean(object.mute) : false,
    };
  },

  toJSON(message: ChangeGroupMuteReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.mute !== false) {
      obj.mute = message.mute;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeGroupMuteReq>, I>>(base?: I): ChangeGroupMuteReq {
    return ChangeGroupMuteReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeGroupMuteReq>, I>>(object: I): ChangeGroupMuteReq {
    const message = createBaseChangeGroupMuteReq();
    message.groupID = object.groupID ?? "";
    message.mute = object.mute ?? false;
    return message;
  },
};

function createBaseChangeGroupMuteResp(): ChangeGroupMuteResp {
  return {};
}

export const ChangeGroupMuteResp: MessageFns<ChangeGroupMuteResp> = {
  encode(_: ChangeGroupMuteResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeGroupMuteResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeGroupMuteResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ChangeGroupMuteResp {
    return {};
  },

  toJSON(_: ChangeGroupMuteResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeGroupMuteResp>, I>>(base?: I): ChangeGroupMuteResp {
    return ChangeGroupMuteResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeGroupMuteResp>, I>>(_: I): ChangeGroupMuteResp {
    const message = createBaseChangeGroupMuteResp();
    return message;
  },
};

function createBaseChangeGroupMemberMuteReq(): ChangeGroupMemberMuteReq {
  return { groupID: "", userID: "", mutedSeconds: 0 };
}

export const ChangeGroupMemberMuteReq: MessageFns<ChangeGroupMemberMuteReq> = {
  encode(message: ChangeGroupMemberMuteReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.userID !== "") {
      writer.uint32(18).string(message.userID);
    }
    if (message.mutedSeconds !== 0) {
      writer.uint32(24).uint32(message.mutedSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeGroupMemberMuteReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeGroupMemberMuteReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mutedSeconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeGroupMemberMuteReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      mutedSeconds: isSet(object.mutedSeconds) ? globalThis.Number(object.mutedSeconds) : 0,
    };
  },

  toJSON(message: ChangeGroupMemberMuteReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.mutedSeconds !== 0) {
      obj.mutedSeconds = Math.round(message.mutedSeconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeGroupMemberMuteReq>, I>>(base?: I): ChangeGroupMemberMuteReq {
    return ChangeGroupMemberMuteReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeGroupMemberMuteReq>, I>>(object: I): ChangeGroupMemberMuteReq {
    const message = createBaseChangeGroupMemberMuteReq();
    message.groupID = object.groupID ?? "";
    message.userID = object.userID ?? "";
    message.mutedSeconds = object.mutedSeconds ?? 0;
    return message;
  },
};

function createBaseChangeGroupMemberMuteResp(): ChangeGroupMemberMuteResp {
  return {};
}

export const ChangeGroupMemberMuteResp: MessageFns<ChangeGroupMemberMuteResp> = {
  encode(_: ChangeGroupMemberMuteResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeGroupMemberMuteResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeGroupMemberMuteResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ChangeGroupMemberMuteResp {
    return {};
  },

  toJSON(_: ChangeGroupMemberMuteResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeGroupMemberMuteResp>, I>>(base?: I): ChangeGroupMemberMuteResp {
    return ChangeGroupMemberMuteResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeGroupMemberMuteResp>, I>>(_: I): ChangeGroupMemberMuteResp {
    const message = createBaseChangeGroupMemberMuteResp();
    return message;
  },
};

function createBaseTransferGroupOwnerReq(): TransferGroupOwnerReq {
  return { groupID: "", ownerUserID: "" };
}

export const TransferGroupOwnerReq: MessageFns<TransferGroupOwnerReq> = {
  encode(message: TransferGroupOwnerReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.ownerUserID !== "") {
      writer.uint32(18).string(message.ownerUserID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferGroupOwnerReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferGroupOwnerReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerUserID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferGroupOwnerReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      ownerUserID: isSet(object.ownerUserID) ? globalThis.String(object.ownerUserID) : "",
    };
  },

  toJSON(message: TransferGroupOwnerReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.ownerUserID !== "") {
      obj.ownerUserID = message.ownerUserID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferGroupOwnerReq>, I>>(base?: I): TransferGroupOwnerReq {
    return TransferGroupOwnerReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferGroupOwnerReq>, I>>(object: I): TransferGroupOwnerReq {
    const message = createBaseTransferGroupOwnerReq();
    message.groupID = object.groupID ?? "";
    message.ownerUserID = object.ownerUserID ?? "";
    return message;
  },
};

function createBaseTransferGroupOwnerResp(): TransferGroupOwnerResp {
  return {};
}

export const TransferGroupOwnerResp: MessageFns<TransferGroupOwnerResp> = {
  encode(_: TransferGroupOwnerResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferGroupOwnerResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferGroupOwnerResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TransferGroupOwnerResp {
    return {};
  },

  toJSON(_: TransferGroupOwnerResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferGroupOwnerResp>, I>>(base?: I): TransferGroupOwnerResp {
    return TransferGroupOwnerResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferGroupOwnerResp>, I>>(_: I): TransferGroupOwnerResp {
    const message = createBaseTransferGroupOwnerResp();
    return message;
  },
};

function createBaseKickGroupMemberReq(): KickGroupMemberReq {
  return { groupID: "", kickedUserIDs: [], reason: "" };
}

export const KickGroupMemberReq: MessageFns<KickGroupMemberReq> = {
  encode(message: KickGroupMemberReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    for (const v of message.kickedUserIDs) {
      writer.uint32(18).string(v!);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KickGroupMemberReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKickGroupMemberReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.kickedUserIDs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KickGroupMemberReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      kickedUserIDs: globalThis.Array.isArray(object?.kickedUserIDs)
        ? object.kickedUserIDs.map((e: any) => globalThis.String(e))
        : [],
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: KickGroupMemberReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.kickedUserIDs?.length) {
      obj.kickedUserIDs = message.kickedUserIDs;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KickGroupMemberReq>, I>>(base?: I): KickGroupMemberReq {
    return KickGroupMemberReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KickGroupMemberReq>, I>>(object: I): KickGroupMemberReq {
    const message = createBaseKickGroupMemberReq();
    message.groupID = object.groupID ?? "";
    message.kickedUserIDs = object.kickedUserIDs?.map((e) => e) || [];
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseKickGroupMemberResp(): KickGroupMemberResp {
  return {};
}

export const KickGroupMemberResp: MessageFns<KickGroupMemberResp> = {
  encode(_: KickGroupMemberResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KickGroupMemberResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKickGroupMemberResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): KickGroupMemberResp {
    return {};
  },

  toJSON(_: KickGroupMemberResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<KickGroupMemberResp>, I>>(base?: I): KickGroupMemberResp {
    return KickGroupMemberResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KickGroupMemberResp>, I>>(_: I): KickGroupMemberResp {
    const message = createBaseKickGroupMemberResp();
    return message;
  },
};

function createBaseSetGroupInfoReq(): SetGroupInfoReq {
  return {
    groupID: "",
    groupName: undefined,
    notification: undefined,
    introduction: undefined,
    faceURL: undefined,
    ex: undefined,
    needVerification: undefined,
    lookMemberInfo: undefined,
    applyMemberFriend: undefined,
  };
}

export const SetGroupInfoReq: MessageFns<SetGroupInfoReq> = {
  encode(message: SetGroupInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.groupName !== undefined) {
      writer.uint32(18).string(message.groupName);
    }
    if (message.notification !== undefined) {
      writer.uint32(26).string(message.notification);
    }
    if (message.introduction !== undefined) {
      writer.uint32(34).string(message.introduction);
    }
    if (message.faceURL !== undefined) {
      writer.uint32(42).string(message.faceURL);
    }
    if (message.ex !== undefined) {
      writer.uint32(50).string(message.ex);
    }
    if (message.needVerification !== undefined) {
      writer.uint32(56).int32(message.needVerification);
    }
    if (message.lookMemberInfo !== undefined) {
      writer.uint32(64).int32(message.lookMemberInfo);
    }
    if (message.applyMemberFriend !== undefined) {
      writer.uint32(72).int32(message.applyMemberFriend);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetGroupInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGroupInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.notification = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.introduction = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.needVerification = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.lookMemberInfo = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.applyMemberFriend = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetGroupInfoReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      groupName: isSet(object.groupName) ? globalThis.String(object.groupName) : undefined,
      notification: isSet(object.notification) ? globalThis.String(object.notification) : undefined,
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : undefined,
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : undefined,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : undefined,
      needVerification: isSet(object.needVerification) ? globalThis.Number(object.needVerification) : undefined,
      lookMemberInfo: isSet(object.lookMemberInfo) ? globalThis.Number(object.lookMemberInfo) : undefined,
      applyMemberFriend: isSet(object.applyMemberFriend) ? globalThis.Number(object.applyMemberFriend) : undefined,
    };
  },

  toJSON(message: SetGroupInfoReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.groupName !== undefined) {
      obj.groupName = message.groupName;
    }
    if (message.notification !== undefined) {
      obj.notification = message.notification;
    }
    if (message.introduction !== undefined) {
      obj.introduction = message.introduction;
    }
    if (message.faceURL !== undefined) {
      obj.faceURL = message.faceURL;
    }
    if (message.ex !== undefined) {
      obj.ex = message.ex;
    }
    if (message.needVerification !== undefined) {
      obj.needVerification = Math.round(message.needVerification);
    }
    if (message.lookMemberInfo !== undefined) {
      obj.lookMemberInfo = Math.round(message.lookMemberInfo);
    }
    if (message.applyMemberFriend !== undefined) {
      obj.applyMemberFriend = Math.round(message.applyMemberFriend);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetGroupInfoReq>, I>>(base?: I): SetGroupInfoReq {
    return SetGroupInfoReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetGroupInfoReq>, I>>(object: I): SetGroupInfoReq {
    const message = createBaseSetGroupInfoReq();
    message.groupID = object.groupID ?? "";
    message.groupName = object.groupName ?? undefined;
    message.notification = object.notification ?? undefined;
    message.introduction = object.introduction ?? undefined;
    message.faceURL = object.faceURL ?? undefined;
    message.ex = object.ex ?? undefined;
    message.needVerification = object.needVerification ?? undefined;
    message.lookMemberInfo = object.lookMemberInfo ?? undefined;
    message.applyMemberFriend = object.applyMemberFriend ?? undefined;
    return message;
  },
};

function createBaseSetGroupInfoResp(): SetGroupInfoResp {
  return {};
}

export const SetGroupInfoResp: MessageFns<SetGroupInfoResp> = {
  encode(_: SetGroupInfoResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetGroupInfoResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGroupInfoResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetGroupInfoResp {
    return {};
  },

  toJSON(_: SetGroupInfoResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetGroupInfoResp>, I>>(base?: I): SetGroupInfoResp {
    return SetGroupInfoResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetGroupInfoResp>, I>>(_: I): SetGroupInfoResp {
    const message = createBaseSetGroupInfoResp();
    return message;
  },
};

function createBaseSetGroupMemberInfoReq(): SetGroupMemberInfoReq {
  return { groupID: "", userID: "", nickname: undefined, faceURL: undefined, roleLevel: undefined, ex: undefined };
}

export const SetGroupMemberInfoReq: MessageFns<SetGroupMemberInfoReq> = {
  encode(message: SetGroupMemberInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.userID !== "") {
      writer.uint32(18).string(message.userID);
    }
    if (message.nickname !== undefined) {
      writer.uint32(26).string(message.nickname);
    }
    if (message.faceURL !== undefined) {
      writer.uint32(34).string(message.faceURL);
    }
    if (message.roleLevel !== undefined) {
      writer.uint32(40).int32(message.roleLevel);
    }
    if (message.ex !== undefined) {
      writer.uint32(50).string(message.ex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetGroupMemberInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGroupMemberInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nickname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.faceURL = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.roleLevel = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetGroupMemberInfoReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : undefined,
      faceURL: isSet(object.faceURL) ? globalThis.String(object.faceURL) : undefined,
      roleLevel: isSet(object.roleLevel) ? globalThis.Number(object.roleLevel) : undefined,
      ex: isSet(object.ex) ? globalThis.String(object.ex) : undefined,
    };
  },

  toJSON(message: SetGroupMemberInfoReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.nickname !== undefined) {
      obj.nickname = message.nickname;
    }
    if (message.faceURL !== undefined) {
      obj.faceURL = message.faceURL;
    }
    if (message.roleLevel !== undefined) {
      obj.roleLevel = Math.round(message.roleLevel);
    }
    if (message.ex !== undefined) {
      obj.ex = message.ex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetGroupMemberInfoReq>, I>>(base?: I): SetGroupMemberInfoReq {
    return SetGroupMemberInfoReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetGroupMemberInfoReq>, I>>(object: I): SetGroupMemberInfoReq {
    const message = createBaseSetGroupMemberInfoReq();
    message.groupID = object.groupID ?? "";
    message.userID = object.userID ?? "";
    message.nickname = object.nickname ?? undefined;
    message.faceURL = object.faceURL ?? undefined;
    message.roleLevel = object.roleLevel ?? undefined;
    message.ex = object.ex ?? undefined;
    return message;
  },
};

function createBaseSetGroupMemberInfoResp(): SetGroupMemberInfoResp {
  return {};
}

export const SetGroupMemberInfoResp: MessageFns<SetGroupMemberInfoResp> = {
  encode(_: SetGroupMemberInfoResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetGroupMemberInfoResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGroupMemberInfoResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetGroupMemberInfoResp {
    return {};
  },

  toJSON(_: SetGroupMemberInfoResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SetGroupMemberInfoResp>, I>>(base?: I): SetGroupMemberInfoResp {
    return SetGroupMemberInfoResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetGroupMemberInfoResp>, I>>(_: I): SetGroupMemberInfoResp {
    const message = createBaseSetGroupMemberInfoResp();
    return message;
  },
};

function createBaseGetJoinedGroupsReq(): GetJoinedGroupsReq {
  return {};
}

export const GetJoinedGroupsReq: MessageFns<GetJoinedGroupsReq> = {
  encode(_: GetJoinedGroupsReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJoinedGroupsReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJoinedGroupsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetJoinedGroupsReq {
    return {};
  },

  toJSON(_: GetJoinedGroupsReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJoinedGroupsReq>, I>>(base?: I): GetJoinedGroupsReq {
    return GetJoinedGroupsReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJoinedGroupsReq>, I>>(_: I): GetJoinedGroupsReq {
    const message = createBaseGetJoinedGroupsReq();
    return message;
  },
};

function createBaseGetJoinedGroupsResp(): GetJoinedGroupsResp {
  return { groups: [] };
}

export const GetJoinedGroupsResp: MessageFns<GetJoinedGroupsResp> = {
  encode(message: GetJoinedGroupsResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      GroupInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJoinedGroupsResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJoinedGroupsResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groups.push(GroupInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJoinedGroupsResp {
    return {
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => GroupInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetJoinedGroupsResp): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => GroupInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJoinedGroupsResp>, I>>(base?: I): GetJoinedGroupsResp {
    return GetJoinedGroupsResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJoinedGroupsResp>, I>>(object: I): GetJoinedGroupsResp {
    const message = createBaseGetJoinedGroupsResp();
    message.groups = object.groups?.map((e) => GroupInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetJoinedGroupsPageReq(): GetJoinedGroupsPageReq {
  return { pagination: undefined };
}

export const GetJoinedGroupsPageReq: MessageFns<GetJoinedGroupsPageReq> = {
  encode(message: GetJoinedGroupsPageReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      RequestPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJoinedGroupsPageReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJoinedGroupsPageReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = RequestPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJoinedGroupsPageReq {
    return { pagination: isSet(object.pagination) ? RequestPagination.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: GetJoinedGroupsPageReq): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = RequestPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJoinedGroupsPageReq>, I>>(base?: I): GetJoinedGroupsPageReq {
    return GetJoinedGroupsPageReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJoinedGroupsPageReq>, I>>(object: I): GetJoinedGroupsPageReq {
    const message = createBaseGetJoinedGroupsPageReq();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? RequestPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetJoinedGroupsPageResp(): GetJoinedGroupsPageResp {
  return { groups: [] };
}

export const GetJoinedGroupsPageResp: MessageFns<GetJoinedGroupsPageResp> = {
  encode(message: GetJoinedGroupsPageResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      GroupInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJoinedGroupsPageResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJoinedGroupsPageResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groups.push(GroupInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJoinedGroupsPageResp {
    return {
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => GroupInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetJoinedGroupsPageResp): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => GroupInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJoinedGroupsPageResp>, I>>(base?: I): GetJoinedGroupsPageResp {
    return GetJoinedGroupsPageResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJoinedGroupsPageResp>, I>>(object: I): GetJoinedGroupsPageResp {
    const message = createBaseGetJoinedGroupsPageResp();
    message.groups = object.groups?.map((e) => GroupInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetSpecifiedGroupsInfoReq(): GetSpecifiedGroupsInfoReq {
  return { groupIDs: [] };
}

export const GetSpecifiedGroupsInfoReq: MessageFns<GetSpecifiedGroupsInfoReq> = {
  encode(message: GetSpecifiedGroupsInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groupIDs) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSpecifiedGroupsInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSpecifiedGroupsInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupIDs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSpecifiedGroupsInfoReq {
    return {
      groupIDs: globalThis.Array.isArray(object?.groupIDs) ? object.groupIDs.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetSpecifiedGroupsInfoReq): unknown {
    const obj: any = {};
    if (message.groupIDs?.length) {
      obj.groupIDs = message.groupIDs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSpecifiedGroupsInfoReq>, I>>(base?: I): GetSpecifiedGroupsInfoReq {
    return GetSpecifiedGroupsInfoReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSpecifiedGroupsInfoReq>, I>>(object: I): GetSpecifiedGroupsInfoReq {
    const message = createBaseGetSpecifiedGroupsInfoReq();
    message.groupIDs = object.groupIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSpecifiedGroupsInfoResp(): GetSpecifiedGroupsInfoResp {
  return { groups: [] };
}

export const GetSpecifiedGroupsInfoResp: MessageFns<GetSpecifiedGroupsInfoResp> = {
  encode(message: GetSpecifiedGroupsInfoResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      GroupInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSpecifiedGroupsInfoResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSpecifiedGroupsInfoResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groups.push(GroupInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSpecifiedGroupsInfoResp {
    return {
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => GroupInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetSpecifiedGroupsInfoResp): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => GroupInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSpecifiedGroupsInfoResp>, I>>(base?: I): GetSpecifiedGroupsInfoResp {
    return GetSpecifiedGroupsInfoResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSpecifiedGroupsInfoResp>, I>>(object: I): GetSpecifiedGroupsInfoResp {
    const message = createBaseGetSpecifiedGroupsInfoResp();
    message.groups = object.groups?.map((e) => GroupInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchGroupsReq(): SearchGroupsReq {
  return { keyword: "", searchGroupID: false, searchGroupName: false };
}

export const SearchGroupsReq: MessageFns<SearchGroupsReq> = {
  encode(message: SearchGroupsReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyword !== "") {
      writer.uint32(10).string(message.keyword);
    }
    if (message.searchGroupID !== false) {
      writer.uint32(16).bool(message.searchGroupID);
    }
    if (message.searchGroupName !== false) {
      writer.uint32(24).bool(message.searchGroupName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchGroupsReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchGroupsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyword = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.searchGroupID = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.searchGroupName = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchGroupsReq {
    return {
      keyword: isSet(object.keyword) ? globalThis.String(object.keyword) : "",
      searchGroupID: isSet(object.searchGroupID) ? globalThis.Boolean(object.searchGroupID) : false,
      searchGroupName: isSet(object.searchGroupName) ? globalThis.Boolean(object.searchGroupName) : false,
    };
  },

  toJSON(message: SearchGroupsReq): unknown {
    const obj: any = {};
    if (message.keyword !== "") {
      obj.keyword = message.keyword;
    }
    if (message.searchGroupID !== false) {
      obj.searchGroupID = message.searchGroupID;
    }
    if (message.searchGroupName !== false) {
      obj.searchGroupName = message.searchGroupName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchGroupsReq>, I>>(base?: I): SearchGroupsReq {
    return SearchGroupsReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchGroupsReq>, I>>(object: I): SearchGroupsReq {
    const message = createBaseSearchGroupsReq();
    message.keyword = object.keyword ?? "";
    message.searchGroupID = object.searchGroupID ?? false;
    message.searchGroupName = object.searchGroupName ?? false;
    return message;
  },
};

function createBaseSearchGroupsResp(): SearchGroupsResp {
  return { groups: [] };
}

export const SearchGroupsResp: MessageFns<SearchGroupsResp> = {
  encode(message: SearchGroupsResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      GroupInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchGroupsResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchGroupsResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groups.push(GroupInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchGroupsResp {
    return {
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => GroupInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: SearchGroupsResp): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => GroupInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchGroupsResp>, I>>(base?: I): SearchGroupsResp {
    return SearchGroupsResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchGroupsResp>, I>>(object: I): SearchGroupsResp {
    const message = createBaseSearchGroupsResp();
    message.groups = object.groups?.map((e) => GroupInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetGroupMemberOwnerAndAdminReq(): GetGroupMemberOwnerAndAdminReq {
  return { groupID: "" };
}

export const GetGroupMemberOwnerAndAdminReq: MessageFns<GetGroupMemberOwnerAndAdminReq> = {
  encode(message: GetGroupMemberOwnerAndAdminReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMemberOwnerAndAdminReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMemberOwnerAndAdminReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMemberOwnerAndAdminReq {
    return { groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "" };
  },

  toJSON(message: GetGroupMemberOwnerAndAdminReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMemberOwnerAndAdminReq>, I>>(base?: I): GetGroupMemberOwnerAndAdminReq {
    return GetGroupMemberOwnerAndAdminReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMemberOwnerAndAdminReq>, I>>(
    object: I,
  ): GetGroupMemberOwnerAndAdminReq {
    const message = createBaseGetGroupMemberOwnerAndAdminReq();
    message.groupID = object.groupID ?? "";
    return message;
  },
};

function createBaseGetGroupMemberOwnerAndAdminResp(): GetGroupMemberOwnerAndAdminResp {
  return { members: [] };
}

export const GetGroupMemberOwnerAndAdminResp: MessageFns<GetGroupMemberOwnerAndAdminResp> = {
  encode(message: GetGroupMemberOwnerAndAdminResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      GroupMemberInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMemberOwnerAndAdminResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMemberOwnerAndAdminResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(GroupMemberInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMemberOwnerAndAdminResp {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => GroupMemberInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetGroupMemberOwnerAndAdminResp): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => GroupMemberInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMemberOwnerAndAdminResp>, I>>(base?: I): GetGroupMemberOwnerAndAdminResp {
    return GetGroupMemberOwnerAndAdminResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMemberOwnerAndAdminResp>, I>>(
    object: I,
  ): GetGroupMemberOwnerAndAdminResp {
    const message = createBaseGetGroupMemberOwnerAndAdminResp();
    message.members = object.members?.map((e) => GroupMemberInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetGroupMembersByJoinTimeFilterReq(): GetGroupMembersByJoinTimeFilterReq {
  return { groupID: "", joinTimeBegin: 0, joinTimeEnd: 0, pagination: undefined };
}

export const GetGroupMembersByJoinTimeFilterReq: MessageFns<GetGroupMembersByJoinTimeFilterReq> = {
  encode(message: GetGroupMembersByJoinTimeFilterReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.joinTimeBegin !== 0) {
      writer.uint32(16).int64(message.joinTimeBegin);
    }
    if (message.joinTimeEnd !== 0) {
      writer.uint32(24).int64(message.joinTimeEnd);
    }
    if (message.pagination !== undefined) {
      RequestPagination.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMembersByJoinTimeFilterReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMembersByJoinTimeFilterReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.joinTimeBegin = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.joinTimeEnd = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = RequestPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMembersByJoinTimeFilterReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      joinTimeBegin: isSet(object.joinTimeBegin) ? globalThis.Number(object.joinTimeBegin) : 0,
      joinTimeEnd: isSet(object.joinTimeEnd) ? globalThis.Number(object.joinTimeEnd) : 0,
      pagination: isSet(object.pagination) ? RequestPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetGroupMembersByJoinTimeFilterReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.joinTimeBegin !== 0) {
      obj.joinTimeBegin = Math.round(message.joinTimeBegin);
    }
    if (message.joinTimeEnd !== 0) {
      obj.joinTimeEnd = Math.round(message.joinTimeEnd);
    }
    if (message.pagination !== undefined) {
      obj.pagination = RequestPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMembersByJoinTimeFilterReq>, I>>(
    base?: I,
  ): GetGroupMembersByJoinTimeFilterReq {
    return GetGroupMembersByJoinTimeFilterReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMembersByJoinTimeFilterReq>, I>>(
    object: I,
  ): GetGroupMembersByJoinTimeFilterReq {
    const message = createBaseGetGroupMembersByJoinTimeFilterReq();
    message.groupID = object.groupID ?? "";
    message.joinTimeBegin = object.joinTimeBegin ?? 0;
    message.joinTimeEnd = object.joinTimeEnd ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? RequestPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetGroupMembersByJoinTimeFilterResp(): GetGroupMembersByJoinTimeFilterResp {
  return { members: [] };
}

export const GetGroupMembersByJoinTimeFilterResp: MessageFns<GetGroupMembersByJoinTimeFilterResp> = {
  encode(message: GetGroupMembersByJoinTimeFilterResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      GroupMemberInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMembersByJoinTimeFilterResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMembersByJoinTimeFilterResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(GroupMemberInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMembersByJoinTimeFilterResp {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => GroupMemberInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetGroupMembersByJoinTimeFilterResp): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => GroupMemberInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMembersByJoinTimeFilterResp>, I>>(
    base?: I,
  ): GetGroupMembersByJoinTimeFilterResp {
    return GetGroupMembersByJoinTimeFilterResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMembersByJoinTimeFilterResp>, I>>(
    object: I,
  ): GetGroupMembersByJoinTimeFilterResp {
    const message = createBaseGetGroupMembersByJoinTimeFilterResp();
    message.members = object.members?.map((e) => GroupMemberInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetSpecifiedGroupMembersInfoReq(): GetSpecifiedGroupMembersInfoReq {
  return { groupID: "", userIDs: [] };
}

export const GetSpecifiedGroupMembersInfoReq: MessageFns<GetSpecifiedGroupMembersInfoReq> = {
  encode(message: GetSpecifiedGroupMembersInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    for (const v of message.userIDs) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSpecifiedGroupMembersInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSpecifiedGroupMembersInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userIDs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSpecifiedGroupMembersInfoReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      userIDs: globalThis.Array.isArray(object?.userIDs) ? object.userIDs.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetSpecifiedGroupMembersInfoReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.userIDs?.length) {
      obj.userIDs = message.userIDs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSpecifiedGroupMembersInfoReq>, I>>(base?: I): GetSpecifiedGroupMembersInfoReq {
    return GetSpecifiedGroupMembersInfoReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSpecifiedGroupMembersInfoReq>, I>>(
    object: I,
  ): GetSpecifiedGroupMembersInfoReq {
    const message = createBaseGetSpecifiedGroupMembersInfoReq();
    message.groupID = object.groupID ?? "";
    message.userIDs = object.userIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSpecifiedGroupMembersInfoResp(): GetSpecifiedGroupMembersInfoResp {
  return { members: [] };
}

export const GetSpecifiedGroupMembersInfoResp: MessageFns<GetSpecifiedGroupMembersInfoResp> = {
  encode(message: GetSpecifiedGroupMembersInfoResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      GroupMemberInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSpecifiedGroupMembersInfoResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSpecifiedGroupMembersInfoResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(GroupMemberInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSpecifiedGroupMembersInfoResp {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => GroupMemberInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSpecifiedGroupMembersInfoResp): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => GroupMemberInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSpecifiedGroupMembersInfoResp>, I>>(
    base?: I,
  ): GetSpecifiedGroupMembersInfoResp {
    return GetSpecifiedGroupMembersInfoResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSpecifiedGroupMembersInfoResp>, I>>(
    object: I,
  ): GetSpecifiedGroupMembersInfoResp {
    const message = createBaseGetSpecifiedGroupMembersInfoResp();
    message.members = object.members?.map((e) => GroupMemberInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetGroupMembersReq(): GetGroupMembersReq {
  return { groupID: "", filter: 0, pagination: undefined };
}

export const GetGroupMembersReq: MessageFns<GetGroupMembersReq> = {
  encode(message: GetGroupMembersReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.filter !== 0) {
      writer.uint32(16).int32(message.filter);
    }
    if (message.pagination !== undefined) {
      RequestPagination.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMembersReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMembersReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.filter = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = RequestPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMembersReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      filter: isSet(object.filter) ? groupFilterFromJSON(object.filter) : 0,
      pagination: isSet(object.pagination) ? RequestPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetGroupMembersReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.filter !== 0) {
      obj.filter = groupFilterToJSON(message.filter);
    }
    if (message.pagination !== undefined) {
      obj.pagination = RequestPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMembersReq>, I>>(base?: I): GetGroupMembersReq {
    return GetGroupMembersReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMembersReq>, I>>(object: I): GetGroupMembersReq {
    const message = createBaseGetGroupMembersReq();
    message.groupID = object.groupID ?? "";
    message.filter = object.filter ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? RequestPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetGroupMembersResp(): GetGroupMembersResp {
  return { members: [] };
}

export const GetGroupMembersResp: MessageFns<GetGroupMembersResp> = {
  encode(message: GetGroupMembersResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      GroupMemberInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMembersResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMembersResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(GroupMemberInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMembersResp {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => GroupMemberInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetGroupMembersResp): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => GroupMemberInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMembersResp>, I>>(base?: I): GetGroupMembersResp {
    return GetGroupMembersResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMembersResp>, I>>(object: I): GetGroupMembersResp {
    const message = createBaseGetGroupMembersResp();
    message.members = object.members?.map((e) => GroupMemberInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetGroupRequestReq(): GetGroupRequestReq {
  return { send: false };
}

export const GetGroupRequestReq: MessageFns<GetGroupRequestReq> = {
  encode(message: GetGroupRequestReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.send !== false) {
      writer.uint32(8).bool(message.send);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupRequestReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupRequestReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.send = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupRequestReq {
    return { send: isSet(object.send) ? globalThis.Boolean(object.send) : false };
  },

  toJSON(message: GetGroupRequestReq): unknown {
    const obj: any = {};
    if (message.send !== false) {
      obj.send = message.send;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupRequestReq>, I>>(base?: I): GetGroupRequestReq {
    return GetGroupRequestReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupRequestReq>, I>>(object: I): GetGroupRequestReq {
    const message = createBaseGetGroupRequestReq();
    message.send = object.send ?? false;
    return message;
  },
};

function createBaseGetGroupRequestResp(): GetGroupRequestResp {
  return { requests: [] };
}

export const GetGroupRequestResp: MessageFns<GetGroupRequestResp> = {
  encode(message: GetGroupRequestResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      GroupRequestInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupRequestResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupRequestResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(GroupRequestInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupRequestResp {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => GroupRequestInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetGroupRequestResp): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => GroupRequestInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupRequestResp>, I>>(base?: I): GetGroupRequestResp {
    return GetGroupRequestResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupRequestResp>, I>>(object: I): GetGroupRequestResp {
    const message = createBaseGetGroupRequestResp();
    message.requests = object.requests?.map((e) => GroupRequestInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchGroupMembersReq(): SearchGroupMembersReq {
  return { groupID: "", Keyword: "", searchUserID: false, searchMemberNickname: false, pagination: undefined };
}

export const SearchGroupMembersReq: MessageFns<SearchGroupMembersReq> = {
  encode(message: SearchGroupMembersReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.Keyword !== "") {
      writer.uint32(18).string(message.Keyword);
    }
    if (message.searchUserID !== false) {
      writer.uint32(24).bool(message.searchUserID);
    }
    if (message.searchMemberNickname !== false) {
      writer.uint32(32).bool(message.searchMemberNickname);
    }
    if (message.pagination !== undefined) {
      RequestPagination.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchGroupMembersReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchGroupMembersReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.Keyword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.searchUserID = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.searchMemberNickname = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = RequestPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchGroupMembersReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      Keyword: isSet(object.Keyword) ? globalThis.String(object.Keyword) : "",
      searchUserID: isSet(object.searchUserID) ? globalThis.Boolean(object.searchUserID) : false,
      searchMemberNickname: isSet(object.searchMemberNickname)
        ? globalThis.Boolean(object.searchMemberNickname)
        : false,
      pagination: isSet(object.pagination) ? RequestPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: SearchGroupMembersReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.Keyword !== "") {
      obj.Keyword = message.Keyword;
    }
    if (message.searchUserID !== false) {
      obj.searchUserID = message.searchUserID;
    }
    if (message.searchMemberNickname !== false) {
      obj.searchMemberNickname = message.searchMemberNickname;
    }
    if (message.pagination !== undefined) {
      obj.pagination = RequestPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchGroupMembersReq>, I>>(base?: I): SearchGroupMembersReq {
    return SearchGroupMembersReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchGroupMembersReq>, I>>(object: I): SearchGroupMembersReq {
    const message = createBaseSearchGroupMembersReq();
    message.groupID = object.groupID ?? "";
    message.Keyword = object.Keyword ?? "";
    message.searchUserID = object.searchUserID ?? false;
    message.searchMemberNickname = object.searchMemberNickname ?? false;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? RequestPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseSearchGroupMembersResp(): SearchGroupMembersResp {
  return { members: [] };
}

export const SearchGroupMembersResp: MessageFns<SearchGroupMembersResp> = {
  encode(message: SearchGroupMembersResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      GroupMemberInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchGroupMembersResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchGroupMembersResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(GroupMemberInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchGroupMembersResp {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => GroupMemberInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchGroupMembersResp): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => GroupMemberInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchGroupMembersResp>, I>>(base?: I): SearchGroupMembersResp {
    return SearchGroupMembersResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchGroupMembersResp>, I>>(object: I): SearchGroupMembersResp {
    const message = createBaseSearchGroupMembersResp();
    message.members = object.members?.map((e) => GroupMemberInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIsJoinGroupReq(): IsJoinGroupReq {
  return { groupID: "", userID: "" };
}

export const IsJoinGroupReq: MessageFns<IsJoinGroupReq> = {
  encode(message: IsJoinGroupReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.userID !== "") {
      writer.uint32(18).string(message.userID);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsJoinGroupReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsJoinGroupReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userID = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsJoinGroupReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
    };
  },

  toJSON(message: IsJoinGroupReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsJoinGroupReq>, I>>(base?: I): IsJoinGroupReq {
    return IsJoinGroupReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsJoinGroupReq>, I>>(object: I): IsJoinGroupReq {
    const message = createBaseIsJoinGroupReq();
    message.groupID = object.groupID ?? "";
    message.userID = object.userID ?? "";
    return message;
  },
};

function createBaseIsJoinGroupResp(): IsJoinGroupResp {
  return { joined: false };
}

export const IsJoinGroupResp: MessageFns<IsJoinGroupResp> = {
  encode(message: IsJoinGroupResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joined !== false) {
      writer.uint32(8).bool(message.joined);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IsJoinGroupResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIsJoinGroupResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.joined = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IsJoinGroupResp {
    return { joined: isSet(object.joined) ? globalThis.Boolean(object.joined) : false };
  },

  toJSON(message: IsJoinGroupResp): unknown {
    const obj: any = {};
    if (message.joined !== false) {
      obj.joined = message.joined;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IsJoinGroupResp>, I>>(base?: I): IsJoinGroupResp {
    return IsJoinGroupResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IsJoinGroupResp>, I>>(object: I): IsJoinGroupResp {
    const message = createBaseIsJoinGroupResp();
    message.joined = object.joined ?? false;
    return message;
  },
};

function createBaseGetUsersInGroupReq(): GetUsersInGroupReq {
  return { groupID: "", userIDs: [] };
}

export const GetUsersInGroupReq: MessageFns<GetUsersInGroupReq> = {
  encode(message: GetUsersInGroupReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    for (const v of message.userIDs) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersInGroupReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersInGroupReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userIDs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsersInGroupReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      userIDs: globalThis.Array.isArray(object?.userIDs) ? object.userIDs.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetUsersInGroupReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.userIDs?.length) {
      obj.userIDs = message.userIDs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersInGroupReq>, I>>(base?: I): GetUsersInGroupReq {
    return GetUsersInGroupReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersInGroupReq>, I>>(object: I): GetUsersInGroupReq {
    const message = createBaseGetUsersInGroupReq();
    message.groupID = object.groupID ?? "";
    message.userIDs = object.userIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetUsersInGroupResp(): GetUsersInGroupResp {
  return { userIDs: [] };
}

export const GetUsersInGroupResp: MessageFns<GetUsersInGroupResp> = {
  encode(message: GetUsersInGroupResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userIDs) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUsersInGroupResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersInGroupResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userIDs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUsersInGroupResp {
    return {
      userIDs: globalThis.Array.isArray(object?.userIDs) ? object.userIDs.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetUsersInGroupResp): unknown {
    const obj: any = {};
    if (message.userIDs?.length) {
      obj.userIDs = message.userIDs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersInGroupResp>, I>>(base?: I): GetUsersInGroupResp {
    return GetUsersInGroupResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUsersInGroupResp>, I>>(object: I): GetUsersInGroupResp {
    const message = createBaseGetUsersInGroupResp();
    message.userIDs = object.userIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseInviteUserToGroupReq(): InviteUserToGroupReq {
  return { groupID: "", userIDs: [], reason: "" };
}

export const InviteUserToGroupReq: MessageFns<InviteUserToGroupReq> = {
  encode(message: InviteUserToGroupReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    for (const v of message.userIDs) {
      writer.uint32(18).string(v!);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InviteUserToGroupReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteUserToGroupReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userIDs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InviteUserToGroupReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      userIDs: globalThis.Array.isArray(object?.userIDs) ? object.userIDs.map((e: any) => globalThis.String(e)) : [],
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: InviteUserToGroupReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.userIDs?.length) {
      obj.userIDs = message.userIDs;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InviteUserToGroupReq>, I>>(base?: I): InviteUserToGroupReq {
    return InviteUserToGroupReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InviteUserToGroupReq>, I>>(object: I): InviteUserToGroupReq {
    const message = createBaseInviteUserToGroupReq();
    message.groupID = object.groupID ?? "";
    message.userIDs = object.userIDs?.map((e) => e) || [];
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseInviteUserToGroupResp(): InviteUserToGroupResp {
  return {};
}

export const InviteUserToGroupResp: MessageFns<InviteUserToGroupResp> = {
  encode(_: InviteUserToGroupResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InviteUserToGroupResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInviteUserToGroupResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InviteUserToGroupResp {
    return {};
  },

  toJSON(_: InviteUserToGroupResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<InviteUserToGroupResp>, I>>(base?: I): InviteUserToGroupResp {
    return InviteUserToGroupResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InviteUserToGroupResp>, I>>(_: I): InviteUserToGroupResp {
    const message = createBaseInviteUserToGroupResp();
    return message;
  },
};

function createBaseHandlerGroupRequestReq(): HandlerGroupRequestReq {
  return { groupID: "", fromUserID: "", handledMsg: "", status: 0 };
}

export const HandlerGroupRequestReq: MessageFns<HandlerGroupRequestReq> = {
  encode(message: HandlerGroupRequestReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupID !== "") {
      writer.uint32(10).string(message.groupID);
    }
    if (message.fromUserID !== "") {
      writer.uint32(18).string(message.fromUserID);
    }
    if (message.handledMsg !== "") {
      writer.uint32(26).string(message.handledMsg);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandlerGroupRequestReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandlerGroupRequestReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupID = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromUserID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.handledMsg = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandlerGroupRequestReq {
    return {
      groupID: isSet(object.groupID) ? globalThis.String(object.groupID) : "",
      fromUserID: isSet(object.fromUserID) ? globalThis.String(object.fromUserID) : "",
      handledMsg: isSet(object.handledMsg) ? globalThis.String(object.handledMsg) : "",
      status: isSet(object.status) ? approvalStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: HandlerGroupRequestReq): unknown {
    const obj: any = {};
    if (message.groupID !== "") {
      obj.groupID = message.groupID;
    }
    if (message.fromUserID !== "") {
      obj.fromUserID = message.fromUserID;
    }
    if (message.handledMsg !== "") {
      obj.handledMsg = message.handledMsg;
    }
    if (message.status !== 0) {
      obj.status = approvalStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandlerGroupRequestReq>, I>>(base?: I): HandlerGroupRequestReq {
    return HandlerGroupRequestReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandlerGroupRequestReq>, I>>(object: I): HandlerGroupRequestReq {
    const message = createBaseHandlerGroupRequestReq();
    message.groupID = object.groupID ?? "";
    message.fromUserID = object.fromUserID ?? "";
    message.handledMsg = object.handledMsg ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseHandlerGroupRequestResp(): HandlerGroupRequestResp {
  return {};
}

export const HandlerGroupRequestResp: MessageFns<HandlerGroupRequestResp> = {
  encode(_: HandlerGroupRequestResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandlerGroupRequestResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandlerGroupRequestResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HandlerGroupRequestResp {
    return {};
  },

  toJSON(_: HandlerGroupRequestResp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HandlerGroupRequestResp>, I>>(base?: I): HandlerGroupRequestResp {
    return HandlerGroupRequestResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandlerGroupRequestResp>, I>>(_: I): HandlerGroupRequestResp {
    const message = createBaseHandlerGroupRequestResp();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
